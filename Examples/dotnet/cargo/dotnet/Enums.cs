// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.Cargo
{
    /// <summary>
    /// The `edition` key affects which edition your package is compiled with. Cargo
    /// will always generate packages via [`cargo new`](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the `edition` key set to the
    /// latest edition. Setting the `edition` key in `[package]` will affect all
    /// targets/crates in the package, including test suites, benchmarks, binaries,
    /// examples, etc.
    /// </summary>
    [EnumType]
    public readonly struct DefinitionsEdition : IEquatable<DefinitionsEdition>
    {
        private readonly string _value;

        private DefinitionsEdition(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DefinitionsEdition DefinitionsEdition_2015 { get; } = new DefinitionsEdition("2015");
        public static DefinitionsEdition DefinitionsEdition_2018 { get; } = new DefinitionsEdition("2018");
        public static DefinitionsEdition DefinitionsEdition_2021 { get; } = new DefinitionsEdition("2021");
        public static DefinitionsEdition DefinitionsEdition_2024 { get; } = new DefinitionsEdition("2024");

        public static bool operator ==(DefinitionsEdition left, DefinitionsEdition right) => left.Equals(right);
        public static bool operator !=(DefinitionsEdition left, DefinitionsEdition right) => !left.Equals(right);

        public static explicit operator string(DefinitionsEdition value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefinitionsEdition other && Equals(other);
        public bool Equals(DefinitionsEdition other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The `panic` setting controls the [`-C panic` flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic) which controls which panic
    /// strategy to use.
    /// 
    /// When set to `"unwind"`, the actual value depends on the default of the target
    /// platform. For example, the NVPTX platform does not support unwinding, so it
    /// always uses `"abort"`.
    /// 
    /// Tests, benchmarks, build scripts, and proc macros ignore the `panic` setting.
    /// The `rustc` test harness currently requires `unwind` behavior. See the
    /// [`panic-abort-tests`](https://doc.rust-lang.org/cargo/reference/unstable.html#panic-abort-tests) unstable flag which enables `abort` behavior.
    /// 
    /// Additionally, when using the `abort` strategy and building a test, all of the
    /// dependencies will also be forced to built with the `unwind` strategy.
    /// </summary>
    [EnumType]
    public readonly struct DefinitionsPanic : IEquatable<DefinitionsPanic>
    {
        private readonly string _value;

        private DefinitionsPanic(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DefinitionsPanic Unwind { get; } = new DefinitionsPanic("unwind");
        public static DefinitionsPanic Abort { get; } = new DefinitionsPanic("abort");

        public static bool operator ==(DefinitionsPanic left, DefinitionsPanic right) => left.Equals(right);
        public static bool operator !=(DefinitionsPanic left, DefinitionsPanic right) => !left.Equals(right);

        public static explicit operator string(DefinitionsPanic value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefinitionsPanic other && Equals(other);
        public bool Equals(DefinitionsPanic other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A different feature resolver algorithm can be used by specifying the resolver version in Cargo.toml like this:
    /// 
    /// [package]
    /// name = "my-package"
    /// version = "1.0.0"
    /// resolver = "2"
    /// 
    /// The version "1" resolver is the original resolver that shipped with Cargo up to version 1.50. The default is "2" if the root package specifies edition = "2021" or a newer edition. Otherwise the default is "1".
    /// 
    /// The version "2" resolver introduces changes in feature unification. See the features chapter for more details.
    /// 
    /// The resolver is a global option that affects the entire workspace. The resolver version in dependencies is ignored, only the value in the top-level package will be used. If using a virtual workspace, the version should be specified in the [workspace] table, for example:
    /// 
    /// [workspace]
    /// members = ["member1", "member2"]
    /// resolver = "2"
    /// </summary>
    [EnumType]
    public readonly struct DefinitionsResolver : IEquatable<DefinitionsResolver>
    {
        private readonly string _value;

        private DefinitionsResolver(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DefinitionsResolver One { get; } = new DefinitionsResolver("1");
        public static DefinitionsResolver Two { get; } = new DefinitionsResolver("2");
        public static DefinitionsResolver Three { get; } = new DefinitionsResolver("3");

        public static bool operator ==(DefinitionsResolver left, DefinitionsResolver right) => left.Equals(right);
        public static bool operator !=(DefinitionsResolver left, DefinitionsResolver right) => !left.Equals(right);

        public static explicit operator string(DefinitionsResolver value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefinitionsResolver other && Equals(other);
        public bool Equals(DefinitionsResolver other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The `panic` setting controls the [`-C panic` flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic) which controls which panic
    /// strategy to use.
    /// 
    /// When set to `"unwind"`, the actual value depends on the default of the target
    /// platform. For example, the NVPTX platform does not support unwinding, so it
    /// always uses `"abort"`.
    /// 
    /// Tests, benchmarks, build scripts, and proc macros ignore the `panic` setting.
    /// The `rustc` test harness currently requires `unwind` behavior. See the
    /// [`panic-abort-tests`](https://doc.rust-lang.org/cargo/reference/unstable.html#panic-abort-tests) unstable flag which enables `abort` behavior.
    /// 
    /// Additionally, when using the `abort` strategy and building a test, all of the
    /// dependencies will also be forced to built with the `unwind` strategy.
    /// </summary>
    [EnumType]
    public readonly struct DevPanic : IEquatable<DevPanic>
    {
        private readonly string _value;

        private DevPanic(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DevPanic Unwind { get; } = new DevPanic("unwind");
        public static DevPanic Abort { get; } = new DevPanic("abort");

        public static bool operator ==(DevPanic left, DevPanic right) => left.Equals(right);
        public static bool operator !=(DevPanic left, DevPanic right) => !left.Equals(right);

        public static explicit operator string(DevPanic value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DevPanic other && Equals(other);
        public bool Equals(DevPanic other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The `edition` key affects which edition your package is compiled with. Cargo
    /// will always generate packages via [`cargo new`](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the `edition` key set to the
    /// latest edition. Setting the `edition` key in `[package]` will affect all
    /// targets/crates in the package, including test suites, benchmarks, binaries,
    /// examples, etc.
    /// </summary>
    [EnumType]
    public readonly struct Edition : IEquatable<Edition>
    {
        private readonly string _value;

        private Edition(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Edition Edition_2015 { get; } = new Edition("2015");
        public static Edition Edition_2018 { get; } = new Edition("2018");
        public static Edition Edition_2021 { get; } = new Edition("2021");
        public static Edition Edition_2024 { get; } = new Edition("2024");

        public static bool operator ==(Edition left, Edition right) => left.Equals(right);
        public static bool operator !=(Edition left, Edition right) => !left.Equals(right);

        public static explicit operator string(Edition value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Edition other && Equals(other);
        public bool Equals(Edition other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The `edition` key affects which edition your package is compiled with. Cargo
    /// will always generate packages via [`cargo new`](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the `edition` key set to the
    /// latest edition. Setting the `edition` key in `[package]` will affect all
    /// targets/crates in the package, including test suites, benchmarks, binaries,
    /// examples, etc.
    /// </summary>
    [EnumType]
    public readonly struct ItemsEdition : IEquatable<ItemsEdition>
    {
        private readonly string _value;

        private ItemsEdition(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ItemsEdition ItemsEdition_2015 { get; } = new ItemsEdition("2015");
        public static ItemsEdition ItemsEdition_2018 { get; } = new ItemsEdition("2018");
        public static ItemsEdition ItemsEdition_2021 { get; } = new ItemsEdition("2021");
        public static ItemsEdition ItemsEdition_2024 { get; } = new ItemsEdition("2024");

        public static bool operator ==(ItemsEdition left, ItemsEdition right) => left.Equals(right);
        public static bool operator !=(ItemsEdition left, ItemsEdition right) => !left.Equals(right);

        public static explicit operator string(ItemsEdition value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ItemsEdition other && Equals(other);
        public bool Equals(ItemsEdition other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The `edition` key affects which edition your package is compiled with. Cargo
    /// will always generate packages via [`cargo new`](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the `edition` key set to the
    /// latest edition. Setting the `edition` key in `[package]` will affect all
    /// targets/crates in the package, including test suites, benchmarks, binaries,
    /// examples, etc.
    /// </summary>
    [EnumType]
    public readonly struct LibEdition : IEquatable<LibEdition>
    {
        private readonly string _value;

        private LibEdition(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LibEdition LibEdition_2015 { get; } = new LibEdition("2015");
        public static LibEdition LibEdition_2018 { get; } = new LibEdition("2018");
        public static LibEdition LibEdition_2021 { get; } = new LibEdition("2021");
        public static LibEdition LibEdition_2024 { get; } = new LibEdition("2024");

        public static bool operator ==(LibEdition left, LibEdition right) => left.Equals(right);
        public static bool operator !=(LibEdition left, LibEdition right) => !left.Equals(right);

        public static explicit operator string(LibEdition value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LibEdition other && Equals(other);
        public bool Equals(LibEdition other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct Method : IEquatable<Method>
    {
        private readonly string _value;

        private Method(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Method Copy { get; } = new Method("copy");
        public static Method Link { get; } = new Method("link");

        public static bool operator ==(Method left, Method right) => left.Equals(right);
        public static bool operator !=(Method left, Method right) => !left.Equals(right);

        public static explicit operator string(Method value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Method other && Equals(other);
        public bool Equals(Method other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The `edition` key affects which edition your package is compiled with. Cargo
    /// will always generate packages via [`cargo new`](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the `edition` key set to the
    /// latest edition. Setting the `edition` key in `[package]` will affect all
    /// targets/crates in the package, including test suites, benchmarks, binaries,
    /// examples, etc.
    /// </summary>
    [EnumType]
    public readonly struct PackageEdition : IEquatable<PackageEdition>
    {
        private readonly string _value;

        private PackageEdition(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PackageEdition PackageEdition_2015 { get; } = new PackageEdition("2015");
        public static PackageEdition PackageEdition_2018 { get; } = new PackageEdition("2018");
        public static PackageEdition PackageEdition_2021 { get; } = new PackageEdition("2021");
        public static PackageEdition PackageEdition_2024 { get; } = new PackageEdition("2024");

        public static bool operator ==(PackageEdition left, PackageEdition right) => left.Equals(right);
        public static bool operator !=(PackageEdition left, PackageEdition right) => !left.Equals(right);

        public static explicit operator string(PackageEdition value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PackageEdition other && Equals(other);
        public bool Equals(PackageEdition other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The `panic` setting controls the [`-C panic` flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic) which controls which panic
    /// strategy to use.
    /// 
    /// When set to `"unwind"`, the actual value depends on the default of the target
    /// platform. For example, the NVPTX platform does not support unwinding, so it
    /// always uses `"abort"`.
    /// 
    /// Tests, benchmarks, build scripts, and proc macros ignore the `panic` setting.
    /// The `rustc` test harness currently requires `unwind` behavior. See the
    /// [`panic-abort-tests`](https://doc.rust-lang.org/cargo/reference/unstable.html#panic-abort-tests) unstable flag which enables `abort` behavior.
    /// 
    /// Additionally, when using the `abort` strategy and building a test, all of the
    /// dependencies will also be forced to built with the `unwind` strategy.
    /// </summary>
    [EnumType]
    public readonly struct Panic : IEquatable<Panic>
    {
        private readonly string _value;

        private Panic(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Panic Unwind { get; } = new Panic("unwind");
        public static Panic Abort { get; } = new Panic("abort");

        public static bool operator ==(Panic left, Panic right) => left.Equals(right);
        public static bool operator !=(Panic left, Panic right) => !left.Equals(right);

        public static explicit operator string(Panic value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Panic other && Equals(other);
        public bool Equals(Panic other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The `panic` setting controls the [`-C panic` flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic) which controls which panic
    /// strategy to use.
    /// 
    /// When set to `"unwind"`, the actual value depends on the default of the target
    /// platform. For example, the NVPTX platform does not support unwinding, so it
    /// always uses `"abort"`.
    /// 
    /// Tests, benchmarks, build scripts, and proc macros ignore the `panic` setting.
    /// The `rustc` test harness currently requires `unwind` behavior. See the
    /// [`panic-abort-tests`](https://doc.rust-lang.org/cargo/reference/unstable.html#panic-abort-tests) unstable flag which enables `abort` behavior.
    /// 
    /// Additionally, when using the `abort` strategy and building a test, all of the
    /// dependencies will also be forced to built with the `unwind` strategy.
    /// </summary>
    [EnumType]
    public readonly struct ReleasePanic : IEquatable<ReleasePanic>
    {
        private readonly string _value;

        private ReleasePanic(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReleasePanic Unwind { get; } = new ReleasePanic("unwind");
        public static ReleasePanic Abort { get; } = new ReleasePanic("abort");

        public static bool operator ==(ReleasePanic left, ReleasePanic right) => left.Equals(right);
        public static bool operator !=(ReleasePanic left, ReleasePanic right) => !left.Equals(right);

        public static explicit operator string(ReleasePanic value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReleasePanic other && Equals(other);
        public bool Equals(ReleasePanic other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A different feature resolver algorithm can be used by specifying the resolver version in Cargo.toml like this:
    /// 
    /// [package]
    /// name = "my-package"
    /// version = "1.0.0"
    /// resolver = "2"
    /// 
    /// The version "1" resolver is the original resolver that shipped with Cargo up to version 1.50. The default is "2" if the root package specifies edition = "2021" or a newer edition. Otherwise the default is "1".
    /// 
    /// The version "2" resolver introduces changes in feature unification. See the features chapter for more details.
    /// 
    /// The resolver is a global option that affects the entire workspace. The resolver version in dependencies is ignored, only the value in the top-level package will be used. If using a virtual workspace, the version should be specified in the [workspace] table, for example:
    /// 
    /// [workspace]
    /// members = ["member1", "member2"]
    /// resolver = "2"
    /// </summary>
    [EnumType]
    public readonly struct Resolver : IEquatable<Resolver>
    {
        private readonly string _value;

        private Resolver(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Resolver One { get; } = new Resolver("1");
        public static Resolver Two { get; } = new Resolver("2");
        public static Resolver Three { get; } = new Resolver("3");

        public static bool operator ==(Resolver left, Resolver right) => left.Equals(right);
        public static bool operator !=(Resolver left, Resolver right) => !left.Equals(right);

        public static explicit operator string(Resolver value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Resolver other && Equals(other);
        public bool Equals(Resolver other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The `edition` key affects which edition your package is compiled with. Cargo
    /// will always generate packages via [`cargo new`](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the `edition` key set to the
    /// latest edition. Setting the `edition` key in `[package]` will affect all
    /// targets/crates in the package, including test suites, benchmarks, binaries,
    /// examples, etc.
    /// </summary>
    [EnumType]
    public readonly struct TestItemsEdition : IEquatable<TestItemsEdition>
    {
        private readonly string _value;

        private TestItemsEdition(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TestItemsEdition TestItemsEdition_2015 { get; } = new TestItemsEdition("2015");
        public static TestItemsEdition TestItemsEdition_2018 { get; } = new TestItemsEdition("2018");
        public static TestItemsEdition TestItemsEdition_2021 { get; } = new TestItemsEdition("2021");
        public static TestItemsEdition TestItemsEdition_2024 { get; } = new TestItemsEdition("2024");

        public static bool operator ==(TestItemsEdition left, TestItemsEdition right) => left.Equals(right);
        public static bool operator !=(TestItemsEdition left, TestItemsEdition right) => !left.Equals(right);

        public static explicit operator string(TestItemsEdition value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TestItemsEdition other && Equals(other);
        public bool Equals(TestItemsEdition other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The `panic` setting controls the [`-C panic` flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic) which controls which panic
    /// strategy to use.
    /// 
    /// When set to `"unwind"`, the actual value depends on the default of the target
    /// platform. For example, the NVPTX platform does not support unwinding, so it
    /// always uses `"abort"`.
    /// 
    /// Tests, benchmarks, build scripts, and proc macros ignore the `panic` setting.
    /// The `rustc` test harness currently requires `unwind` behavior. See the
    /// [`panic-abort-tests`](https://doc.rust-lang.org/cargo/reference/unstable.html#panic-abort-tests) unstable flag which enables `abort` behavior.
    /// 
    /// Additionally, when using the `abort` strategy and building a test, all of the
    /// dependencies will also be forced to built with the `unwind` strategy.
    /// </summary>
    [EnumType]
    public readonly struct TestPanic : IEquatable<TestPanic>
    {
        private readonly string _value;

        private TestPanic(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TestPanic Unwind { get; } = new TestPanic("unwind");
        public static TestPanic Abort { get; } = new TestPanic("abort");

        public static bool operator ==(TestPanic left, TestPanic right) => left.Equals(right);
        public static bool operator !=(TestPanic left, TestPanic right) => !left.Equals(right);

        public static explicit operator string(TestPanic value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TestPanic other && Equals(other);
        public bool Equals(TestPanic other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
