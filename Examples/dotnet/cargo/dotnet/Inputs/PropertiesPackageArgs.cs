// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Cargo.Inputs
{

    /// <summary>
    /// The `workspace.package` table is where you define keys that can be
    /// inherited by members of a workspace. These keys can be inherited by
    /// defining them in the member package with `{key}.workspace = true`.
    /// 
    /// Keys that are supported:
    /// 
    /// |                |                 |
    /// |----------------|-----------------|
    /// | `authors`      | `categories`    |
    /// | `description`  | `documentation` |
    /// | `edition`      | `exclude`       |
    /// | `homepage`     | `include`       |
    /// | `keywords`     | `license`       |
    /// | `license-file` | `publish`       |
    /// | `readme`       | `repository`    |
    /// | `rust-version` | `version`       |
    /// 
    /// - `license-file` and `readme` are relative to the workspace root
    /// - `include` and `exclude` are relative to your package root
    /// 
    /// Example:
    /// ```toml
    /// # [PROJECT_DIR]/Cargo.toml
    /// [workspace]
    /// members = ["bar"]
    /// 
    /// [workspace.package]
    /// version = "1.2.3"
    /// authors = ["Nice Folks"]
    /// description = "A short description of my package"
    /// documentation = "https://example.com/bar"
    /// ```
    /// 
    /// ```toml
    /// # [PROJECT_DIR]/bar/Cargo.toml
    /// [package]
    /// name = "bar"
    /// version.workspace = true
    /// authors.workspace = true
    /// description.workspace = true
    /// documentation.workspace = true
    /// ```
    /// </summary>
    public sealed class PropertiesPackageArgs : global::Pulumi.ResourceArgs
    {
        [Input("additionalProperties")]
        private InputMap<object>? _additionalProperties;
        public InputMap<object> AdditionalProperties
        {
            get => _additionalProperties ?? (_additionalProperties = new InputMap<object>());
            set => _additionalProperties = value;
        }

        [Input("authors")]
        private InputList<string>? _authors;

        /// <summary>
        /// The `authors` field lists people or organizations that are considered the
        /// "authors" of the package. The exact meaning is open to interpretation â€” it may
        /// list the original or primary authors, current maintainers, or owners of the
        /// package. These names will be listed on the crate's page on
        /// [crates.io](https://crates.io). An optional email address may be included within angled
        /// brackets at the end of each author.
        /// 
        /// &gt; **Note**: [crates.io](https://crates.io) requires at least one author to be listed.
        /// </summary>
        public InputList<string> Authors
        {
            get => _authors ?? (_authors = new InputList<string>());
            set => _authors = value;
        }

        [Input("categories")]
        private InputList<string>? _categories;

        /// <summary>
        /// The `categories` field is an array of strings of the categories this package
        /// belongs to.
        /// 
        /// ```toml
        /// categories = ["command-line-utilities", "development-tools::cargo-plugins"]
        /// ```
        /// 
        /// &gt; **Note**: [crates.io](https://crates.io) has a maximum of 5 categories. Each category should
        /// &gt; match one of the strings available at https://crates.io/category_slugs, and
        /// &gt; must match exactly.
        /// </summary>
        public InputList<string> Categories
        {
            get => _categories ?? (_categories = new InputList<string>());
            set => _categories = value;
        }

        /// <summary>
        /// The description is a short blurb about the package. [crates.io](https://crates.io) will display
        /// this with your package. This should be plain text (not Markdown).
        /// 
        /// ```toml
        /// [package]
        /// # ...
        /// description = "A short description of my package"
        /// ```
        /// 
        /// &gt; **Note**: [crates.io](https://crates.io) requires the `description` to be set.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// 
        /// The `documentation` field specifies a URL to a website hosting the crate's
        /// documentation. If no URL is specified in the manifest file, [crates.io](https://crates.io) will
        /// automatically link your crate to the corresponding [docs.rs](https://docs.rs) page.
        /// 
        /// ```toml
        /// [package]
        /// # ...
        /// documentation = "https://docs.rs/bitflags"
        /// ```
        /// </summary>
        [Input("documentation")]
        public Input<string>? Documentation { get; set; }

        /// <summary>
        /// The `edition` key affects which edition your package is compiled with. Cargo
        /// will always generate packages via [`cargo new`](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the `edition` key set to the
        /// latest edition. Setting the `edition` key in `[package]` will affect all
        /// targets/crates in the package, including test suites, benchmarks, binaries,
        /// examples, etc.
        /// </summary>
        [Input("edition")]
        public Input<Pulumi.Cargo.PackageEdition>? Edition { get; set; }

        [Input("exclude")]
        private InputList<string>? _exclude;

        /// <summary>
        /// You can explicitly specify that a set of file patterns should be ignored or
        /// included for the purposes of packaging. The patterns specified in the
        /// `exclude` field identify a set of files that are not included, and the
        /// patterns in `include` specify files that are explicitly included.
        /// 
        /// The patterns should be [gitignore](https://git-scm.com/docs/gitignore)-style patterns. Briefly:
        /// 
        /// - `foo` matches any file or directory with the name `foo` anywhere in the
        ///   package. This is equivalent to the pattern `**/foo`.
        /// - `/foo` matches any file or directory with the name `foo` only in the root of
        ///   the package.
        /// - `foo/` matches any *directory* with the name `foo` anywhere in the package.
        /// - Common glob patterns like `*`, `?`, and `[]` are supported:
        ///   - `*` matches zero or more characters except `/`.  For example, `*.html`
        ///     matches any file or directory with the `.html` extension anywhere in the
        ///     package.
        ///   - `?` matches any character except `/`. For example, `foo?` matches `food`,
        ///     but not `foo`.
        ///   - `[]` allows for matching a range of characters. For example, `[ab]`
        ///     matches either `a` or `b`. `[a-z]` matches letters a through z.
        /// - `**/` prefix matches in any directory. For example, `**/foo/bar` matches the
        ///   file or directory `bar` anywhere that is directly under directory `foo`.
        /// - `/**` suffix matches everything inside. For example, `foo/**` matches all
        ///   files inside directory `foo`, including all files in subdirectories below
        ///   `foo`.
        /// - `/**/` matches zero or more directories. For example, `a/**/b` matches
        ///   `a/b`, `a/x/b`, `a/x/y/b`, and so on.
        /// - `!` prefix negates a pattern. For example, a pattern of `src/**.rs` and
        ///   `!foo.rs` would match all files with the `.rs` extension inside the `src`
        ///   directory, except for any file named `foo.rs`.
        /// 
        /// If git is being used for a package, the `exclude` field will be seeded with
        /// the `gitignore` settings from the repository.
        /// 
        /// ```toml
        /// [package]
        /// # ...
        /// exclude = ["build/**/*.o", "doc/**/*.html"]
        /// ```
        /// 
        /// ```toml
        /// [package]
        /// # ...
        /// include = ["src/**/*", "Cargo.toml"]
        /// ```
        /// 
        /// The options are mutually exclusive: setting `include` will override an
        /// `exclude`. Note that `include` must be an exhaustive list of files as otherwise
        /// necessary source files may not be included. The package's `Cargo.toml` is
        /// automatically included.
        /// 
        /// The include/exclude list is also used for change tracking in some situations.
        /// For targets built with `rustdoc`, it is used to determine the list of files to
        /// track to determine if the target should be rebuilt. If the package has a
        /// [build script](https://doc.rust-lang.org/cargo/reference/build-scripts.html) that does not emit any `rerun-if-*` directives, then the
        /// include/exclude list is used for tracking if the build script should be re-run
        /// if any of those files change.
        /// </summary>
        public InputList<string> Exclude
        {
            get => _exclude ?? (_exclude = new InputList<string>());
            set => _exclude = value;
        }

        /// <summary>
        /// The `homepage` field should be a URL to a site that is the home page for your
        /// package.
        /// 
        /// ```toml
        /// [package]
        /// # ...
        /// homepage = "https://serde.rs/"
        /// ```
        /// </summary>
        [Input("homepage")]
        public Input<string>? Homepage { get; set; }

        [Input("include")]
        private InputList<string>? _include;

        /// <summary>
        /// You can explicitly specify that a set of file patterns should be ignored or
        /// included for the purposes of packaging. The patterns specified in the
        /// `exclude` field identify a set of files that are not included, and the
        /// patterns in `include` specify files that are explicitly included.
        /// 
        /// The patterns should be [gitignore](https://git-scm.com/docs/gitignore)-style patterns. Briefly:
        /// 
        /// - `foo` matches any file or directory with the name `foo` anywhere in the
        ///   package. This is equivalent to the pattern `**/foo`.
        /// - `/foo` matches any file or directory with the name `foo` only in the root of
        ///   the package.
        /// - `foo/` matches any *directory* with the name `foo` anywhere in the package.
        /// - Common glob patterns like `*`, `?`, and `[]` are supported:
        ///   - `*` matches zero or more characters except `/`.  For example, `*.html`
        ///     matches any file or directory with the `.html` extension anywhere in the
        ///     package.
        ///   - `?` matches any character except `/`. For example, `foo?` matches `food`,
        ///     but not `foo`.
        ///   - `[]` allows for matching a range of characters. For example, `[ab]`
        ///     matches either `a` or `b`. `[a-z]` matches letters a through z.
        /// - `**/` prefix matches in any directory. For example, `**/foo/bar` matches the
        ///   file or directory `bar` anywhere that is directly under directory `foo`.
        /// - `/**` suffix matches everything inside. For example, `foo/**` matches all
        ///   files inside directory `foo`, including all files in subdirectories below
        ///   `foo`.
        /// - `/**/` matches zero or more directories. For example, `a/**/b` matches
        ///   `a/b`, `a/x/b`, `a/x/y/b`, and so on.
        /// - `!` prefix negates a pattern. For example, a pattern of `src/**.rs` and
        ///   `!foo.rs` would match all files with the `.rs` extension inside the `src`
        ///   directory, except for any file named `foo.rs`.
        /// 
        /// If git is being used for a package, the `exclude` field will be seeded with
        /// the `gitignore` settings from the repository.
        /// 
        /// ```toml
        /// [package]
        /// # ...
        /// exclude = ["build/**/*.o", "doc/**/*.html"]
        /// ```
        /// 
        /// ```toml
        /// [package]
        /// # ...
        /// include = ["src/**/*", "Cargo.toml"]
        /// ```
        /// 
        /// The options are mutually exclusive: setting `include` will override an
        /// `exclude`. Note that `include` must be an exhaustive list of files as otherwise
        /// necessary source files may not be included. The package's `Cargo.toml` is
        /// automatically included.
        /// 
        /// The include/exclude list is also used for change tracking in some situations.
        /// For targets built with `rustdoc`, it is used to determine the list of files to
        /// track to determine if the target should be rebuilt. If the package has a
        /// [build script](https://doc.rust-lang.org/cargo/reference/build-scripts.html) that does not emit any `rerun-if-*` directives, then the
        /// include/exclude list is used for tracking if the build script should be re-run
        /// if any of those files change.
        /// </summary>
        public InputList<string> Include
        {
            get => _include ?? (_include = new InputList<string>());
            set => _include = value;
        }

        [Input("keywords")]
        private InputList<string>? _keywords;

        /// <summary>
        /// The `keywords` field is an array of strings that describe this package. This
        /// can help when searching for the package on a registry, and you may choose any
        /// words that would help someone find this crate.
        /// 
        /// ```toml
        /// [package]
        /// # ...
        /// keywords = ["gamedev", "graphics"]
        /// ```
        /// 
        /// &gt; **Note**: [crates.io](https://crates.io) has a maximum of 5 keywords. Each keyword must be
        /// &gt; ASCII text, start with a letter, and only contain letters, numbers, `_` or
        /// &gt; `-`, and have at most 20 characters.
        /// </summary>
        public InputList<string> Keywords
        {
            get => _keywords ?? (_keywords = new InputList<string>());
            set => _keywords = value;
        }

        /// <summary>
        /// The `license` field contains the name of the software license that the package
        /// is released under.
        /// 
        /// [crates.io](https://crates.io/) interprets the `license` field as an [SPDX 2.1 license
        /// expression](https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60). The name must be a known license
        /// from the [SPDX license list 3.6](https://github.com/spdx/license-list-data/tree/v3.6). Parentheses are not
        /// currently supported. See the [SPDX site](https://spdx.org/license-list) for more information.
        /// 
        /// SPDX license expressions support AND and OR operators to combine multiple
        /// licenses.
        /// 
        /// ```toml
        /// [package]
        /// # ...
        /// license = "MIT OR Apache-2.0"
        /// ```
        /// 
        /// Using `OR` indicates the user may choose either license. Using `AND` indicates
        /// the user must comply with both licenses simultaneously. The `WITH` operator
        /// indicates a license with a special exception. Some examples:
        /// 
        /// * `MIT OR Apache-2.0`
        /// * `LGPL-2.1 AND MIT AND BSD-2-Clause`
        /// * `GPL-2.0+ WITH Bison-exception-2.2`
        /// 
        /// If a package is using a nonstandard license, then the `license-file` field may
        /// be specified in lieu of the `license` field.
        /// </summary>
        [Input("license")]
        public Input<string>? License { get; set; }

        /// <summary>
        /// The `license-file` field contains the path to a file
        /// containing the text of the license (relative to this `Cargo.toml`).
        /// 
        /// ```toml
        /// [package]
        /// # ...
        /// license-file = "LICENSE.txt"
        /// ```
        /// 
        /// &gt; **Note**: [crates.io](https://crates.io) requires either `license` or `license-file` to be set.
        /// </summary>
        [Input("licenseFile")]
        public Input<string>? LicenseFile { get; set; }

        /// <summary>
        /// unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.AnyOfKeyword, Json.Schema.UnrecognizedKeyword
        /// </summary>
        [Input("publish")]
        public Input<object>? Publish { get; set; }

        /// <summary>
        /// unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.AnyOfKeyword, Json.Schema.UnrecognizedKeyword
        /// </summary>
        [Input("readme")]
        public Input<object>? Readme { get; set; }

        /// <summary>
        /// The `repository` field should be a URL to the source repository for your
        /// package.
        /// 
        /// ```toml
        /// [package]
        /// # ...
        /// repository = "https://github.com/rust-lang/cargo/"
        /// ```
        /// </summary>
        [Input("repository")]
        public Input<string>? Repository { get; set; }

        /// <summary>
        /// The `rust-version` field is an optional key that tells cargo what version of the
        /// Rust language and compiler your package can be compiled with. If the currently
        /// selected version of the Rust compiler is older than the stated version, cargo
        /// will exit with an error, telling the user what version is required.
        /// 
        /// The first version of Cargo that supports this field was released with Rust 1.56.0.
        /// In older releases, the field will be ignored, and Cargo will display a warning.
        /// 
        /// ```toml
        /// [package]
        /// # ...
        /// rust-version = "1.56"
        /// ```
        /// 
        /// The Rust version must be a bare version number with two or three components; it
        /// cannot include semver operators or pre-release identifiers. Compiler pre-release
        /// identifiers such as -nightly will be ignored while checking the Rust version.
        /// The `rust-version` must be equal to or newer than the version that first
        /// introduced the configured `edition`.
        /// 
        /// The `rust-version` may be ignored using the `--ignore-rust-version` option.
        /// 
        /// Setting the `rust-version` key in `[package]` will affect all targets/crates in
        /// the package, including test suites, benchmarks, binaries, examples, etc.
        /// </summary>
        [Input("rustVersion")]
        public Input<string>? RustVersion { get; set; }

        /// <summary>
        /// Cargo bakes in the concept of [Semantic Versioning](https://semver.org/), so make sure you follow some basic rules:
        /// 
        /// * Before you reach 1.0.0, anything goes, but if you make breaking changes,
        ///     increment the minor version. In Rust, breaking changes include adding fields to
        ///     structs or variants to enums.
        /// * After 1.0.0, only make breaking changes when you increment the major version.
        ///     Don't break the build.
        /// * After 1.0.0, don't add any new public API (no new `pub` anything) in patch-level
        ///     versions. Always increment the minor version if you add any new `pub` structs,
        ///     traits, fields, types, functions, methods or anything else.
        /// * Use version numbers with three numeric parts such as 1.0.0 rather than 1.0.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        public PropertiesPackageArgs()
        {
        }
        public static new PropertiesPackageArgs Empty => new PropertiesPackageArgs();
    }
}
