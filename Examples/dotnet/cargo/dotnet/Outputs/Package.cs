// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Cargo.Outputs
{

    /// <summary>
    /// The only field required by Cargo is [`name`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-name-field).
    ///  If publishing to a registry, the registry may
    /// require additional fields. See the notes below and [the publishing chapter](https://doc.rust-lang.org/cargo/reference/publishing.html) for requirements for publishing to [crates.io](https://crates.io/).
    /// </summary>
    [OutputType]
    public sealed class Package
    {
        public readonly ImmutableDictionary<string, object>? AdditionalProperties;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? Authors;
        /// <summary>
        /// Disable automatic discovery of `bench` targets.
        /// 
        /// Disabling automatic discovery should only be needed for specialized
        /// situations. For example, if you have a library where you want a *module* named
        /// `bin`, this would present a problem because Cargo would usually attempt to
        /// compile anything in the `bin` directory as an executable. Here is a sample
        /// layout of this scenario:
        /// 
        /// ```
        /// ├── Cargo.toml
        /// └── src
        ///     ├── lib.rs
        ///     └── bin
        ///         └── mod.rs
        /// ```
        /// </summary>
        public readonly bool? Autobenches;
        /// <summary>
        /// Disable automatic discovery of `bin` targets.
        /// 
        /// Disabling automatic discovery should only be needed for specialized
        /// situations. For example, if you have a library where you want a *module* named
        /// `bin`, this would present a problem because Cargo would usually attempt to
        /// compile anything in the `bin` directory as an executable. Here is a sample
        /// layout of this scenario:
        /// 
        /// ```
        /// ├── Cargo.toml
        /// └── src
        ///     ├── lib.rs
        ///     └── bin
        ///         └── mod.rs
        /// ```
        /// 
        /// To prevent Cargo from inferring `src/bin/mod.rs` as an executable, set
        /// this to `false` to disable auto-discovery.
        /// </summary>
        public readonly bool? Autobins;
        /// <summary>
        /// Disable automatic discovery of `example` targets.
        /// 
        /// Disabling automatic discovery should only be needed for specialized
        /// situations. For example, if you have a library where you want a *module* named
        /// `bin`, this would present a problem because Cargo would usually attempt to
        /// compile anything in the `bin` directory as an executable. Here is a sample
        /// layout of this scenario:
        /// 
        /// ```
        /// ├── Cargo.toml
        /// └── src
        ///     ├── lib.rs
        ///     └── bin
        ///         └── mod.rs
        /// ```
        /// </summary>
        public readonly bool? Autoexamples;
        /// <summary>
        /// Disable automatic discovery of `test` targets.
        /// 
        /// Disabling automatic discovery should only be needed for specialized
        /// situations. For example, if you have a library where you want a *module* named
        /// `bin`, this would present a problem because Cargo would usually attempt to
        /// compile anything in the `bin` directory as an executable. Here is a sample
        /// layout of this scenario:
        /// 
        /// ```
        /// ├── Cargo.toml
        /// └── src
        ///     ├── lib.rs
        ///     └── bin
        ///         └── mod.rs
        /// ```
        /// </summary>
        public readonly bool? Autotests;
        /// <summary>
        /// unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.AnyOfKeyword, Json.Schema.UnrecognizedKeyword
        /// </summary>
        public readonly object? Build;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? Categories;
        /// <summary>
        /// The `default-run` field in the `[package]` section of the manifest can be used
        /// to specify a default binary picked by [`cargo run`](https://doc.rust-lang.org/cargo/commands/cargo-run.html). For example, when there is
        /// both `src/bin/a.rs` and `src/bin/b.rs`:
        /// 
        /// ```toml
        /// [package]
        /// default-run = "a"
        /// ```
        /// </summary>
        public readonly string? DefaultRun;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? Description;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? Documentation;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? Edition;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? Exclude;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? Homepage;
        /// <summary>
        /// Sets whether the current package is a teapot or something else that is not capable of brewing tea.
        /// </summary>
        public readonly bool? ImATeapot;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? Include;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? Keywords;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? License;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? LicenseFile;
        /// <summary>
        /// The `links` field specifies the name of a native library that is being linked
        /// to. More information can be found in the [`links`](https://doc.rust-lang.org/cargo/reference/build-scripts.html#the-links-manifest-key) section of the build
        /// script guide.
        /// 
        /// ```toml
        /// [package]
        /// # ...
        /// links = "foo"
        /// ```
        /// </summary>
        public readonly string? Links;
        public readonly ImmutableArray<string> Metabuild;
        public readonly Outputs.Metadata? Metadata;
        /// <summary>
        /// The package name is an identifier used to refer to the package. It is used
        /// when listed as a dependency in another package, and as the default name of
        /// inferred lib and bin targets.
        /// 
        /// The name must use only [alphanumeric](https://doc.rust-lang.org/std/primitive.char.html#method.is_alphanumeric) characters or `-` or `_`, and cannot be empty.
        /// Note that [`cargo new`](https://doc.rust-lang.org/cargo/commands/cargo-new.html) and [`cargo init`](https://doc.rust-lang.org/cargo/commands/cargo-init.html) impose some additional restrictions on
        /// the package name, such as enforcing that it is a valid Rust identifier and not
        /// a keyword. [crates.io](https://crates.io) imposes even more restrictions, such as
        /// enforcing only ASCII characters, not a reserved name, not a special Windows
        /// name such as "nul", is not too long, etc.
        /// </summary>
        public readonly string Name;
        public readonly bool? NamespacedFeatures;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? Publish;
        public readonly bool? PublishLockfile;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? Readme;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? Repository;
        public readonly Pulumi.Cargo.Resolver? Resolver;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? RustVersion;
        /// <summary>
        /// unhandled schema: Json.Schema.AnyOfKeyword
        /// </summary>
        public readonly object? Version;
        /// <summary>
        /// The `workspace` field can be used to configure the workspace that this package
        /// will be a member of. If not specified this will be inferred as the first
        /// Cargo.toml with `[workspace]` upwards in the filesystem. Setting this is
        /// useful if the member is not inside a subdirectory of the workspace root.
        /// 
        /// ```toml
        /// [package]
        /// # ...
        /// workspace = "path/to/workspace/root"
        /// ```
        /// 
        /// This field cannot be specified if the manifest already has a `[workspace]`
        /// table defined. That is, a crate cannot both be a root crate in a workspace
        /// (contain `[workspace]`) and also be a member crate of another workspace
        /// (contain `package.workspace`).
        /// 
        /// For more information, see the [workspaces chapter](https://doc.rust-lang.org/cargo/reference/workspaces.html).
        /// </summary>
        public readonly string? Workspace;

        [OutputConstructor]
        private Package(
            ImmutableDictionary<string, object>? additionalProperties,

            object? authors,

            bool? autobenches,

            bool? autobins,

            bool? autoexamples,

            bool? autotests,

            object? build,

            object? categories,

            string? defaultRun,

            object? description,

            object? documentation,

            object? edition,

            object? exclude,

            object? homepage,

            bool? imATeapot,

            object? include,

            object? keywords,

            object? license,

            object? licenseFile,

            string? links,

            ImmutableArray<string> metabuild,

            Outputs.Metadata? metadata,

            string name,

            bool? namespacedFeatures,

            object? publish,

            bool? publishLockfile,

            object? readme,

            object? repository,

            Pulumi.Cargo.Resolver? resolver,

            object? rustVersion,

            object? version,

            string? workspace)
        {
            AdditionalProperties = additionalProperties;
            Authors = authors;
            Autobenches = autobenches;
            Autobins = autobins;
            Autoexamples = autoexamples;
            Autotests = autotests;
            Build = build;
            Categories = categories;
            DefaultRun = defaultRun;
            Description = description;
            Documentation = documentation;
            Edition = edition;
            Exclude = exclude;
            Homepage = homepage;
            ImATeapot = imATeapot;
            Include = include;
            Keywords = keywords;
            License = license;
            LicenseFile = licenseFile;
            Links = links;
            Metabuild = metabuild;
            Metadata = metadata;
            Name = name;
            NamespacedFeatures = namespacedFeatures;
            Publish = publish;
            PublishLockfile = publishLockfile;
            Readme = readme;
            Repository = repository;
            Resolver = resolver;
            RustVersion = rustVersion;
            Version = version;
            Workspace = workspace;
        }
    }
}
