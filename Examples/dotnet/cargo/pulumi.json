{
  "name": "cargo",
  "version": "1.0.0",
  "description": "A pulumi package generated from a json schema",
  "keywords": [
    "pulumi",
    "jsonschema"
  ],
  "homepage": "https://github.com/Frassle/pulumi-jsonschema",
  "repository": "https://github.com/Frassle/pulumi-jsonschema",
  "license": "Apache-2.0",
  "pluginDownloadURL": "github://api.github.com/Frassle",
  "parameterization": {
    "baseProvider": {
      "version": "0.1.1",
      "name": "jsonschema"
    },
    "parameter": "XGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9TY2hlbWFTdG9yZS9zY2hlbWFzdG9yZS9tYXN0ZXIvc3JjL3NjaGVtYXMvanNvbi9jYXJnby5qc29uqJEIewogICIkc2NoZW1hIjogImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hIyIsCiAgIiRpZCI6ICJodHRwczovL2pzb24uc2NoZW1hc3RvcmUub3JnL2NhcmdvLmpzb24iLAogICJkZWZpbml0aW9ucyI6IHsKICAgICJCdWlsZCI6IHsKICAgICAgInRpdGxlIjogIkJ1aWxkIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgYnVpbGRgIGZpZWxkIHNwZWNpZmllcyBhIGZpbGUgaW4gdGhlIHBhY2thZ2Ugcm9vdCB3aGljaCBpcyBhIFtidWlsZCBzY3JpcHRdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2J1aWxkLXNjcmlwdHMuaHRtbCkgZm9yIGJ1aWxkaW5nIG5hdGl2ZSBjb2RlLiBNb3JlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiB0aGUgW2J1aWxkIHNjcmlwdCBndWlkZV0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvYnVpbGQtc2NyaXB0cy5odG1sKS5cblxuXG5gYGB0b21sXG5bcGFja2FnZV1cbiMgLi4uXG5idWlsZCA9IFwiYnVpbGQucnNcIlxuYGBgXG5cblRoZSBkZWZhdWx0IGlzIGBcImJ1aWxkLnJzXCJgLCB3aGljaCBsb2FkcyB0aGUgc2NyaXB0IGZyb20gYSBmaWxlIG5hbWVkXG5gYnVpbGQucnNgIGluIHRoZSByb290IG9mIHRoZSBwYWNrYWdlLiBVc2UgYGJ1aWxkID0gXCJjdXN0b21fYnVpbGRfbmFtZS5yc1wiYCB0b1xuc3BlY2lmeSBhIHBhdGggdG8gYSBkaWZmZXJlbnQgZmlsZSBvciBgYnVpbGQgPSBmYWxzZWAgdG8gZGlzYWJsZSBhdXRvbWF0aWNcbmRldGVjdGlvbiBvZiB0aGUgYnVpbGQgc2NyaXB0LlxuIiwKICAgICAgImFueU9mIjogWwogICAgICAgIHsKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJQYXRoIHRvIHRoZSBidWlsZCBmaWxlLiIsCiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAidHlwZSI6ICJib29sZWFuIiwKICAgICAgICAgICJlbnVtIjogW3RydWUsIGZhbHNlXSwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAiZG9jcyI6IHsKICAgICAgICAgICAgICAiZW51bVZhbHVlcyI6IFsKICAgICAgICAgICAgICAgICJBdXRvbWF0aWNhbGx5IGRldGVjdCB0aGUgYnVpbGQgZmlsZSAoYGJ1aWxkLnJzYCkuIiwKICAgICAgICAgICAgICAgICJEaXNhYmxlIGF1dG9tYXRpYyBkZXRlY3Rpb24gb2YgdGhlIGJ1aWxkIGZpbGUuIgogICAgICAgICAgICAgIF0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgXSwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9tYW5pZmVzdC5odG1sI3RoZS1idWlsZC1maWVsZCIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAiRGVidWdMZXZlbCI6IHsKICAgICAgInRpdGxlIjogIkRlYnVnIExldmVsIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgZGVidWdgIHNldHRpbmcgY29udHJvbHMgdGhlIFtgLUMgZGVidWdpbmZvYCBmbGFnXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL3J1c3RjL2NvZGVnZW4tb3B0aW9ucy9pbmRleC5odG1sI2RlYnVnaW5mbykgd2hpY2ggY29udHJvbHMgdGhlXG5hbW91bnQgb2YgZGVidWcgaW5mb3JtYXRpb24gaW5jbHVkZWQgaW4gdGhlIGNvbXBpbGVkIGJpbmFyeS4iLAogICAgICAiZW51bSI6IFsKICAgICAgICAwLAogICAgICAgIDEsCiAgICAgICAgMiwKICAgICAgICB0cnVlLAogICAgICAgIGZhbHNlLAogICAgICAgICJub25lIiwKICAgICAgICAibGluZS1kaXJlY3RpdmVzLW9ubHkiLAogICAgICAgICJsaW5lLXRhYmxlcy1vbmx5IiwKICAgICAgICAibGltaXRlZCIsCiAgICAgICAgImZ1bGwiCiAgICAgIF0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJkb2NzIjogewogICAgICAgICAgImVudW1WYWx1ZXMiOiBbCiAgICAgICAgICAgICJObyBkZWJ1ZyBpbmZvIGF0IGFsbCwgZGVmYXVsdCBmb3IgYHJlbGVhc2VgIHByb2ZpbGUiLAogICAgICAgICAgICAiRGVidWcgaW5mbyB3aXRob3V0IHR5cGUgb3IgdmFyaWFibGUtbGV2ZWwgaW5mb3JtYXRpb24uIEdlbmVyYXRlcyBtb3JlIGRldGFpbGVkIG1vZHVsZS1sZXZlbCBpbmZvIHRoYW4gYGxpbmUtdGFibGVzLW9ubHlgLiIsCiAgICAgICAgICAgICJGdWxsIGRlYnVnIGluZm8sIGRlZmF1bHQgZm9yIGBkZXZgIHByb2ZpbGUiLAogICAgICAgICAgICAiRnVsbCBkZWJ1ZyBpbmZvLCBkZWZhdWx0IGZvciBgZGV2YCBwcm9maWxlIiwKICAgICAgICAgICAgIk5vIGRlYnVnIGluZm8gYXQgYWxsLCBkZWZhdWx0IGZvciBgcmVsZWFzZWAgcHJvZmlsZSIsCiAgICAgICAgICAgICJObyBkZWJ1ZyBpbmZvIGF0IGFsbCwgZGVmYXVsdCBmb3IgYHJlbGVhc2VgIHByb2ZpbGUiLAogICAgICAgICAgICAiTGluZSBpbmZvIGRpcmVjdGl2ZXMgb25seS4gRm9yIHRoZSBudnB0eCogdGFyZ2V0cyB0aGlzIGVuYWJsZXMgW3Byb2ZpbGluZ10oaHR0cHM6Ly9yZXZpZXdzLmxsdm0ub3JnL0Q0NjA2MSkuIEZvciBvdGhlciB1c2UgY2FzZXMsIGBsaW5lLXRhYmxlcy1vbmx5YCBpcyB0aGUgYmV0dGVyLCBtb3JlIGNvbXBhdGlibGUgY2hvaWNlLiIsCiAgICAgICAgICAgICJMaW5lIHRhYmxlcyBvbmx5LiBHZW5lcmF0ZXMgdGhlIG1pbmltYWwgYW1vdW50IG9mIGRlYnVnIGluZm8gZm9yIGJhY2t0cmFjZXMgd2l0aCBmaWxlbmFtZS9saW5lIG51bWJlciBpbmZvLCBidXQgbm90IGFueXRoaW5nIGVsc2UsIGkuZS4gbm8gdmFyaWFibGUgb3IgZnVuY3Rpb24gcGFyYW1ldGVyIGluZm8uIiwKICAgICAgICAgICAgIkRlYnVnIGluZm8gd2l0aG91dCB0eXBlIG9yIHZhcmlhYmxlLWxldmVsIGluZm9ybWF0aW9uLiBHZW5lcmF0ZXMgbW9yZSBkZXRhaWxlZCBtb2R1bGUtbGV2ZWwgaW5mbyB0aGFuIGBsaW5lLXRhYmxlcy1vbmx5YC4iLAogICAgICAgICAgICAiRnVsbCBkZWJ1ZyBpbmZvLCBkZWZhdWx0IGZvciBgZGV2YCBwcm9maWxlIgogICAgICAgICAgXQogICAgICAgIH0sCiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9wcm9maWxlcy5odG1sI2RlYnVnIgogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJEZXBlbmRlbmN5IjogewogICAgICAidGl0bGUiOiAiRGVwZW5kZW5jeSIsCiAgICAgICJhbnlPZiI6IFsKICAgICAgICB7CiAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1NlbVZlclJlcXVpcmVtZW50IgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9EZXRhaWxlZERlcGVuZGVuY3kiCiAgICAgICAgfQogICAgICBdCiAgICB9LAogICAgIkRldGFpbGVkRGVwZW5kZW5jeSI6IHsKICAgICAgInRpdGxlIjogIkRldGFpbGVkIERlcGVuZGVuY3kiLAogICAgICAidHlwZSI6ICJvYmplY3QiLAogICAgICAicHJvcGVydGllcyI6IHsKICAgICAgICAiYnJhbmNoIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlNwZWNpZnkgdGhlIEdpdCBicmFuY2ggdG8gdXNlIGluIGNhc2Ugb2YgYSBbR2l0IGRlcGVuZGVuY3ldKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwjc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMtZnJvbS1naXQtcmVwb3NpdG9yaWVzKS4iLAogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9zcGVjaWZ5aW5nLWRlcGVuZGVuY2llcy5odG1sI3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLWZyb20tZ2l0LXJlcG9zaXRvcmllcyIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgImRlZmF1bHQtZmVhdHVyZXMiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiVXNlIHRoZSBkZWZhdWx0IGZlYXR1cmVzIG9mIHRoZSBkZXBlbmRlbmN5LiIsCiAgICAgICAgICAidHlwZSI6ICJib29sZWFuIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9zcGVjaWZ5aW5nLWRlcGVuZGVuY2llcy5odG1sI2Nob29zaW5nLWZlYXR1cmVzIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiZGVmYXVsdF9mZWF0dXJlcyI6IHsKICAgICAgICAgICJ0eXBlIjogImJvb2xlYW4iLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJoaWRkZW4iOiB0cnVlCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiZmVhdHVyZXMiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiTGlzdCBvZiBmZWF0dXJlcyB0byBhY3RpdmF0ZSBpbiB0aGUgZGVwZW5kZW5jeS4iLAogICAgICAgICAgInR5cGUiOiAiYXJyYXkiLAogICAgICAgICAgIml0ZW1zIjogewogICAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiTGlzdCBvZiBmZWF0dXJlcyB0byBhY3RpdmF0ZSBpbiB0aGUgZGVwZW5kZW5jeS4iLAogICAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwjY2hvb3NpbmctZmVhdHVyZXMiCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAicGx1Z2lucyI6IFsiY3JhdGVzIl0sCiAgICAgICAgICAgICAgImNyYXRlcyI6IHsKICAgICAgICAgICAgICAgICJzY2hlbWFzIjogImZlYXR1cmUiCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9LAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwjY2hvb3NpbmctZmVhdHVyZXMiCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICJnaXQiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiVG8gZGVwZW5kIG9uIGEgbGlicmFyeSBsb2NhdGVkIGluIGEgYGdpdGAgcmVwb3NpdG9yeSwgdGhlIG1pbmltdW0gaW5mb3JtYXRpb25cbnlvdSBuZWVkIHRvIHNwZWNpZnkgaXMgdGhlIGxvY2F0aW9uIG9mIHRoZSByZXBvc2l0b3J5IHdpdGggdGhlIGBnaXRgIGtleTpcblxuYGBgdG9tbFxuW2RlcGVuZGVuY2llc11cbnJhbmQgPSB7IGdpdCA9IFwiaHR0cHM6Ly9naXRodWIuY29tL3J1c3QtbGFuZy1udXJzZXJ5L3JhbmRcIiB9XG5gYGBcblxuQ2FyZ28gd2lsbCBmZXRjaCB0aGUgYGdpdGAgcmVwb3NpdG9yeSBhdCB0aGlzIGxvY2F0aW9uIHRoZW4gbG9vayBmb3IgYVxuYENhcmdvLnRvbWxgIGZvciB0aGUgcmVxdWVzdGVkIGNyYXRlIGFueXdoZXJlIGluc2lkZSB0aGUgYGdpdGAgcmVwb3NpdG9yeVxuKG5vdCBuZWNlc3NhcmlseSBhdCB0aGUgcm9vdCAtIGZvciBleGFtcGxlLCBzcGVjaWZ5aW5nIGEgbWVtYmVyIGNyYXRlIG5hbWVcbm9mIGEgd29ya3NwYWNlIGFuZCBzZXR0aW5nIGBnaXRgIHRvIHRoZSByZXBvc2l0b3J5IGNvbnRhaW5pbmcgdGhlIHdvcmtzcGFjZSkuXG5cblNpbmNlIHdlIGhhdmVuJ3Qgc3BlY2lmaWVkIGFueSBvdGhlciBpbmZvcm1hdGlvbiwgQ2FyZ28gYXNzdW1lcyB0aGF0XG53ZSBpbnRlbmQgdG8gdXNlIHRoZSBsYXRlc3QgY29tbWl0IG9uIHRoZSBtYWluIGJyYW5jaCB0byBidWlsZCBvdXIgcGFja2FnZS5cbllvdSBjYW4gY29tYmluZSB0aGUgYGdpdGAga2V5IHdpdGggdGhlIGByZXZgLCBgdGFnYCwgb3IgYGJyYW5jaGAga2V5cyB0b1xuc3BlY2lmeSBzb21ldGhpbmcgZWxzZS4gSGVyZSdzIGFuIGV4YW1wbGUgb2Ygc3BlY2lmeWluZyB0aGF0IHlvdSB3YW50IHRvIHVzZVxudGhlIGxhdGVzdCBjb21taXQgb24gYSBicmFuY2ggbmFtZWQgYG5leHRgOlxuXG5gYGB0b21sXG5bZGVwZW5kZW5jaWVzXVxucmFuZCA9IHsgZ2l0ID0gXCJodHRwczovL2dpdGh1Yi5jb20vcnVzdC1sYW5nLW51cnNlcnkvcmFuZFwiLCBicmFuY2ggPSBcIm5leHRcIiB9XG5gYGBcblxuU2VlIFtHaXQgQXV0aGVudGljYXRpb25dKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vYXBwZW5kaXgvZ2l0LWF1dGhlbnRpY2F0aW9uLmh0bWwpIGZvciBoZWxwIHdpdGggZ2l0IGF1dGhlbnRpY2F0aW9uIGZvciBwcml2YXRlIHJlcG9zLlxuXG4\u002BICoqTm90ZSoqOiBbY3JhdGVzLmlvXShodHRwczovL2NyYXRlcy5pby8pIGRvZXMgbm90IGFsbG93IHBhY2thZ2VzIHRvIGJlIHB1Ymxpc2hlZCB3aXRoIGBnaXRgXG4\u002BIGRlcGVuZGVuY2llcyAoYGdpdGAgW2Rldi1kZXBlbmRlbmNpZXNdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwjZGV2ZWxvcG1lbnQtZGVwZW5kZW5jaWVzKSBhcmUgaWdub3JlZCkuIFNlZSB0aGUgW011bHRpcGxlXG4\u002BIGxvY2F0aW9uc10oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMuaHRtbCNtdWx0aXBsZS1sb2NhdGlvbnMpIHNlY3Rpb24gZm9yIGEgZmFsbGJhY2sgYWx0ZXJuYXRpdmUuXG4iLAogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9zcGVjaWZ5aW5nLWRlcGVuZGVuY2llcy5odG1sI3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLWZyb20tZ2l0LXJlcG9zaXRvcmllcyIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgIm9wdGlvbmFsIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIk1hcmsgdGhlIGRlcGVuZGVuY3kgYXMgb3B0aW9uYWwuXG5cbk9wdGlvbmFsIGRlcGVuZGVuY2llcyBjYW4gYmUgYWN0aXZhdGVkIHRocm91Z2ggZmVhdHVyZXMuIiwKICAgICAgICAgICJ0eXBlIjogImJvb2xlYW4iLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwjY2hvb3NpbmctZmVhdHVyZXMiCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICJwYWNrYWdlIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlNwZWNpZnkgdGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UuXG5cbldoZW4gd3JpdGluZyBhIGBbZGVwZW5kZW5jaWVzXWAgc2VjdGlvbiBpbiBgQ2FyZ28udG9tbGAgdGhlIGtleSB5b3Ugd3JpdGUgZm9yIGFcbmRlcGVuZGVuY3kgdHlwaWNhbGx5IG1hdGNoZXMgdXAgdG8gdGhlIG5hbWUgb2YgdGhlIGNyYXRlIHlvdSBpbXBvcnQgZnJvbSBpbiB0aGVcbmNvZGUuIEZvciBzb21lIHByb2plY3RzLCB0aG91Z2gsIHlvdSBtYXkgd2lzaCB0byByZWZlcmVuY2UgdGhlIGNyYXRlIHdpdGggYVxuZGlmZmVyZW50IG5hbWUgaW4gdGhlIGNvZGUgcmVnYXJkbGVzcyBvZiBob3cgaXQncyBwdWJsaXNoZWQgb24gY3JhdGVzLmlvLiBGb3JcbmV4YW1wbGUgeW91IG1heSB3aXNoIHRvOlxuXG4qIEF2b2lkIHRoZSBuZWVkIHRvICBgdXNlIGZvbyBhcyBiYXJgIGluIFJ1c3Qgc291cmNlLlxuKiBEZXBlbmQgb24gbXVsdGlwbGUgdmVyc2lvbnMgb2YgYSBjcmF0ZS5cbiogRGVwZW5kIG9uIGNyYXRlcyB3aXRoIHRoZSBzYW1lIG5hbWUgZnJvbSBkaWZmZXJlbnQgcmVnaXN0cmllcy5cblxuVG8gc3VwcG9ydCB0aGlzIENhcmdvIHN1cHBvcnRzIGEgYHBhY2thZ2VgIGtleSBpbiB0aGUgYFtkZXBlbmRlbmNpZXNdYCBzZWN0aW9uXG5vZiB3aGljaCBwYWNrYWdlIHNob3VsZCBiZSBkZXBlbmRlZCBvbjpcblxuYGBgdG9tbFxuW3BhY2thZ2VdXG5uYW1lID0gXCJteXBhY2thZ2VcIlxudmVyc2lvbiA9IFwiMC4wLjFcIlxuXG5bZGVwZW5kZW5jaWVzXVxuZm9vID0gXCIwLjFcIlxuYmFyID0geyBnaXQgPSBcImh0dHBzOi8vZ2l0aHViLmNvbS9leGFtcGxlL3Byb2plY3RcIiwgcGFja2FnZSA9IFwiZm9vXCIgfVxuYmF6ID0geyB2ZXJzaW9uID0gXCIwLjFcIiwgcmVnaXN0cnkgPSBcImN1c3RvbVwiLCBwYWNrYWdlID0gXCJmb29cIiB9XG5gYGBcblxuSW4gdGhpcyBleGFtcGxlLCB0aHJlZSBjcmF0ZXMgYXJlIG5vdyBhdmFpbGFibGUgaW4geW91ciBSdXN0IGNvZGU6XG5cbmBgYHJ1c3RcbmV4dGVybiBjcmF0ZSBmb287IC8vIGNyYXRlcy5pb1xuZXh0ZXJuIGNyYXRlIGJhcjsgLy8gZ2l0IHJlcG9zaXRvcnlcbmV4dGVybiBjcmF0ZSBiYXo7IC8vIHJlZ2lzdHJ5IGBjdXN0b21gXG5gYGBcblxuQWxsIHRocmVlIG9mIHRoZXNlIGNyYXRlcyBoYXZlIHRoZSBwYWNrYWdlIG5hbWUgb2YgYGZvb2AgaW4gdGhlaXIgb3duXG5gQ2FyZ28udG9tbGAsIHNvIHdlJ3JlIGV4cGxpY2l0bHkgdXNpbmcgdGhlIGBwYWNrYWdlYCBrZXkgdG8gaW5mb3JtIENhcmdvIHRoYXRcbndlIHdhbnQgdGhlIGBmb29gIHBhY2thZ2UgZXZlbiB0aG91Z2ggd2UncmUgY2FsbGluZyBpdCBzb21ldGhpbmcgZWxzZSBsb2NhbGx5LlxuVGhlIGBwYWNrYWdlYCBrZXksIGlmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHRoZSBuYW1lIG9mIHRoZSBkZXBlbmRlbmN5XG5iZWluZyByZXF1ZXN0ZWQuXG4iLAogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9zcGVjaWZ5aW5nLWRlcGVuZGVuY2llcy5odG1sI3JlbmFtaW5nLWRlcGVuZGVuY2llcy1pbi1jYXJnb3RvbWwiCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICJwYXRoIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIkNhcmdvIHN1cHBvcnRzICoqcGF0aCBkZXBlbmRlbmNpZXMqKiB3aGljaCBhcmUgdHlwaWNhbGx5IHN1Yi1jcmF0ZXMgdGhhdCBsaXZlIHdpdGhpbiBvbmUgcmVwb3NpdG9yeS5cbkxldCdzIHN0YXJ0IG9mZiBieSBtYWtpbmcgYSBuZXcgY3JhdGUgaW5zaWRlIG9mIG91ciBgaGVsbG9fd29ybGRgIHBhY2thZ2U6XG5cbmBgYGNvbnNvbGVcbiMgaW5zaWRlIG9mIGhlbGxvX3dvcmxkL1xuJCBjYXJnbyBuZXcgaGVsbG9fdXRpbHNcbmBgYFxuXG5UaGlzIHdpbGwgY3JlYXRlIGEgbmV3IGZvbGRlciBgaGVsbG9fdXRpbHNgIGluc2lkZSBvZiB3aGljaCBhIGBDYXJnby50b21sYCBhbmRcbmBzcmNgIGZvbGRlciBhcmUgcmVhZHkgdG8gYmUgY29uZmlndXJlZC4gSW4gb3JkZXIgdG8gdGVsbCBDYXJnbyBhYm91dCB0aGlzLCBvcGVuXG51cCBgaGVsbG9fd29ybGQvQ2FyZ28udG9tbGAgYW5kIGFkZCBgaGVsbG9fdXRpbHNgIHRvIHlvdXIgZGVwZW5kZW5jaWVzOlxuXG5gYGB0b21sXG5bZGVwZW5kZW5jaWVzXVxuaGVsbG9fdXRpbHMgPSB7IHBhdGggPSBcImhlbGxvX3V0aWxzXCIgfVxuYGBgXG5cblRoaXMgdGVsbHMgQ2FyZ28gdGhhdCB3ZSBkZXBlbmQgb24gYSBjcmF0ZSBjYWxsZWQgYGhlbGxvX3V0aWxzYCB3aGljaCBpcyBmb3VuZFxuaW4gdGhlIGBoZWxsb191dGlsc2AgZm9sZGVyIChyZWxhdGl2ZSB0byB0aGUgYENhcmdvLnRvbWxgIGl0J3Mgd3JpdHRlbiBpbikuIiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMuaHRtbCNzcGVjaWZ5aW5nLXBhdGgtZGVwZW5kZW5jaWVzIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAicHVibGljIjogewogICAgICAgICAgInR5cGUiOiAiYm9vbGVhbiIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImhpZGRlbiI6IHRydWUKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICJyZWdpc3RyeSI6IHsKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJUbyBzcGVjaWZ5IGEgZGVwZW5kZW5jeSBmcm9tIGEgcmVnaXN0cnkgb3RoZXIgdGhhbiBbY3JhdGVzLmlvXShodHRwczovL2NyYXRlcy5pbyksIGZpcnN0IHRoZVxucmVnaXN0cnkgbXVzdCBiZSBjb25maWd1cmVkIGluIGEgYC5jYXJnby9jb25maWcudG9tbGAgZmlsZS4gU2VlIHRoZSBbcmVnaXN0cmllc1xuZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvcmVnaXN0cmllcy5odG1sKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gSW4gdGhlIGRlcGVuZGVuY3ksIHNldCB0aGUgYHJlZ2lzdHJ5YCBrZXlcbnRvIHRoZSBuYW1lIG9mIHRoZSByZWdpc3RyeSB0byB1c2UuXG5cbmBgYHRvbWxcbltkZXBlbmRlbmNpZXNdXG5zb21lLWNyYXRlID0geyB2ZXJzaW9uID0gXCIxLjBcIiwgcmVnaXN0cnkgPSBcIm15LXJlZ2lzdHJ5XCIgfVxuYGBgXG5cbj4gKipOb3RlKio6IFtjcmF0ZXMuaW9dKGh0dHBzOi8vY3JhdGVzLmlvKSBkb2VzIG5vdCBhbGxvdyBwYWNrYWdlcyB0byBiZSBwdWJsaXNoZWQgd2l0aFxuPiBkZXBlbmRlbmNpZXMgb24gb3RoZXIgcmVnaXN0cmllcy5cbiIsCiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwjc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMtZnJvbS1vdGhlci1yZWdpc3RyaWVzIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAicmVnaXN0cnktaW5kZXgiOiB7CiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJoaWRkZW4iOiB0cnVlCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAicmV2IjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlNwZWNpZnkgdGhlIEdpdCByZXZpc2lvbiB0byB1c2UgaW4gY2FzZSBvZiBhIFtHaXQgZGVwZW5kZW5jeV0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMuaHRtbCNzcGVjaWZ5aW5nLWRlcGVuZGVuY2llcy1mcm9tLWdpdC1yZXBvc2l0b3JpZXMpLiIsCiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwjc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMtZnJvbS1naXQtcmVwb3NpdG9yaWVzIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAidGFnIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlNwZWNpZnkgdGhlIEdpdCB0YWcgdG8gdXNlIGluIGNhc2Ugb2YgYSBbR2l0IGRlcGVuZGVuY3ldKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwjc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMtZnJvbS1naXQtcmVwb3NpdG9yaWVzKS4iLAogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9zcGVjaWZ5aW5nLWRlcGVuZGVuY2llcy5odG1sI3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLWZyb20tZ2l0LXJlcG9zaXRvcmllcyIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgInZlcnNpb24iOiB7CiAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1NlbVZlclJlcXVpcmVtZW50IgogICAgICAgIH0sCiAgICAgICAgIndvcmtzcGFjZSI6IHsKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJJbmhlcml0IHRoaXMgZGVwZW5kZW5jeSBmcm9tIHRoZSB3b3Jrc3BhY2UgbWFuaWZlc3QuIiwKICAgICAgICAgICJ0eXBlIjogImJvb2xlYW4iLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwjaW5oZXJpdGluZy1hLWRlcGVuZGVuY3ktZnJvbS1hLXdvcmtzcGFjZSIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImluaXRGaWVsZHMiOiBbInZlcnNpb24iXQogICAgICB9CiAgICB9LAogICAgIkVkaXRpb24iOiB7CiAgICAgICJ0aXRsZSI6ICJFZGl0aW9uIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgZWRpdGlvbmAga2V5IGFmZmVjdHMgd2hpY2ggZWRpdGlvbiB5b3VyIHBhY2thZ2UgaXMgY29tcGlsZWQgd2l0aC4gQ2FyZ29cbndpbGwgYWx3YXlzIGdlbmVyYXRlIHBhY2thZ2VzIHZpYSBbYGNhcmdvIG5ld2BdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vY29tbWFuZHMvY2FyZ28tbmV3Lmh0bWwpIHdpdGggdGhlIGBlZGl0aW9uYCBrZXkgc2V0IHRvIHRoZVxubGF0ZXN0IGVkaXRpb24uIFNldHRpbmcgdGhlIGBlZGl0aW9uYCBrZXkgaW4gYFtwYWNrYWdlXWAgd2lsbCBhZmZlY3QgYWxsXG50YXJnZXRzL2NyYXRlcyBpbiB0aGUgcGFja2FnZSwgaW5jbHVkaW5nIHRlc3Qgc3VpdGVzLCBiZW5jaG1hcmtzLCBiaW5hcmllcyxcbmV4YW1wbGVzLCBldGMuIiwKICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgImVudW0iOiBbIjIwMTUiLCAiMjAxOCIsICIyMDIxIiwgIjIwMjQiXSwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL3N0YWJsZS9lZGl0aW9uLWd1aWRlL2ludHJvZHVjdGlvbi5odG1sIgogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJMdG8iOiB7CiAgICAgICJ0aXRsZSI6ICJMdG8iLAogICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGBsdG9gIHNldHRpbmcgY29udHJvbHMgdGhlIFtgLUMgbHRvYCBmbGFnXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL3J1c3RjL2NvZGVnZW4tb3B0aW9ucy9pbmRleC5odG1sI2x0bykgd2hpY2ggY29udHJvbHMgTExWTSdzIFtsaW5rIHRpbWUgb3B0aW1pemF0aW9uc10oaHR0cHM6Ly9sbHZtLm9yZy9kb2NzL0xpbmtUaW1lT3B0aW1pemF0aW9uLmh0bWwpLiBMVE8gY2FuIHByb2R1Y2UgYmV0dGVyIG9wdGltaXplZCBjb2RlLCB1c2luZ1xud2hvbGUtcHJvZ3JhbSBhbmFseXNpcywgYXQgdGhlIGNvc3Qgb2YgbG9uZ2VyIGxpbmtpbmcgdGltZS5cbiAgICAgICAgICAgICAgICAgICAgXG5TZWUgYWxzbyB0aGUgW2AtQyBsaW5rZXItcGx1Z2luLWx0b2BdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvcnVzdGMvY29kZWdlbi1vcHRpb25zL2luZGV4Lmh0bWwjbGlua2VyLXBsdWdpbi1sdG8pIGBydXN0Y2AgZmxhZyBmb3IgY3Jvc3MtbGFuZ3VhZ2UgTFRPLiIsCiAgICAgICJlbnVtIjogWyJmYXQiLCAidGhpbiIsICJvZmYiLCB0cnVlLCBmYWxzZV0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJkb2NzIjogewogICAgICAgICAgImVudW1WYWx1ZXMiOiBbCiAgICAgICAgICAgICJQZXJmb3JtcyBcImZhdFwiIExUTyB3aGljaCBhdHRlbXB0cyB0byBwZXJmb3JtIG9wdGltaXphdGlvbnMgYWNyb3NzIGFsbCBjcmF0ZXMgd2l0aGluIHRoZSBkZXBlbmRlbmN5IGdyYXBoLiIsCiAgICAgICAgICAgICJQZXJmb3JtcyBbXCJ0aGluXCIgTFRPXShodHRwOi8vYmxvZy5sbHZtLm9yZy8yMDE2LzA2L3RoaW5sdG8tc2NhbGFibGUtYW5kLWluY3JlbWVudGFsLWx0by5odG1sKS4gVGhpcyBpcyBzaW1pbGFyIHRvIFwiZmF0XCIsIGJ1dCB0YWtlc1xuc3Vic3RhbnRpYWxseSBsZXNzIHRpbWUgdG8gcnVuIHdoaWxlIHN0aWxsIGFjaGlldmluZyBwZXJmb3JtYW5jZSBnYWluc1xuc2ltaWxhciB0byBcImZhdFwiLiIsCiAgICAgICAgICAgICJEaXNhYmxlcyBMVE8uIiwKICAgICAgICAgICAgIlBlcmZvcm1zIFwiZmF0XCIgTFRPIHdoaWNoIGF0dGVtcHRzIHRvIHBlcmZvcm0gb3B0aW1pemF0aW9ucyBhY3Jvc3MgYWxsIGNyYXRlcyB3aXRoaW4gdGhlIGRlcGVuZGVuY3kgZ3JhcGguIiwKICAgICAgICAgICAgIlBlcmZvcm1zIFwidGhpbiBsb2NhbCBMVE9cIiB3aGljaCBwZXJmb3JtcyBcInRoaW5cIiBMVE8gb24gdGhlIGxvY2FsXG5jcmF0ZSBvbmx5IGFjcm9zcyBpdHMgW2NvZGVnZW4gdW5pdHNdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3Byb2ZpbGVzLmh0bWwjY29kZWdlbi11bml0cykuIE5vIExUTyBpcyBwZXJmb3JtZWRcbmlmIGNvZGVnZW4gdW5pdHMgaXMgMSBvciBbb3B0LWxldmVsXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9wcm9maWxlcy5odG1sI29wdC1sZXZlbCkgaXMgMC4iCiAgICAgICAgICBdCiAgICAgICAgfSwKICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3Byb2ZpbGVzLmh0bWwjbHRvIgogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJNZXRhQnVpbGQiOiB7CiAgICAgICJ0aXRsZSI6ICJNZXRhIEJ1aWxkIiwKICAgICAgInR5cGUiOiAiYXJyYXkiLAogICAgICAiaXRlbXMiOiB7CiAgICAgICAgInR5cGUiOiAic3RyaW5nIgogICAgICB9CiAgICB9LAogICAgIlJlc29sdmVyIjogewogICAgICAidGl0bGUiOiAiUmVzb2x2ZXIiLAogICAgICAiZGVzY3JpcHRpb24iOiAiQSBkaWZmZXJlbnQgZmVhdHVyZSByZXNvbHZlciBhbGdvcml0aG0gY2FuIGJlIHVzZWQgYnkgc3BlY2lmeWluZyB0aGUgcmVzb2x2ZXIgdmVyc2lvbiBpbiBDYXJnby50b21sIGxpa2UgdGhpczpcblxuW3BhY2thZ2VdXG5uYW1lID0gXCJteS1wYWNrYWdlXCJcbnZlcnNpb24gPSBcIjEuMC4wXCJcbnJlc29sdmVyID0gXCIyXCJcblxuVGhlIHZlcnNpb24gXCIxXCIgcmVzb2x2ZXIgaXMgdGhlIG9yaWdpbmFsIHJlc29sdmVyIHRoYXQgc2hpcHBlZCB3aXRoIENhcmdvIHVwIHRvIHZlcnNpb24gMS41MC4gVGhlIGRlZmF1bHQgaXMgXCIyXCIgaWYgdGhlIHJvb3QgcGFja2FnZSBzcGVjaWZpZXMgZWRpdGlvbiA9IFwiMjAyMVwiIG9yIGEgbmV3ZXIgZWRpdGlvbi4gT3RoZXJ3aXNlIHRoZSBkZWZhdWx0IGlzIFwiMVwiLlxuXG5UaGUgdmVyc2lvbiBcIjJcIiByZXNvbHZlciBpbnRyb2R1Y2VzIGNoYW5nZXMgaW4gZmVhdHVyZSB1bmlmaWNhdGlvbi4gU2VlIHRoZSBmZWF0dXJlcyBjaGFwdGVyIGZvciBtb3JlIGRldGFpbHMuXG5cblRoZSByZXNvbHZlciBpcyBhIGdsb2JhbCBvcHRpb24gdGhhdCBhZmZlY3RzIHRoZSBlbnRpcmUgd29ya3NwYWNlLiBUaGUgcmVzb2x2ZXIgdmVyc2lvbiBpbiBkZXBlbmRlbmNpZXMgaXMgaWdub3JlZCwgb25seSB0aGUgdmFsdWUgaW4gdGhlIHRvcC1sZXZlbCBwYWNrYWdlIHdpbGwgYmUgdXNlZC4gSWYgdXNpbmcgYSB2aXJ0dWFsIHdvcmtzcGFjZSwgdGhlIHZlcnNpb24gc2hvdWxkIGJlIHNwZWNpZmllZCBpbiB0aGUgW3dvcmtzcGFjZV0gdGFibGUsIGZvciBleGFtcGxlOlxuXG5bd29ya3NwYWNlXVxubWVtYmVycyA9IFtcIm1lbWJlcjFcIiwgXCJtZW1iZXIyXCJdXG5yZXNvbHZlciA9IFwiMlwiIiwKICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgImVudW0iOiBbIjEiLCAiMiIsICIzIl0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvcmVzb2x2ZXIuaHRtbCNyZXNvbHZlci12ZXJzaW9ucyIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAiT3B0TGV2ZWwiOiB7CiAgICAgICJ0aXRsZSI6ICJPcHRpbWl6YXRpb24gTGV2ZWwiLAogICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGBvcHQtbGV2ZWxgIHNldHRpbmcgY29udHJvbHMgdGhlIFtgLUMgb3B0LWxldmVsYCBmbGFnXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL3J1c3RjL2NvZGVnZW4tb3B0aW9ucy9pbmRleC5odG1sI29wdC1sZXZlbCkgd2hpY2ggY29udHJvbHMgdGhlIGxldmVsXG5vZiBvcHRpbWl6YXRpb24uIEhpZ2hlciBvcHRpbWl6YXRpb24gbGV2ZWxzIG1heSBwcm9kdWNlIGZhc3RlciBydW50aW1lIGNvZGUgYXRcbnRoZSBleHBlbnNlIG9mIGxvbmdlciBjb21waWxlciB0aW1lcy4gSGlnaGVyIGxldmVscyBtYXkgYWxzbyBjaGFuZ2UgYW5kXG5yZWFycmFuZ2UgdGhlIGNvbXBpbGVkIGNvZGUgd2hpY2ggbWF5IG1ha2UgaXQgaGFyZGVyIHRvIHVzZSB3aXRoIGEgZGVidWdnZXIuXG5cbkl0IGlzIHJlY29tbWVuZGVkIHRvIGV4cGVyaW1lbnQgd2l0aCBkaWZmZXJlbnQgbGV2ZWxzIHRvIGZpbmQgdGhlIHJpZ2h0XG5iYWxhbmNlIGZvciB5b3VyIHByb2plY3QuIFRoZXJlIG1heSBiZSBzdXJwcmlzaW5nIHJlc3VsdHMsIHN1Y2ggYXMgbGV2ZWwgYDNgXG5iZWluZyBzbG93ZXIgdGhhbiBgMmAsIG9yIHRoZSBgXCJzXCJgIGFuZCBgXCJ6XCJgIGxldmVscyBub3QgYmVpbmcgbmVjZXNzYXJpbHlcbnNtYWxsZXIuIFlvdSBtYXkgYWxzbyB3YW50IHRvIHJlZXZhbHVhdGUgeW91ciBzZXR0aW5ncyBvdmVyIHRpbWUgYXMgbmV3ZXJcbnZlcnNpb25zIG9mIGBydXN0Y2AgY2hhbmdlcyBvcHRpbWl6YXRpb24gYmVoYXZpb3IuXG5cblNlZSBhbHNvIFtQcm9maWxlIEd1aWRlZCBPcHRpbWl6YXRpb25dKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvcnVzdGMvcHJvZmlsZS1ndWlkZWQtb3B0aW1pemF0aW9uLmh0bWwpIGZvciBtb3JlIGFkdmFuY2VkIG9wdGltaXphdGlvblxudGVjaG5pcXVlcy4iLAogICAgICAiZW51bSI6IFswLCAxLCAyLCAzLCAicyIsICJ6Il0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJkb2NzIjogewogICAgICAgICAgImVudW1WYWx1ZXMiOiBbCiAgICAgICAgICAgICJObyBvcHRpbWl6YXRpb25zLCBhbHNvIHR1cm5zIG9uIFtgY2ZnKGRlYnVnX2Fzc2VydGlvbnMpYF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvcHJvZmlsZXMuaHRtbCNkZWJ1Zy1hc3NlcnRpb25zKS4iLAogICAgICAgICAgICAiQmFzaWMgb3B0aW1pemF0aW9ucy4iLAogICAgICAgICAgICAiU29tZSBvcHRpbWl6YXRpb25zLiIsCiAgICAgICAgICAgICJBbGwgb3B0aW1pemF0aW9ucy4iLAogICAgICAgICAgICAiT3B0aW1pemUgZm9yIGJpbmFyeSBzaXplLiIsCiAgICAgICAgICAgICJPcHRpbWl6ZSBmb3IgYmluYXJ5IHNpemUsIGJ1dCBhbHNvIHR1cm4gb2ZmIGxvb3AgdmVjdG9yaXphdGlvbi4iCiAgICAgICAgICBdCiAgICAgICAgfSwKICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3Byb2ZpbGVzLmh0bWwjb3B0LWxldmVsIgogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJQYWNrYWdlIjogewogICAgICAidGl0bGUiOiAiUGFja2FnZSIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgb25seSBmaWVsZCByZXF1aXJlZCBieSBDYXJnbyBpcyBbYG5hbWVgXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9tYW5pZmVzdC5odG1sI3RoZS1uYW1lLWZpZWxkKS5cbiBJZiBwdWJsaXNoaW5nIHRvIGEgcmVnaXN0cnksIHRoZSByZWdpc3RyeSBtYXlcbnJlcXVpcmUgYWRkaXRpb25hbCBmaWVsZHMuIFNlZSB0aGUgbm90ZXMgYmVsb3cgYW5kIFt0aGUgcHVibGlzaGluZyBjaGFwdGVyXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9wdWJsaXNoaW5nLmh0bWwpIGZvciByZXF1aXJlbWVudHMgZm9yIHB1Ymxpc2hpbmcgdG8gW2NyYXRlcy5pb10oaHR0cHM6Ly9jcmF0ZXMuaW8vKS4iLAogICAgICAidHlwZSI6ICJvYmplY3QiLAogICAgICAicmVxdWlyZWQiOiBbIm5hbWUiXSwKICAgICAgInByb3BlcnRpZXMiOiB7CiAgICAgICAgImF1dGhvcnMiOiB7CiAgICAgICAgICAiYW55T2YiOiBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL0F1dGhvcnMiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1dvcmtzcGFjZUluaGVyaXRhbmNlIgogICAgICAgICAgICB9CiAgICAgICAgICBdCiAgICAgICAgfSwKICAgICAgICAiYXV0b2JlbmNoZXMiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiRGlzYWJsZSBhdXRvbWF0aWMgZGlzY292ZXJ5IG9mIGBiZW5jaGAgdGFyZ2V0cy5cblxuRGlzYWJsaW5nIGF1dG9tYXRpYyBkaXNjb3Zlcnkgc2hvdWxkIG9ubHkgYmUgbmVlZGVkIGZvciBzcGVjaWFsaXplZFxuc2l0dWF0aW9ucy4gRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIGEgbGlicmFyeSB3aGVyZSB5b3Ugd2FudCBhICptb2R1bGUqIG5hbWVkXG5gYmluYCwgdGhpcyB3b3VsZCBwcmVzZW50IGEgcHJvYmxlbSBiZWNhdXNlIENhcmdvIHdvdWxkIHVzdWFsbHkgYXR0ZW1wdCB0b1xuY29tcGlsZSBhbnl0aGluZyBpbiB0aGUgYGJpbmAgZGlyZWN0b3J5IGFzIGFuIGV4ZWN1dGFibGUuIEhlcmUgaXMgYSBzYW1wbGVcbmxheW91dCBvZiB0aGlzIHNjZW5hcmlvOlxuXG5gYGBcbuKUnOKUgOKUgCBDYXJnby50b21sXG7ilJTilIDilIAgc3JjXG4gICAg4pSc4pSA4pSAIGxpYi5yc1xuICAgIOKUlOKUgOKUgCBiaW5cbiAgICAgICAg4pSU4pSA4pSAIG1vZC5yc1xuYGBgXG4iLAogICAgICAgICAgInR5cGUiOiAiYm9vbGVhbiIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI3RhcmdldC1hdXRvLWRpc2NvdmVyeSIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgImF1dG9iaW5zIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIkRpc2FibGUgYXV0b21hdGljIGRpc2NvdmVyeSBvZiBgYmluYCB0YXJnZXRzLlxuXG5EaXNhYmxpbmcgYXV0b21hdGljIGRpc2NvdmVyeSBzaG91bGQgb25seSBiZSBuZWVkZWQgZm9yIHNwZWNpYWxpemVkXG5zaXR1YXRpb25zLiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgYSBsaWJyYXJ5IHdoZXJlIHlvdSB3YW50IGEgKm1vZHVsZSogbmFtZWRcbmBiaW5gLCB0aGlzIHdvdWxkIHByZXNlbnQgYSBwcm9ibGVtIGJlY2F1c2UgQ2FyZ28gd291bGQgdXN1YWxseSBhdHRlbXB0IHRvXG5jb21waWxlIGFueXRoaW5nIGluIHRoZSBgYmluYCBkaXJlY3RvcnkgYXMgYW4gZXhlY3V0YWJsZS4gSGVyZSBpcyBhIHNhbXBsZVxubGF5b3V0IG9mIHRoaXMgc2NlbmFyaW86XG5cbmBgYFxu4pSc4pSA4pSAIENhcmdvLnRvbWxcbuKUlOKUgOKUgCBzcmNcbiAgICDilJzilIDilIAgbGliLnJzXG4gICAg4pSU4pSA4pSAIGJpblxuICAgICAgICDilJTilIDilIAgbW9kLnJzXG5gYGBcblxuVG8gcHJldmVudCBDYXJnbyBmcm9tIGluZmVycmluZyBgc3JjL2Jpbi9tb2QucnNgIGFzIGFuIGV4ZWN1dGFibGUsIHNldFxudGhpcyB0byBgZmFsc2VgIHRvIGRpc2FibGUgYXV0by1kaXNjb3ZlcnkuIiwKICAgICAgICAgICJ0eXBlIjogImJvb2xlYW4iLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2NhcmdvLXRhcmdldHMuaHRtbCN0YXJnZXQtYXV0by1kaXNjb3ZlcnkiCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICJhdXRvZXhhbXBsZXMiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiRGlzYWJsZSBhdXRvbWF0aWMgZGlzY292ZXJ5IG9mIGBleGFtcGxlYCB0YXJnZXRzLlxuXG5EaXNhYmxpbmcgYXV0b21hdGljIGRpc2NvdmVyeSBzaG91bGQgb25seSBiZSBuZWVkZWQgZm9yIHNwZWNpYWxpemVkXG5zaXR1YXRpb25zLiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgYSBsaWJyYXJ5IHdoZXJlIHlvdSB3YW50IGEgKm1vZHVsZSogbmFtZWRcbmBiaW5gLCB0aGlzIHdvdWxkIHByZXNlbnQgYSBwcm9ibGVtIGJlY2F1c2UgQ2FyZ28gd291bGQgdXN1YWxseSBhdHRlbXB0IHRvXG5jb21waWxlIGFueXRoaW5nIGluIHRoZSBgYmluYCBkaXJlY3RvcnkgYXMgYW4gZXhlY3V0YWJsZS4gSGVyZSBpcyBhIHNhbXBsZVxubGF5b3V0IG9mIHRoaXMgc2NlbmFyaW86XG5cbmBgYFxu4pSc4pSA4pSAIENhcmdvLnRvbWxcbuKUlOKUgOKUgCBzcmNcbiAgICDilJzilIDilIAgbGliLnJzXG4gICAg4pSU4pSA4pSAIGJpblxuICAgICAgICDilJTilIDilIAgbW9kLnJzXG5gYGBcbiIsCiAgICAgICAgICAidHlwZSI6ICJib29sZWFuIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9jYXJnby10YXJnZXRzLmh0bWwjdGFyZ2V0LWF1dG8tZGlzY292ZXJ5IgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiYXV0b3Rlc3RzIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIkRpc2FibGUgYXV0b21hdGljIGRpc2NvdmVyeSBvZiBgdGVzdGAgdGFyZ2V0cy5cblxuRGlzYWJsaW5nIGF1dG9tYXRpYyBkaXNjb3Zlcnkgc2hvdWxkIG9ubHkgYmUgbmVlZGVkIGZvciBzcGVjaWFsaXplZFxuc2l0dWF0aW9ucy4gRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIGEgbGlicmFyeSB3aGVyZSB5b3Ugd2FudCBhICptb2R1bGUqIG5hbWVkXG5gYmluYCwgdGhpcyB3b3VsZCBwcmVzZW50IGEgcHJvYmxlbSBiZWNhdXNlIENhcmdvIHdvdWxkIHVzdWFsbHkgYXR0ZW1wdCB0b1xuY29tcGlsZSBhbnl0aGluZyBpbiB0aGUgYGJpbmAgZGlyZWN0b3J5IGFzIGFuIGV4ZWN1dGFibGUuIEhlcmUgaXMgYSBzYW1wbGVcbmxheW91dCBvZiB0aGlzIHNjZW5hcmlvOlxuXG5gYGBcbuKUnOKUgOKUgCBDYXJnby50b21sXG7ilJTilIDilIAgc3JjXG4gICAg4pSc4pSA4pSAIGxpYi5yc1xuICAgIOKUlOKUgOKUgCBiaW5cbiAgICAgICAg4pSU4pSA4pSAIG1vZC5yc1xuYGBgXG4iLAogICAgICAgICAgInR5cGUiOiAiYm9vbGVhbiIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI3RhcmdldC1hdXRvLWRpc2NvdmVyeSIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgImJ1aWxkIjogewogICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9CdWlsZCIKICAgICAgICB9LAogICAgICAgICJjYXRlZ29yaWVzIjogewogICAgICAgICAgImFueU9mIjogWwogICAgICAgICAgICB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9DYXRlZ29yaWVzIgogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9Xb3Jrc3BhY2VJbmhlcml0YW5jZSIKICAgICAgICAgICAgfQogICAgICAgICAgXQogICAgICAgIH0sCiAgICAgICAgImRlZmF1bHQtcnVuIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgZGVmYXVsdC1ydW5gIGZpZWxkIGluIHRoZSBgW3BhY2thZ2VdYCBzZWN0aW9uIG9mIHRoZSBtYW5pZmVzdCBjYW4gYmUgdXNlZFxudG8gc3BlY2lmeSBhIGRlZmF1bHQgYmluYXJ5IHBpY2tlZCBieSBbYGNhcmdvIHJ1bmBdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vY29tbWFuZHMvY2FyZ28tcnVuLmh0bWwpLiBGb3IgZXhhbXBsZSwgd2hlbiB0aGVyZSBpc1xuYm90aCBgc3JjL2Jpbi9hLnJzYCBhbmQgYHNyYy9iaW4vYi5yc2A6XG5cbmBgYHRvbWxcbltwYWNrYWdlXVxuZGVmYXVsdC1ydW4gPSBcImFcIlxuYGBgIiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvbWFuaWZlc3QuaHRtbCN0aGUtZGVmYXVsdC1ydW4tZmllbGQiCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICJkZXNjcmlwdGlvbiI6IHsKICAgICAgICAgICJhbnlPZiI6IFsKICAgICAgICAgICAgewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvRGVzY3JpcHRpb24iCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1dvcmtzcGFjZUluaGVyaXRhbmNlIgogICAgICAgICAgICB9CiAgICAgICAgICBdCiAgICAgICAgfSwKICAgICAgICAiZG9jdW1lbnRhdGlvbiI6IHsKICAgICAgICAgICJhbnlPZiI6IFsKICAgICAgICAgICAgewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvRG9jdW1lbnRhdGlvbiIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvV29ya3NwYWNlSW5oZXJpdGFuY2UiCiAgICAgICAgICAgIH0KICAgICAgICAgIF0KICAgICAgICB9LAogICAgICAgICJlZGl0aW9uIjogewogICAgICAgICAgImFueU9mIjogWwogICAgICAgICAgICB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9FZGl0aW9uIgogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9Xb3Jrc3BhY2VJbmhlcml0YW5jZSIKICAgICAgICAgICAgfQogICAgICAgICAgXQogICAgICAgIH0sCiAgICAgICAgImV4Y2x1ZGUiOiB7CiAgICAgICAgICAiYW55T2YiOiBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL0V4Y2x1ZGUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1dvcmtzcGFjZUluaGVyaXRhbmNlIgogICAgICAgICAgICB9CiAgICAgICAgICBdCiAgICAgICAgfSwKICAgICAgICAiaG9tZXBhZ2UiOiB7CiAgICAgICAgICAiYW55T2YiOiBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL0hvbWVwYWdlIgogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9Xb3Jrc3BhY2VJbmhlcml0YW5jZSIKICAgICAgICAgICAgfQogICAgICAgICAgXQogICAgICAgIH0sCiAgICAgICAgImltLWEtdGVhcG90IjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlNldHMgd2hldGhlciB0aGUgY3VycmVudCBwYWNrYWdlIGlzIGEgdGVhcG90IG9yIHNvbWV0aGluZyBlbHNlIHRoYXQgaXMgbm90IGNhcGFibGUgb2YgYnJld2luZyB0ZWEuIiwKICAgICAgICAgICJ0eXBlIjogImJvb2xlYW4iLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJoaWRkZW4iOiB0cnVlCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiaW5jbHVkZSI6IHsKICAgICAgICAgICJhbnlPZiI6IFsKICAgICAgICAgICAgewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvSW5jbHVkZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvV29ya3NwYWNlSW5oZXJpdGFuY2UiCiAgICAgICAgICAgIH0KICAgICAgICAgIF0KICAgICAgICB9LAogICAgICAgICJrZXl3b3JkcyI6IHsKICAgICAgICAgICJhbnlPZiI6IFsKICAgICAgICAgICAgewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvS2V5d29yZHMiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1dvcmtzcGFjZUluaGVyaXRhbmNlIgogICAgICAgICAgICB9CiAgICAgICAgICBdCiAgICAgICAgfSwKICAgICAgICAibGljZW5zZSI6IHsKICAgICAgICAgICJhbnlPZiI6IFsKICAgICAgICAgICAgewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvTGljZW5zZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvV29ya3NwYWNlSW5oZXJpdGFuY2UiCiAgICAgICAgICAgIH0KICAgICAgICAgIF0KICAgICAgICB9LAogICAgICAgICJsaWNlbnNlLWZpbGUiOiB7CiAgICAgICAgICAiYW55T2YiOiBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL0xpY2Vuc2VGaWxlIgogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9Xb3Jrc3BhY2VJbmhlcml0YW5jZSIKICAgICAgICAgICAgfQogICAgICAgICAgXQogICAgICAgIH0sCiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgbGlua3NgIGZpZWxkIHNwZWNpZmllcyB0aGUgbmFtZSBvZiBhIG5hdGl2ZSBsaWJyYXJ5IHRoYXQgaXMgYmVpbmcgbGlua2VkXG50by4gTW9yZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gdGhlIFtgbGlua3NgXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9idWlsZC1zY3JpcHRzLmh0bWwjdGhlLWxpbmtzLW1hbmlmZXN0LWtleSkgc2VjdGlvbiBvZiB0aGUgYnVpbGRcbnNjcmlwdCBndWlkZS5cblxuYGBgdG9tbFxuW3BhY2thZ2VdXG4jIC4uLlxubGlua3MgPSBcImZvb1wiXG5gYGAiLAogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9tYW5pZmVzdC5odG1sI3RoZS1saW5rcy1maWVsZCIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgIm1ldGFidWlsZCI6IHsKICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvTWV0YUJ1aWxkIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAiaGlkZGVuIjogdHJ1ZQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgIm1ldGFkYXRhIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIkNhcmdvIGJ5IGRlZmF1bHQgd2lsbCB3YXJuIGFib3V0IHVudXNlZCBrZXlzIGluIGBDYXJnby50b21sYCB0byBhc3Npc3QgaW5cbmRldGVjdGluZyB0eXBvcyBhbmQgc3VjaC4gVGhlIGBwYWNrYWdlLm1ldGFkYXRhYCB0YWJsZSwgaG93ZXZlciwgaXMgY29tcGxldGVseVxuaWdub3JlZCBieSBDYXJnbyBhbmQgd2lsbCBub3QgYmUgd2FybmVkIGFib3V0LiBUaGlzIHNlY3Rpb24gY2FuIGJlIHVzZWQgZm9yXG50b29scyB3aGljaCB3b3VsZCBsaWtlIHRvIHN0b3JlIHBhY2thZ2UgY29uZmlndXJhdGlvbiBpbiBgQ2FyZ28udG9tbGAuIEZvclxuZXhhbXBsZTpcblxuYGBgdG9tbFxuW3BhY2thZ2VdXG5uYW1lID0gXCIuLi5cIlxuIyAuLi5cblxuIyBNZXRhZGF0YSB1c2VkIHdoZW4gZ2VuZXJhdGluZyBhbiBBbmRyb2lkIEFQSywgZm9yIGV4YW1wbGUuXG5bcGFja2FnZS5tZXRhZGF0YS5hbmRyb2lkXVxucGFja2FnZS1uYW1lID0gXCJteS1hd2Vzb21lLWFuZHJvaWQtYXBwXCJcbmFzc2V0cyA9IFwicGF0aC90by9zdGF0aWNcIlxuYGBgXG4iLAogICAgICAgICAgInR5cGUiOiAib2JqZWN0IiwKICAgICAgICAgICJhZGRpdGlvbmFsUHJvcGVydGllcyI6IHRydWUsCiAgICAgICAgICAicHJvcGVydGllcyI6IHsKICAgICAgICAgICAgInBsYXlkYXRlIjogewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvUGxheWRhdGVNZXRhZGF0YSIKICAgICAgICAgICAgfQogICAgICAgICAgfSwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9tYW5pZmVzdC5odG1sI3RoZS1tZXRhZGF0YS10YWJsZSIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgIm5hbWUiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIHBhY2thZ2UgbmFtZSBpcyBhbiBpZGVudGlmaWVyIHVzZWQgdG8gcmVmZXIgdG8gdGhlIHBhY2thZ2UuIEl0IGlzIHVzZWRcbndoZW4gbGlzdGVkIGFzIGEgZGVwZW5kZW5jeSBpbiBhbm90aGVyIHBhY2thZ2UsIGFuZCBhcyB0aGUgZGVmYXVsdCBuYW1lIG9mXG5pbmZlcnJlZCBsaWIgYW5kIGJpbiB0YXJnZXRzLlxuXG5UaGUgbmFtZSBtdXN0IHVzZSBvbmx5IFthbHBoYW51bWVyaWNdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvc3RkL3ByaW1pdGl2ZS5jaGFyLmh0bWwjbWV0aG9kLmlzX2FscGhhbnVtZXJpYykgY2hhcmFjdGVycyBvciBgLWAgb3IgYF9gLCBhbmQgY2Fubm90IGJlIGVtcHR5LlxuTm90ZSB0aGF0IFtgY2FyZ28gbmV3YF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9jb21tYW5kcy9jYXJnby1uZXcuaHRtbCkgYW5kIFtgY2FyZ28gaW5pdGBdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vY29tbWFuZHMvY2FyZ28taW5pdC5odG1sKSBpbXBvc2Ugc29tZSBhZGRpdGlvbmFsIHJlc3RyaWN0aW9ucyBvblxudGhlIHBhY2thZ2UgbmFtZSwgc3VjaCBhcyBlbmZvcmNpbmcgdGhhdCBpdCBpcyBhIHZhbGlkIFJ1c3QgaWRlbnRpZmllciBhbmQgbm90XG5hIGtleXdvcmQuIFtjcmF0ZXMuaW9dKGh0dHBzOi8vY3JhdGVzLmlvKSBpbXBvc2VzIGV2ZW4gbW9yZSByZXN0cmljdGlvbnMsIHN1Y2ggYXNcbmVuZm9yY2luZyBvbmx5IEFTQ0lJIGNoYXJhY3RlcnMsIG5vdCBhIHJlc2VydmVkIG5hbWUsIG5vdCBhIHNwZWNpYWwgV2luZG93c1xubmFtZSBzdWNoIGFzIFwibnVsXCIsIGlzIG5vdCB0b28gbG9uZywgZXRjLiIsCiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL21hbmlmZXN0Lmh0bWwjdGhlLW5hbWUtZmllbGQiCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICJuYW1lc3BhY2VkLWZlYXR1cmVzIjogewogICAgICAgICAgInR5cGUiOiAiYm9vbGVhbiIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImhpZGRlbiI6IHRydWUKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICJwdWJsaXNoIjogewogICAgICAgICAgImFueU9mIjogWwogICAgICAgICAgICB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9QdWJsaXNoIgogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9Xb3Jrc3BhY2VJbmhlcml0YW5jZSIKICAgICAgICAgICAgfQogICAgICAgICAgXQogICAgICAgIH0sCiAgICAgICAgInB1Ymxpc2gtbG9ja2ZpbGUiOiB7CiAgICAgICAgICAidHlwZSI6ICJib29sZWFuIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAiaGlkZGVuIjogdHJ1ZQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgInJlYWRtZSI6IHsKICAgICAgICAgICJhbnlPZiI6IFsKICAgICAgICAgICAgewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvUmVhZG1lIgogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9Xb3Jrc3BhY2VJbmhlcml0YW5jZSIKICAgICAgICAgICAgfQogICAgICAgICAgXQogICAgICAgIH0sCiAgICAgICAgInJlcG9zaXRvcnkiOiB7CiAgICAgICAgICAiYW55T2YiOiBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1JlcG9zaXRvcnkiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1dvcmtzcGFjZUluaGVyaXRhbmNlIgogICAgICAgICAgICB9CiAgICAgICAgICBdCiAgICAgICAgfSwKICAgICAgICAicmVzb2x2ZXIiOiB7CiAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1Jlc29sdmVyIgogICAgICAgIH0sCiAgICAgICAgInJ1c3QtdmVyc2lvbiI6IHsKICAgICAgICAgICJhbnlPZiI6IFsKICAgICAgICAgICAgewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvUnVzdFZlcnNpb24iCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1dvcmtzcGFjZUluaGVyaXRhbmNlIgogICAgICAgICAgICB9CiAgICAgICAgICBdCiAgICAgICAgfSwKICAgICAgICAidmVyc2lvbiI6IHsKICAgICAgICAgICJhbnlPZiI6IFsKICAgICAgICAgICAgewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvU2VtVmVyIgogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9Xb3Jrc3BhY2VJbmhlcml0YW5jZSIKICAgICAgICAgICAgfQogICAgICAgICAgXQogICAgICAgIH0sCiAgICAgICAgIndvcmtzcGFjZSI6IHsKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYHdvcmtzcGFjZWAgZmllbGQgY2FuIGJlIHVzZWQgdG8gY29uZmlndXJlIHRoZSB3b3Jrc3BhY2UgdGhhdCB0aGlzIHBhY2thZ2VcbndpbGwgYmUgYSBtZW1iZXIgb2YuIElmIG5vdCBzcGVjaWZpZWQgdGhpcyB3aWxsIGJlIGluZmVycmVkIGFzIHRoZSBmaXJzdFxuQ2FyZ28udG9tbCB3aXRoIGBbd29ya3NwYWNlXWAgdXB3YXJkcyBpbiB0aGUgZmlsZXN5c3RlbS4gU2V0dGluZyB0aGlzIGlzXG51c2VmdWwgaWYgdGhlIG1lbWJlciBpcyBub3QgaW5zaWRlIGEgc3ViZGlyZWN0b3J5IG9mIHRoZSB3b3Jrc3BhY2Ugcm9vdC5cblxuYGBgdG9tbFxuW3BhY2thZ2VdXG4jIC4uLlxud29ya3NwYWNlID0gXCJwYXRoL3RvL3dvcmtzcGFjZS9yb290XCJcbmBgYFxuXG5UaGlzIGZpZWxkIGNhbm5vdCBiZSBzcGVjaWZpZWQgaWYgdGhlIG1hbmlmZXN0IGFscmVhZHkgaGFzIGEgYFt3b3Jrc3BhY2VdYFxudGFibGUgZGVmaW5lZC4gVGhhdCBpcywgYSBjcmF0ZSBjYW5ub3QgYm90aCBiZSBhIHJvb3QgY3JhdGUgaW4gYSB3b3Jrc3BhY2Vcbihjb250YWluIGBbd29ya3NwYWNlXWApIGFuZCBhbHNvIGJlIGEgbWVtYmVyIGNyYXRlIG9mIGFub3RoZXIgd29ya3NwYWNlXG4oY29udGFpbiBgcGFja2FnZS53b3Jrc3BhY2VgKS5cblxuRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgW3dvcmtzcGFjZXMgY2hhcHRlcl0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvd29ya3NwYWNlcy5odG1sKS4iLAogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9tYW5pZmVzdC5odG1sI3RoZS13b3Jrc3BhY2UtZmllbGQiCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvbWFuaWZlc3QuaHRtbCN0aGUtcGFja2FnZS1zZWN0aW9uIgogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJQYW5pYyI6IHsKICAgICAgInRpdGxlIjogIlBhbmljIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgcGFuaWNgIHNldHRpbmcgY29udHJvbHMgdGhlIFtgLUMgcGFuaWNgIGZsYWddKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvcnVzdGMvY29kZWdlbi1vcHRpb25zL2luZGV4Lmh0bWwjcGFuaWMpIHdoaWNoIGNvbnRyb2xzIHdoaWNoIHBhbmljXG5zdHJhdGVneSB0byB1c2UuXG5cbldoZW4gc2V0IHRvIGBcInVud2luZFwiYCwgdGhlIGFjdHVhbCB2YWx1ZSBkZXBlbmRzIG9uIHRoZSBkZWZhdWx0IG9mIHRoZSB0YXJnZXRcbnBsYXRmb3JtLiBGb3IgZXhhbXBsZSwgdGhlIE5WUFRYIHBsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgdW53aW5kaW5nLCBzbyBpdFxuYWx3YXlzIHVzZXMgYFwiYWJvcnRcImAuXG5cblRlc3RzLCBiZW5jaG1hcmtzLCBidWlsZCBzY3JpcHRzLCBhbmQgcHJvYyBtYWNyb3MgaWdub3JlIHRoZSBgcGFuaWNgIHNldHRpbmcuXG5UaGUgYHJ1c3RjYCB0ZXN0IGhhcm5lc3MgY3VycmVudGx5IHJlcXVpcmVzIGB1bndpbmRgIGJlaGF2aW9yLiBTZWUgdGhlXG5bYHBhbmljLWFib3J0LXRlc3RzYF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvdW5zdGFibGUuaHRtbCNwYW5pYy1hYm9ydC10ZXN0cykgdW5zdGFibGUgZmxhZyB3aGljaCBlbmFibGVzIGBhYm9ydGAgYmVoYXZpb3IuXG5cbkFkZGl0aW9uYWxseSwgd2hlbiB1c2luZyB0aGUgYGFib3J0YCBzdHJhdGVneSBhbmQgYnVpbGRpbmcgYSB0ZXN0LCBhbGwgb2YgdGhlXG5kZXBlbmRlbmNpZXMgd2lsbCBhbHNvIGJlIGZvcmNlZCB0byBidWlsdCB3aXRoIHRoZSBgdW53aW5kYCBzdHJhdGVneS4iLAogICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAiZW51bSI6IFsidW53aW5kIiwgImFib3J0Il0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJkb2NzIjogewogICAgICAgICAgImVudW1WYWx1ZXMiOiBbCiAgICAgICAgICAgICJVbndpbmQgdGhlIHN0YWNrIHVwb24gcGFuaWMuIiwKICAgICAgICAgICAgIlRlcm1pbmF0ZSB0aGUgcHJvY2VzcyB1cG9uIHBhbmljLiIKICAgICAgICAgIF0KICAgICAgICB9LAogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvcHJvZmlsZXMuaHRtbCNwYW5pYyIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAiUGxhdGZvcm0iOiB7CiAgICAgICJ0aXRsZSI6ICJQbGF0Zm9ybSIsCiAgICAgICJ0eXBlIjogIm9iamVjdCIsCiAgICAgICJwcm9wZXJ0aWVzIjogewogICAgICAgICJidWlsZC1kZXBlbmRlbmNpZXMiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiWW91IGNhbiBkZXBlbmQgb24gb3RoZXIgQ2FyZ28tYmFzZWQgY3JhdGVzIGZvciB1c2UgaW4geW91ciBidWlsZCBzY3JpcHRzLlxuRGVwZW5kZW5jaWVzIGFyZSBkZWNsYXJlZCB0aHJvdWdoIHRoZSBgYnVpbGQtZGVwZW5kZW5jaWVzYCBzZWN0aW9uIG9mIHRoZVxubWFuaWZlc3Q6XG5cbmBgYHRvbWxcbltidWlsZC1kZXBlbmRlbmNpZXNdXG5jYyA9IFwiMS4wLjNcIlxuYGBgXG5cblRoZSBidWlsZCBzY3JpcHQgKipkb2VzIG5vdCoqIGhhdmUgYWNjZXNzIHRvIHRoZSBkZXBlbmRlbmNpZXMgbGlzdGVkXG5pbiB0aGUgYGRlcGVuZGVuY2llc2Agb3IgYGRldi1kZXBlbmRlbmNpZXNgIHNlY3Rpb24uIEJ1aWxkXG5kZXBlbmRlbmNpZXMgd2lsbCBsaWtld2lzZSBub3QgYmUgYXZhaWxhYmxlIHRvIHRoZSBwYWNrYWdlIGl0c2VsZlxudW5sZXNzIGxpc3RlZCB1bmRlciB0aGUgYGRlcGVuZGVuY2llc2Agc2VjdGlvbiBhcyB3ZWxsLiBBIHBhY2thZ2Vcbml0c2VsZiBhbmQgaXRzIGJ1aWxkIHNjcmlwdCBhcmUgYnVpbHQgc2VwYXJhdGVseSwgc28gdGhlaXJcbmRlcGVuZGVuY2llcyBuZWVkIG5vdCBjb2luY2lkZS4gQ2FyZ28gaXMga2VwdCBzaW1wbGVyIGFuZCBjbGVhbmVyIGJ5XG51c2luZyBpbmRlcGVuZGVudCBkZXBlbmRlbmNpZXMgZm9yIGluZGVwZW5kZW50IHB1cnBvc2VzLiIsCiAgICAgICAgICAidHlwZSI6ICJvYmplY3QiLAogICAgICAgICAgImFkZGl0aW9uYWxQcm9wZXJ0aWVzIjogewogICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL0RlcGVuZGVuY3kiCiAgICAgICAgICB9LAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwjYnVpbGQtZGVwZW5kZW5jaWVzIgogICAgICAgICAgICB9LAogICAgICAgICAgICAicGx1Z2lucyI6IFsiY3JhdGVzIl0sCiAgICAgICAgICAgICJjcmF0ZXMiOiB7CiAgICAgICAgICAgICAgInNjaGVtYXMiOiAiZGVwZW5kZW5jaWVzIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiYnVpbGRfZGVwZW5kZW5jaWVzIjogewogICAgICAgICAgInR5cGUiOiAib2JqZWN0IiwKICAgICAgICAgICJhZGRpdGlvbmFsUHJvcGVydGllcyI6IHsKICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9EZXBlbmRlbmN5IgogICAgICAgICAgfSwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAiaGlkZGVuIjogdHJ1ZQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgImRlcGVuZGVuY2llcyI6IHsKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJDYXJnbyBpcyBjb25maWd1cmVkIHRvIGxvb2sgZm9yIGRlcGVuZGVuY2llcyBvbiBbY3JhdGVzLmlvXShodHRwczovL2NyYXRlcy5pbykgYnkgZGVmYXVsdC4gT25seVxudGhlIG5hbWUgYW5kIGEgdmVyc2lvbiBzdHJpbmcgYXJlIHJlcXVpcmVkIGluIHRoaXMgY2FzZS4gSW4gW3RoZSBjYXJnb1xuZ3VpZGVdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vZ3VpZGUvaW5kZXguaHRtbCksIHdlIHNwZWNpZmllZCBhIGRlcGVuZGVuY3kgb24gdGhlIGB0aW1lYCBjcmF0ZTpcblxuYGBgdG9tbFxuW2RlcGVuZGVuY2llc11cbnRpbWUgPSBcIjAuMS4xMlwiXG5gYGBcblxuVGhlIHN0cmluZyBgXCIwLjEuMTJcImAgaXMgYSBbc2VtdmVyXShodHRwczovL2dpdGh1Yi5jb20vc3RldmVrbGFibmlrL3NlbXZlciNyZXF1aXJlbWVudHMpIHZlcnNpb24gcmVxdWlyZW1lbnQuIFNpbmNlIHRoaXNcbnN0cmluZyBkb2VzIG5vdCBoYXZlIGFueSBvcGVyYXRvcnMgaW4gaXQsIGl0IGlzIGludGVycHJldGVkIHRoZSBzYW1lIHdheSBhc1xuaWYgd2UgaGFkIHNwZWNpZmllZCBgXCJeMC4xLjEyXCJgLCB3aGljaCBpcyBjYWxsZWQgYSBjYXJldCByZXF1aXJlbWVudC5cblxuQSBkZXBlbmRlbmN5IGNhbiBhbHNvIGJlIGRlZmluZWQgYnkgYSB0YWJsZSB3aXRoIGFkZGl0aW9uYWwgb3B0aW9uczpcblxuYGBgdG9tbFxuW2RlcGVuZGVuY2llc11cbnRpbWUgPSB7IHBhdGggPSBcIi4uL3RpbWVcIiwgdmVyc2lvbiA9IFwiMC4xLjEyXCIgfVxuYGBgIiwKICAgICAgICAgICJ0eXBlIjogIm9iamVjdCIsCiAgICAgICAgICAiYWRkaXRpb25hbFByb3BlcnRpZXMiOiB7CiAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvRGVwZW5kZW5jeSIKICAgICAgICAgIH0sCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMuaHRtbCIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgImRldi1kZXBlbmRlbmNpZXMiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGZvcm1hdCBvZiBgW2Rldi1kZXBlbmRlbmNpZXNdYCBpcyBlcXVpdmFsZW50IHRvIGBbZGVwZW5kZW5jaWVzXWA6XG5cbmBgYHRvbWxcbltkZXYtZGVwZW5kZW5jaWVzXVxudGVtcGRpciA9IFwiMC4zXCJcbmBgYFxuXG5EZXYtZGVwZW5kZW5jaWVzIGFyZSBub3QgdXNlZCB3aGVuIGNvbXBpbGluZ1xuYSBwYWNrYWdlIGZvciBidWlsZGluZywgYnV0IGFyZSB1c2VkIGZvciBjb21waWxpbmcgdGVzdHMsIGV4YW1wbGVzLCBhbmRcbmJlbmNobWFya3MuXG5cblRoZXNlIGRlcGVuZGVuY2llcyBhcmUgKm5vdCogcHJvcGFnYXRlZCB0byBvdGhlciBwYWNrYWdlcyB3aGljaCBkZXBlbmQgb24gdGhpc1xucGFja2FnZS5cblxuWW91IGNhbiBhbHNvIGhhdmUgdGFyZ2V0LXNwZWNpZmljIGRldmVsb3BtZW50IGRlcGVuZGVuY2llcyBieSB1c2luZ1xuYGRldi1kZXBlbmRlbmNpZXNgIGluIHRoZSB0YXJnZXQgc2VjdGlvbiBoZWFkZXIgaW5zdGVhZCBvZiBgZGVwZW5kZW5jaWVzYC4gRm9yXG5leGFtcGxlOlxuXG5gYGB0b21sXG5bdGFyZ2V0LidjZmcodW5peCknLmRldi1kZXBlbmRlbmNpZXNdXG5taW8gPSBcIjAuMC4xXCJcbmBgYFxuXG4\u002BICoqTm90ZSoqOiBXaGVuIGEgcGFja2FnZSBpcyBwdWJsaXNoZWQsIG9ubHkgZGV2LWRlcGVuZGVuY2llcyB0aGF0IHNwZWNpZnkgYVxuPiBgdmVyc2lvbmAgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcHVibGlzaGVkIGNyYXRlLiBGb3IgbW9zdCB1c2UgY2FzZXMsXG4\u002BIGRldi1kZXBlbmRlbmNpZXMgYXJlIG5vdCBuZWVkZWQgd2hlbiBwdWJsaXNoZWQsIHRob3VnaCBzb21lIHVzZXJzIChsaWtlIE9TXG4\u002BIHBhY2thZ2VycykgbWF5IHdhbnQgdG8gcnVuIHRlc3RzIHdpdGhpbiBhIGNyYXRlLCBzbyBwcm92aWRpbmcgYSBgdmVyc2lvbmAgaWZcbj4gcG9zc2libGUgY2FuIHN0aWxsIGJlIGJlbmVmaWNpYWwuXG4iLAogICAgICAgICAgInR5cGUiOiAib2JqZWN0IiwKICAgICAgICAgICJhZGRpdGlvbmFsUHJvcGVydGllcyI6IHsKICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9EZXBlbmRlbmN5IgogICAgICAgICAgfSwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9zcGVjaWZ5aW5nLWRlcGVuZGVuY2llcy5odG1sI2RldmVsb3BtZW50LWRlcGVuZGVuY2llcyIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgInBsdWdpbnMiOiBbImNyYXRlcyJdLAogICAgICAgICAgICAiY3JhdGVzIjogewogICAgICAgICAgICAgICJzY2hlbWFzIjogImRlcGVuZGVuY2llcyIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgImRldl9kZXBlbmRlbmNpZXMiOiB7CiAgICAgICAgICAidHlwZSI6ICJvYmplY3QiLAogICAgICAgICAgImFkZGl0aW9uYWxQcm9wZXJ0aWVzIjogewogICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL0RlcGVuZGVuY3kiCiAgICAgICAgICB9LAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJoaWRkZW4iOiB0cnVlCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgIkJ1aWxkT3ZlcnJpZGUiOiB7CiAgICAgICJ0aXRsZSI6ICJCdWlsZCBPdmVycmlkZSIsCiAgICAgICJ0eXBlIjogIm9iamVjdCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJQcm9maWxlIHNldHRpbmdzIGNhbiBiZSBvdmVycmlkZGVuIGZvciBzcGVjaWZpYyBwYWNrYWdlcyBhbmQgYnVpbGQtdGltZVxuY3JhdGVzLiBUbyBvdmVycmlkZSB0aGUgc2V0dGluZ3MgZm9yIGEgc3BlY2lmaWMgcGFja2FnZSwgdXNlIHRoZSBgcGFja2FnZWBcbnRhYmxlIHRvIGNoYW5nZSB0aGUgc2V0dGluZ3MgZm9yIHRoZSBuYW1lZCBwYWNrYWdlOlxuXG5gYGB0b21sXG4jIFRoZSBgZm9vYCBwYWNrYWdlIHdpbGwgdXNlIHRoZSAtQ29wdC1sZXZlbD0zIGZsYWcuXG5bcHJvZmlsZS5kZXYucGFja2FnZS5mb29dXG5vcHQtbGV2ZWwgPSAzXG5gYGBcblxuVGhlIHBhY2thZ2UgbmFtZSBpcyBhY3R1YWxseSBhIFtQYWNrYWdlIElEIFNwZWNdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3BrZ2lkLXNwZWMuaHRtbCksIHNvIHlvdSBjYW5cbnRhcmdldCBpbmRpdmlkdWFsIHZlcnNpb25zIG9mIGEgcGFja2FnZSB3aXRoIHN5bnRheCBzdWNoIGFzXG5gW3Byb2ZpbGUuZGV2LnBhY2thZ2UuXCJmb286Mi4xLjBcIl1gLlxuXG5UbyBvdmVycmlkZSB0aGUgc2V0dGluZ3MgZm9yIGFsbCBkZXBlbmRlbmNpZXMgKGJ1dCBub3QgYW55IHdvcmtzcGFjZSBtZW1iZXIpLFxudXNlIHRoZSBgXCIqXCJgIHBhY2thZ2UgbmFtZTpcblxuYGBgdG9tbFxuIyBTZXQgdGhlIGRlZmF1bHQgZm9yIGRlcGVuZGVuY2llcy5cbltwcm9maWxlLmRldi5wYWNrYWdlLlwiKlwiXVxub3B0LWxldmVsID0gMlxuYGBgXG5cblRvIG92ZXJyaWRlIHRoZSBzZXR0aW5ncyBmb3IgYnVpbGQgc2NyaXB0cywgcHJvYyBtYWNyb3MsIGFuZCB0aGVpclxuZGVwZW5kZW5jaWVzLCB1c2UgdGhlIGBidWlsZC1vdmVycmlkZWAgdGFibGU6XG5cbmBgYHRvbWxcbiMgU2V0IHRoZSBzZXR0aW5ncyBmb3IgYnVpbGQgc2NyaXB0cyBhbmQgcHJvYy1tYWNyb3MuXG5bcHJvZmlsZS5kZXYuYnVpbGQtb3ZlcnJpZGVdXG5vcHQtbGV2ZWwgPSAzXG5gYGBcblxuPiBOb3RlOiBXaGVuIGEgZGVwZW5kZW5jeSBpcyBib3RoIGEgbm9ybWFsIGRlcGVuZGVuY3kgYW5kIGEgYnVpbGQgZGVwZW5kZW5jeSxcbj4gQ2FyZ28gd2lsbCB0cnkgdG8gb25seSBidWlsZCBpdCBvbmNlIHdoZW4gYC0tdGFyZ2V0YCBpcyBub3Qgc3BlY2lmaWVkLiBXaGVuXG4\u002BIHVzaW5nIGBidWlsZC1vdmVycmlkZWAsIHRoZSBkZXBlbmRlbmN5IG1heSBuZWVkIHRvIGJlIGJ1aWx0IHR3aWNlLCBvbmNlIGFzIGFcbj4gbm9ybWFsIGRlcGVuZGVuY3kgYW5kIG9uY2Ugd2l0aCB0aGUgb3ZlcnJpZGRlbiBidWlsZCBzZXR0aW5ncy4gVGhpcyBtYXlcbj4gaW5jcmVhc2UgaW5pdGlhbCBidWlsZCB0aW1lcy5cbiIsCiAgICAgICJhbGxPZiI6IFsKICAgICAgICB7CiAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1Byb2ZpbGUiCiAgICAgICAgfQogICAgICBdLAogICAgICAieC10YXBsbyI6IHsKICAgICAgICAiZG9jcyI6IHsKICAgICAgICAgICJtYWluIjogIlByb2ZpbGUgc2V0dGluZ3MgY2FuIGJlIG92ZXJyaWRkZW4gZm9yIHNwZWNpZmljIHBhY2thZ2VzIGFuZCBidWlsZC10aW1lXG5jcmF0ZXMuIFRvIG92ZXJyaWRlIHRoZSBzZXR0aW5ncyBmb3IgYSBzcGVjaWZpYyBwYWNrYWdlLCB1c2UgdGhlIGBwYWNrYWdlYFxudGFibGUgdG8gY2hhbmdlIHRoZSBzZXR0aW5ncyBmb3IgdGhlIG5hbWVkIHBhY2thZ2U6XG5cbmBgYHRvbWxcbiMgVGhlIGBmb29gIHBhY2thZ2Ugd2lsbCB1c2UgdGhlIC1Db3B0LWxldmVsPTMgZmxhZy5cbltwcm9maWxlLmRldi5wYWNrYWdlLmZvb11cbm9wdC1sZXZlbCA9IDNcbmBgYFxuXG5UaGUgcGFja2FnZSBuYW1lIGlzIGFjdHVhbGx5IGEgW1BhY2thZ2UgSUQgU3BlY10oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvcGtnaWQtc3BlYy5odG1sKSwgc28geW91IGNhblxudGFyZ2V0IGluZGl2aWR1YWwgdmVyc2lvbnMgb2YgYSBwYWNrYWdlIHdpdGggc3ludGF4IHN1Y2ggYXNcbmBbcHJvZmlsZS5kZXYucGFja2FnZS5cImZvbzoyLjEuMFwiXWAuXG5cblRvIG92ZXJyaWRlIHRoZSBzZXR0aW5ncyBmb3IgYWxsIGRlcGVuZGVuY2llcyAoYnV0IG5vdCBhbnkgd29ya3NwYWNlIG1lbWJlciksXG51c2UgdGhlIGBcIipcImAgcGFja2FnZSBuYW1lOlxuXG5gYGB0b21sXG4jIFNldCB0aGUgZGVmYXVsdCBmb3IgZGVwZW5kZW5jaWVzLlxuW3Byb2ZpbGUuZGV2LnBhY2thZ2UuXCIqXCJdXG5vcHQtbGV2ZWwgPSAyXG5gYGBcblxuVG8gb3ZlcnJpZGUgdGhlIHNldHRpbmdzIGZvciBidWlsZCBzY3JpcHRzLCBwcm9jIG1hY3JvcywgYW5kIHRoZWlyXG5kZXBlbmRlbmNpZXMsIHVzZSB0aGUgYGJ1aWxkLW92ZXJyaWRlYCB0YWJsZTpcblxuYGBgdG9tbFxuIyBTZXQgdGhlIHNldHRpbmdzIGZvciBidWlsZCBzY3JpcHRzIGFuZCBwcm9jLW1hY3Jvcy5cbltwcm9maWxlLmRldi5idWlsZC1vdmVycmlkZV1cbm9wdC1sZXZlbCA9IDNcbmBgYFxuXG4\u002BIE5vdGU6IFdoZW4gYSBkZXBlbmRlbmN5IGlzIGJvdGggYSBub3JtYWwgZGVwZW5kZW5jeSBhbmQgYSBidWlsZCBkZXBlbmRlbmN5LFxuPiBDYXJnbyB3aWxsIHRyeSB0byBvbmx5IGJ1aWxkIGl0IG9uY2Ugd2hlbiBgLS10YXJnZXRgIGlzIG5vdCBzcGVjaWZpZWQuIFdoZW5cbj4gdXNpbmcgYGJ1aWxkLW92ZXJyaWRlYCwgdGhlIGRlcGVuZGVuY3kgbWF5IG5lZWQgdG8gYmUgYnVpbHQgdHdpY2UsIG9uY2UgYXMgYVxuPiBub3JtYWwgZGVwZW5kZW5jeSBhbmQgb25jZSB3aXRoIHRoZSBvdmVycmlkZGVuIGJ1aWxkIHNldHRpbmdzLiBUaGlzIG1heVxuPiBpbmNyZWFzZSBpbml0aWFsIGJ1aWxkIHRpbWVzLlxuIgogICAgICAgIH0sCiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9wcm9maWxlcy5odG1sI292ZXJyaWRlcyIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAiUHJvZmlsZVdpdGhCdWlsZE92ZXJyaWRlIjogewogICAgICAiYWxsT2YiOiBbCiAgICAgICAgewogICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9Qcm9maWxlIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgInR5cGUiOiAib2JqZWN0IiwKICAgICAgICAgICJwcm9wZXJ0aWVzIjogewogICAgICAgICAgICAiYnVpbGQtb3ZlcnJpZGUiOiB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9Qcm9maWxlIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICBdCiAgICB9LAogICAgIlByb2ZpbGUiOiB7CiAgICAgICJ0aXRsZSI6ICJQcm9maWxlIiwKICAgICAgInR5cGUiOiAib2JqZWN0IiwKICAgICAgInByb3BlcnRpZXMiOiB7CiAgICAgICAgImNvZGVnZW4tdW5pdHMiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGBjb2RlZ2VuLXVuaXRzYCBzZXR0aW5nIGNvbnRyb2xzIHRoZSBbYC1DIGNvZGVnZW4tdW5pdHNgIGZsYWddKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvcnVzdGMvY29kZWdlbi1vcHRpb25zL2luZGV4Lmh0bWwjY29kZWdlbi11bml0cykgd2hpY2hcbmNvbnRyb2xzIGhvdyBtYW55IFwiY29kZSBnZW5lcmF0aW9uIHVuaXRzXCIgYSBjcmF0ZSB3aWxsIGJlIHNwbGl0IGludG8uIE1vcmVcbmNvZGUgZ2VuZXJhdGlvbiB1bml0cyBhbGxvd3MgbW9yZSBvZiBhIGNyYXRlIHRvIGJlIHByb2Nlc3NlZCBpbiBwYXJhbGxlbFxucG9zc2libHkgcmVkdWNpbmcgY29tcGlsZSB0aW1lLCBidXQgbWF5IHByb2R1Y2Ugc2xvd2VyIGNvZGUuXG5cblRoaXMgb3B0aW9uIHRha2VzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIDAuXG5cblRoZSBkZWZhdWx0IGlzIDI1NiBmb3IgW2luY3JlbWVudGFsXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9wcm9maWxlcy5odG1sI2luY3JlbWVudGFsKSBidWlsZHMsIGFuZCAxNiBmb3Jcbm5vbi1pbmNyZW1lbnRhbCBidWlsZHMuIiwKICAgICAgICAgICJ0eXBlIjogImludGVnZXIiLAogICAgICAgICAgImZvcm1hdCI6ICJ1aW50MzIiLAogICAgICAgICAgIm1pbmltdW0iOiAwLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3Byb2ZpbGVzLmh0bWwjY29kZWdlbi11bml0cyIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgImRlYnVnIjogewogICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9EZWJ1Z0xldmVsIgogICAgICAgIH0sCiAgICAgICAgImRlYnVnLWFzc2VydGlvbnMiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGBkZWJ1Zy1hc3NlcnRpb25zYCBzZXR0aW5nIGNvbnRyb2xzIHRoZSBbYC1DIGRlYnVnLWFzc2VydGlvbnNgIGZsYWddKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvcnVzdGMvY29kZWdlbi1vcHRpb25zL2luZGV4Lmh0bWwjZGVidWctYXNzZXJ0aW9ucykgd2hpY2hcbnR1cm5zIGBjZmcoZGVidWdfYXNzZXJ0aW9ucylgIFtjb25kaXRpb25hbCBjb21waWxhdGlvbl0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9yZWZlcmVuY2UvY29uZGl0aW9uYWwtY29tcGlsYXRpb24uaHRtbCNkZWJ1Z19hc3NlcnRpb25zKSBvbiBvciBvZmYuIERlYnVnXG5hc3NlcnRpb25zIGFyZSBpbnRlbmRlZCB0byBpbmNsdWRlIHJ1bnRpbWUgdmFsaWRhdGlvbiB3aGljaCBpcyBvbmx5IGF2YWlsYWJsZVxuaW4gZGVidWcvZGV2ZWxvcG1lbnQgYnVpbGRzLiBUaGVzZSBtYXkgYmUgdGhpbmdzIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgb3Jcbm90aGVyd2lzZSB1bmRlc2lyYWJsZSBpbiBhIHJlbGVhc2UgYnVpbGQuIERlYnVnIGFzc2VydGlvbnMgZW5hYmxlcyB0aGVcbltgZGVidWdfYXNzZXJ0IWAgbWFjcm9dKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvc3RkL21hY3JvLmRlYnVnX2Fzc2VydC5odG1sKSBpbiB0aGUgc3RhbmRhcmQgbGlicmFyeS4iLAogICAgICAgICAgInR5cGUiOiAiYm9vbGVhbiIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvcHJvZmlsZXMuaHRtbCNkZWJ1Zy1hc3NlcnRpb25zIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiZGlyLW5hbWUiOiB7CiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJoaWRkZW4iOiB0cnVlCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiaW5jcmVtZW50YWwiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGBpbmNyZW1lbnRhbGAgc2V0dGluZyBjb250cm9scyB0aGUgW2AtQyBpbmNyZW1lbnRhbGAgZmxhZ10oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9ydXN0Yy9jb2RlZ2VuLW9wdGlvbnMvaW5kZXguaHRtbCNpbmNyZW1lbnRhbCkgd2hpY2ggY29udHJvbHNcbndoZXRoZXIgb3Igbm90IGluY3JlbWVudGFsIGNvbXBpbGF0aW9uIGlzIGVuYWJsZWQuIEluY3JlbWVudGFsIGNvbXBpbGF0aW9uXG5jYXVzZXMgYHJ1c3RjYCB0byB0byBzYXZlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gZGlzayB3aGljaCB3aWxsIGJlIHJldXNlZFxud2hlbiByZWNvbXBpbGluZyB0aGUgY3JhdGUsIGltcHJvdmluZyByZS1jb21waWxlIHRpbWVzLiBUaGUgYWRkaXRpb25hbFxuaW5mb3JtYXRpb24gaXMgc3RvcmVkIGluIHRoZSBgdGFyZ2V0YCBkaXJlY3RvcnkuXG5cblRoZSB2YWxpZCBvcHRpb25zIGFyZTpcblxuKiBgdHJ1ZWA6IGVuYWJsZWRcbiogYGZhbHNlYDogZGlzYWJsZWRcblxuSW5jcmVtZW50YWwgY29tcGlsYXRpb24gaXMgb25seSB1c2VkIGZvciB3b3Jrc3BhY2UgbWVtYmVycyBhbmQgXCJwYXRoXCJcbmRlcGVuZGVuY2llcy5cblxuVGhlIGluY3JlbWVudGFsIHZhbHVlIGNhbiBiZSBvdmVycmlkZGVuIGdsb2JhbGx5IHdpdGggdGhlIGBDQVJHT19JTkNSRU1FTlRBTGBcbltlbnZpcm9ubWVudCB2YXJpYWJsZV0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvZW52aXJvbm1lbnQtdmFyaWFibGVzLmh0bWwpIG9yIHRoZSBbYGJ1aWxkLmluY3JlbWVudGFsYF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY29uZmlnLmh0bWwjYnVpbGRpbmNyZW1lbnRhbCkgY29uZmlnIHZhcmlhYmxlLiIsCiAgICAgICAgICAidHlwZSI6ICJib29sZWFuIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9wcm9maWxlcy5odG1sI2luY3JlbWVudGFsIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiaW5oZXJpdHMiOiB7CiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJoaWRkZW4iOiB0cnVlCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAibHRvIjogewogICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9MdG8iCiAgICAgICAgfSwKICAgICAgICAib3B0LWxldmVsIjogewogICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9PcHRMZXZlbCIKICAgICAgICB9LAogICAgICAgICJvdmVyZmxvdy1jaGVja3MiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGBvdmVyZmxvdy1jaGVja3NgIHNldHRpbmcgY29udHJvbHMgdGhlIFtgLUMgb3ZlcmZsb3ctY2hlY2tzYCBmbGFnXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL3J1c3RjL2NvZGVnZW4tb3B0aW9ucy9pbmRleC5odG1sI292ZXJmbG93LWNoZWNrcykgd2hpY2hcbmNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBbcnVudGltZSBpbnRlZ2VyIG92ZXJmbG93XShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL3JlZmVyZW5jZS9leHByZXNzaW9ucy9vcGVyYXRvci1leHByLmh0bWwjb3ZlcmZsb3cpLiBXaGVuIG92ZXJmbG93LWNoZWNrcyBhcmVcbmVuYWJsZWQsIGEgcGFuaWMgd2lsbCBvY2N1ciBvbiBvdmVyZmxvdy4iLAogICAgICAgICAgInR5cGUiOiAiYm9vbGVhbiIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvcHJvZmlsZXMuaHRtbCNvdmVyZmxvdy1jaGVja3MiCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICJwYWNrYWdlIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlBhY2thZ2Utc3BlY2lmaWMgb3ZlcnJpZGVzLlxuXG5UaGUgcGFja2FnZSBuYW1lIGlzIGEgW1BhY2thZ2UgSUQgU3BlY10oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvcGtnaWQtc3BlYy5odG1sKSwgc28geW91IGNhblxudGFyZ2V0IGluZGl2aWR1YWwgdmVyc2lvbnMgb2YgYSBwYWNrYWdlIHdpdGggc3ludGF4IHN1Y2ggYXMgYFtwcm9maWxlLmRldi5wYWNrYWdlLlwiZm9vOjIuMS4wXCJdYC4iLAogICAgICAgICAgInR5cGUiOiAib2JqZWN0IiwKICAgICAgICAgICJhZGRpdGlvbmFsUHJvcGVydGllcyI6IHsKICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9Qcm9maWxlIgogICAgICAgICAgfSwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9wcm9maWxlcy5odG1sI292ZXJyaWRlcyIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgInBhbmljIjogewogICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9QYW5pYyIKICAgICAgICB9LAogICAgICAgICJycGF0aCI6IHsKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYHJwYXRoYCBzZXR0aW5nIGNvbnRyb2xzIHRoZSBbYC1DIHJwYXRoYCBmbGFnXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL3J1c3RjL2NvZGVnZW4tb3B0aW9ucy9pbmRleC5odG1sI3JwYXRoKSB3aGljaCBjb250cm9sc1xud2hldGhlciBvciBub3QgW2BycGF0aGBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JwYXRoKSBpcyBlbmFibGVkLiIsCiAgICAgICAgICAidHlwZSI6ICJib29sZWFuIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9wcm9maWxlcy5odG1sI3JwYXRoIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgIlByb2ZpbGVzIjogewogICAgICAidGl0bGUiOiAiUHJvZmlsZXMiLAogICAgICAiZGVzY3JpcHRpb24iOiAiUHJvZmlsZXMgcHJvdmlkZSBhIHdheSB0byBhbHRlciB0aGUgY29tcGlsZXIgc2V0dGluZ3MsIGluZmx1ZW5jaW5nIHRoaW5ncyBsaWtlIG9wdGltaXphdGlvbnMgYW5kIGRlYnVnZ2luZyBzeW1ib2xzLlxuXG5DYXJnbyBoYXMgNCBidWlsdC1pbiBwcm9maWxlczogZGV2LCByZWxlYXNlLCB0ZXN0LCBhbmQgYmVuY2guIEl0IGF1dG9tYXRpY2FsbHkgY2hvb3NlcyB0aGUgcHJvZmlsZSBiYXNlZCBvbiB3aGljaCBjb21tYW5kIGlzIGJlaW5nIHJ1biwgdGhlIHBhY2thZ2UgYW5kIHRhcmdldCB0aGF0IGlzIGJlaW5nIGJ1aWx0LCBhbmQgY29tbWFuZC1saW5lIGZsYWdzIGxpa2UgLS1yZWxlYXNlLiIsCiAgICAgICJ0eXBlIjogIm9iamVjdCIsCiAgICAgICJwcm9wZXJ0aWVzIjogewogICAgICAgICJiZW5jaCI6IHsKICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvUHJvZmlsZVdpdGhCdWlsZE92ZXJyaWRlIgogICAgICAgIH0sCiAgICAgICAgImRldiI6IHsKICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvUHJvZmlsZVdpdGhCdWlsZE92ZXJyaWRlIgogICAgICAgIH0sCiAgICAgICAgInJlbGVhc2UiOiB7CiAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1Byb2ZpbGVXaXRoQnVpbGRPdmVycmlkZSIKICAgICAgICB9LAogICAgICAgICJ0ZXN0IjogewogICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9Qcm9maWxlV2l0aEJ1aWxkT3ZlcnJpZGUiCiAgICAgICAgfQogICAgICB9LAogICAgICAiYWRkaXRpb25hbFByb3BlcnRpZXMiOiB7CiAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9Qcm9maWxlV2l0aEJ1aWxkT3ZlcnJpZGUiCiAgICAgIH0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvcHJvZmlsZXMuaHRtbCIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAiUHVibGlzaCI6IHsKICAgICAgInRpdGxlIjogIlB1Ymxpc2giLAogICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGBwdWJsaXNoYCBmaWVsZCBjYW4gYmUgdXNlZCB0byBwcmV2ZW50IGEgcGFja2FnZSBmcm9tIGJlaW5nIHB1Ymxpc2hlZCB0byBhIHBhY2thZ2UgcmVnaXN0cnkgKGxpa2UgKmNyYXRlcy5pbyopIGJ5IG1pc3Rha2UsIGZvciBpbnN0YW5jZSB0byBrZWVwIGEgcGFja2FnZVxucHJpdmF0ZSBpbiBhIGNvbXBhbnkuXG5cbmBgYHRvbWxcbltwYWNrYWdlXVxuIyAuLi5cbnB1Ymxpc2ggPSBmYWxzZVxuYGBgXG5cblRoZSB2YWx1ZSBtYXkgYWxzbyBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSByZWdpc3RyeSBuYW1lcyB0aGF0IGFyZVxuYWxsb3dlZCB0byBiZSBwdWJsaXNoZWQgdG8uXG5cbmBgYHRvbWxcbltwYWNrYWdlXVxuIyAuLi5cbnB1Ymxpc2ggPSBbXCJzb21lLXJlZ2lzdHJ5LW5hbWVcIl1cbmBgYCIsCiAgICAgICJhbnlPZiI6IFsKICAgICAgICB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGFja2FnZSBjYW4gYmUgcHVibGlzaGVkLiIsCiAgICAgICAgICAidHlwZSI6ICJib29sZWFuIiwKICAgICAgICAgICJlbnVtIjogW3RydWUsIGZhbHNlXSwKICAgICAgICAgICJkZWZhdWx0IjogdHJ1ZSwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAiZG9jcyI6IHsKICAgICAgICAgICAgICAiZW51bVZhbHVlcyI6IFsKICAgICAgICAgICAgICAgICJUaGUgcGFja2FnZSBjYW4gYmUgcHVibGlzaGVkLiIsCiAgICAgICAgICAgICAgICAiVGhlIHBhY2thZ2UgY2Fubm90IGJlIHB1Ymxpc2hlZC4iCiAgICAgICAgICAgICAgXQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAidHlwZSI6ICJhcnJheSIsCiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiQW4gYXJyYXkgb2YgcmVnaXN0cnkgbmFtZXMuIiwKICAgICAgICAgICJpdGVtcyI6IHsKICAgICAgICAgICAgInR5cGUiOiAic3RyaW5nIgogICAgICAgICAgfQogICAgICAgIH0KICAgICAgXSwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9tYW5pZmVzdC5odG1sI3RoZS1wdWJsaXNoLWZpZWxkIgogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJSZWFkbWUiOiB7CiAgICAgICJ0aXRsZSI6ICJSZWFkbWUiLAogICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGByZWFkbWVgIGZpZWxkIHNob3VsZCBiZSB0aGUgcGF0aCB0byBhIGZpbGUgaW4gdGhlIHBhY2thZ2Ugcm9vdCAocmVsYXRpdmVcbnRvIHRoaXMgYENhcmdvLnRvbWxgKSB0aGF0IGNvbnRhaW5zIGdlbmVyYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHBhY2thZ2UuXG5UaGlzIGZpbGUgd2lsbCBiZSB0cmFuc2ZlcnJlZCB0byB0aGUgcmVnaXN0cnkgd2hlbiB5b3UgcHVibGlzaC4gW2NyYXRlcy5pb10oaHR0cHM6Ly9jcmF0ZXMuaW8pXG53aWxsIGludGVycHJldCBpdCBhcyBNYXJrZG93biBhbmQgcmVuZGVyIGl0IG9uIHRoZSBjcmF0ZSdzIHBhZ2UuXG5cbmBgYHRvbWxcbltwYWNrYWdlXVxuIyAuLi5cbnJlYWRtZSA9IFwiUkVBRE1FLm1kXCJcbmBgYFxuXG5JZiBubyB2YWx1ZSBpcyBzcGVjaWZpZWQgZm9yIHRoaXMgZmllbGQsIGFuZCBhIGZpbGUgbmFtZWQgYFJFQURNRS5tZGAsXG5gUkVBRE1FLnR4dGAgb3IgYFJFQURNRWAgZXhpc3RzIGluIHRoZSBwYWNrYWdlIHJvb3QsIHRoZW4gdGhlIG5hbWUgb2YgdGhhdFxuZmlsZSB3aWxsIGJlIHVzZWQuIFlvdSBjYW4gc3VwcHJlc3MgdGhpcyBiZWhhdmlvciBieSBzZXR0aW5nIHRoaXMgZmllbGQgdG9cbmBmYWxzZWAuIElmIHRoZSBmaWVsZCBpcyBzZXQgdG8gYHRydWVgLCBhIGRlZmF1bHQgdmFsdWUgb2YgYFJFQURNRS5tZGAgd2lsbFxuYmUgYXNzdW1lZC5cbiIsCiAgICAgICJhbnlPZiI6IFsKICAgICAgICB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGByZWFkbWVgIGZpZWxkIHNob3VsZCBiZSB0aGUgcGF0aCB0byBhIGZpbGUgaW4gdGhlIHBhY2thZ2Ugcm9vdCAocmVsYXRpdmVcbnRvIHRoaXMgYENhcmdvLnRvbWxgKSB0aGF0IGNvbnRhaW5zIGdlbmVyYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHBhY2thZ2UuIiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJ0eXBlIjogImJvb2xlYW4iLAogICAgICAgICAgImVudW0iOiBbdHJ1ZSwgZmFsc2VdLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJkb2NzIjogewogICAgICAgICAgICAgICJlbnVtVmFsdWVzIjogWwogICAgICAgICAgICAgICAgIlVzZSB0aGUgYFJFQURNRS5tZGAgZmlsZS4iLAogICAgICAgICAgICAgICAgIkRvIG5vdCB1c2UgdGhlIGRlZmF1bHQgYFJFQURNRS5tZGAgZmlsZSIKICAgICAgICAgICAgICBdCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIF0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvbWFuaWZlc3QuaHRtbCN0aGUtcmVhZG1lLWZpZWxkIgogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJTZW1WZXIiOiB7CiAgICAgICJ0aXRsZSI6ICJTZW1hbnRpYyBWZXJzaW9uIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkNhcmdvIGJha2VzIGluIHRoZSBjb25jZXB0IG9mIFtTZW1hbnRpYyBWZXJzaW9uaW5nXShodHRwczovL3NlbXZlci5vcmcvKSwgc28gbWFrZSBzdXJlIHlvdSBmb2xsb3cgc29tZSBiYXNpYyBydWxlczpcblxuKiBCZWZvcmUgeW91IHJlYWNoIDEuMC4wLCBhbnl0aGluZyBnb2VzLCBidXQgaWYgeW91IG1ha2UgYnJlYWtpbmcgY2hhbmdlcyxcbiAgICBpbmNyZW1lbnQgdGhlIG1pbm9yIHZlcnNpb24uIEluIFJ1c3QsIGJyZWFraW5nIGNoYW5nZXMgaW5jbHVkZSBhZGRpbmcgZmllbGRzIHRvXG4gICAgc3RydWN0cyBvciB2YXJpYW50cyB0byBlbnVtcy5cbiogQWZ0ZXIgMS4wLjAsIG9ubHkgbWFrZSBicmVha2luZyBjaGFuZ2VzIHdoZW4geW91IGluY3JlbWVudCB0aGUgbWFqb3IgdmVyc2lvbi5cbiAgICBEb24ndCBicmVhayB0aGUgYnVpbGQuXG4qIEFmdGVyIDEuMC4wLCBkb24ndCBhZGQgYW55IG5ldyBwdWJsaWMgQVBJIChubyBuZXcgYHB1YmAgYW55dGhpbmcpIGluIHBhdGNoLWxldmVsXG4gICAgdmVyc2lvbnMuIEFsd2F5cyBpbmNyZW1lbnQgdGhlIG1pbm9yIHZlcnNpb24gaWYgeW91IGFkZCBhbnkgbmV3IGBwdWJgIHN0cnVjdHMsXG4gICAgdHJhaXRzLCBmaWVsZHMsIHR5cGVzLCBmdW5jdGlvbnMsIG1ldGhvZHMgb3IgYW55dGhpbmcgZWxzZS5cbiogVXNlIHZlcnNpb24gbnVtYmVycyB3aXRoIHRocmVlIG51bWVyaWMgcGFydHMgc3VjaCBhcyAxLjAuMCByYXRoZXIgdGhhbiAxLjAuIiwKICAgICAgImRlZmF1bHQiOiAiMC4xLjAiLAogICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAiZm9ybWF0IjogInNlbXZlciIsCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvbWFuaWZlc3QuaHRtbCN0aGUtdmVyc2lvbi1maWVsZCIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAiU2VtVmVyUmVxdWlyZW1lbnQiOiB7CiAgICAgICJ0aXRsZSI6ICJTZW1hbnRpYyBWZXJzaW9uIFJlcXVpcmVtZW50IiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBbdmVyc2lvbiByZXF1aXJlbWVudF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMuaHRtbCkgb2YgdGhlIHRhcmdldCBkZXBlbmRlbmN5LiIsCiAgICAgICJkZWZhdWx0IjogIioiLAogICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAiZm9ybWF0IjogInNlbXZlci1yZXF1aXJlbWVudCIsCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMuaHRtbCIKICAgICAgICB9LAogICAgICAgICJwbHVnaW5zIjogWyJjcmF0ZXMiXSwKICAgICAgICAiY3JhdGVzIjogewogICAgICAgICAgInNjaGVtYXMiOiAidmVyc2lvbiIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAiVGFyZ2V0IjogewogICAgICAidGl0bGUiOiAiVGFyZ2V0IiwKICAgICAgInR5cGUiOiAib2JqZWN0IiwKICAgICAgInByb3BlcnRpZXMiOiB7CiAgICAgICAgImJlbmNoIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgYmVuY2hgIGZpZWxkIGluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgdGFyZ2V0IGlzIGJlbmNobWFya2VkIGJ5XG5kZWZhdWx0IGJ5IFtgY2FyZ28gYmVuY2hgXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2NvbW1hbmRzL2NhcmdvLWJlbmNoLmh0bWwpLiBUaGUgZGVmYXVsdCBpcyBgdHJ1ZWAgZm9yIGxpYiwgYmlucywgYW5kXG5iZW5jaG1hcmtzLiIsCiAgICAgICAgICAidHlwZSI6ICJib29sZWFuIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9jYXJnby10YXJnZXRzLmh0bWwjdGhlLWJlbmNoLWZpZWxkIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiY3JhdGUtdHlwZSI6IHsKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYGNyYXRlLXR5cGVgIGZpZWxkIGRlZmluZXMgdGhlIFtjcmF0ZSB0eXBlc10oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9yZWZlcmVuY2UvbGlua2FnZS5odG1sKSB0aGF0IHdpbGwgYmUgZ2VuZXJhdGVkIGJ5IHRoZVxudGFyZ2V0LiBJdCBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLCBhbGxvd2luZyB5b3UgdG8gc3BlY2lmeSBtdWx0aXBsZSBjcmF0ZVxudHlwZXMgZm9yIGEgc2luZ2xlIHRhcmdldC4gVGhpcyBjYW4gb25seSBiZSBzcGVjaWZpZWQgZm9yIGxpYnJhcmllcyBhbmRcbmV4YW1wbGVzLiBCaW5hcmllcywgdGVzdHMsIGFuZCBiZW5jaG1hcmtzIGFyZSBhbHdheXMgdGhlIFwiYmluXCIgY3JhdGUgdHlwZS5cblxuVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZSBgYmluYCwgYGxpYmAsIGBybGliYCwgYGR5bGliYCwgYGNkeWxpYmAsXG5gc3RhdGljbGliYCwgYW5kIGBwcm9jLW1hY3JvYC4gWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgdGhlIGRpZmZlcmVudCBjcmF0ZVxudHlwZXMgaW4gdGhlIFtSdXN0IFJlZmVyZW5jZSBNYW51YWxdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvcmVmZXJlbmNlL2xpbmthZ2UuaHRtbCkuIiwKICAgICAgICAgICJ0eXBlIjogImFycmF5IiwKICAgICAgICAgICJpdGVtcyI6IHsKICAgICAgICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgY3JhdGUtdHlwZWAgZmllbGQgZGVmaW5lcyB0aGUgW2NyYXRlIHR5cGVzXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL3JlZmVyZW5jZS9saW5rYWdlLmh0bWwpIHRoYXQgd2lsbCBiZSBnZW5lcmF0ZWQgYnkgdGhlXG50YXJnZXQuIEl0IGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIGFsbG93aW5nIHlvdSB0byBzcGVjaWZ5IG11bHRpcGxlIGNyYXRlXG50eXBlcyBmb3IgYSBzaW5nbGUgdGFyZ2V0LiBUaGlzIGNhbiBvbmx5IGJlIHNwZWNpZmllZCBmb3IgbGlicmFyaWVzIGFuZFxuZXhhbXBsZXMuIEJpbmFyaWVzLCB0ZXN0cywgYW5kIGJlbmNobWFya3MgYXJlIGFsd2F5cyB0aGUgXCJiaW5cIiBjcmF0ZSB0eXBlLlxuXG5UaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlIGBiaW5gLCBgbGliYCwgYHJsaWJgLCBgZHlsaWJgLCBgY2R5bGliYCxcbmBzdGF0aWNsaWJgLCBhbmQgYHByb2MtbWFjcm9gLiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCB0aGUgZGlmZmVyZW50IGNyYXRlXG50eXBlcyBpbiB0aGUgW1J1c3QgUmVmZXJlbmNlIE1hbnVhbF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9yZWZlcmVuY2UvbGlua2FnZS5odG1sKS4iLAogICAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgICAiZG9jcyI6IHsKICAgICAgICAgICAgICAgICJlbnVtVmFsdWVzIjogWwogICAgICAgICAgICAgICAgICAiQSBydW5uYWJsZSBleGVjdXRhYmxlIHdpbGwgYmUgcHJvZHVjZWQuIFRoaXMgcmVxdWlyZXMgdGhhdCB0aGVyZSBpcyBhIGBtYWluYCBmdW5jdGlvbiBpbiB0aGUgY3JhdGUgd2hpY2hcbndpbGwgYmUgcnVuIHdoZW4gdGhlIHByb2dyYW0gYmVnaW5zIGV4ZWN1dGluZy4gVGhpcyB3aWxsIGxpbmsgaW4gYWxsIFJ1c3QgYW5kXG5uYXRpdmUgZGVwZW5kZW5jaWVzLCBwcm9kdWNpbmcgYSBkaXN0cmlidXRhYmxlIGJpbmFyeS4iLAogICAgICAgICAgICAgICAgICAiQSBSdXN0IGxpYnJhcnkgd2lsbCBiZSBwcm9kdWNlZC5cblRoaXMgaXMgYW4gYW1iaWd1b3VzIGNvbmNlcHQgYXMgdG8gd2hhdCBleGFjdGx5IGlzIHByb2R1Y2VkIGJlY2F1c2UgYSBsaWJyYXJ5XG5jYW4gbWFuaWZlc3QgaXRzZWxmIGluIHNldmVyYWwgZm9ybXMuIFRoZSBwdXJwb3NlIG9mIHRoaXMgZ2VuZXJpYyBgbGliYCBvcHRpb25cbmlzIHRvIGdlbmVyYXRlIHRoZSBcImNvbXBpbGVyIHJlY29tbWVuZGVkXCIgc3R5bGUgb2YgbGlicmFyeS4gVGhlIG91dHB1dCBsaWJyYXJ5XG53aWxsIGFsd2F5cyBiZSB1c2FibGUgYnkgcnVzdGMsIGJ1dCB0aGUgYWN0dWFsIHR5cGUgb2YgbGlicmFyeSBtYXkgY2hhbmdlIGZyb21cbnRpbWUtdG8tdGltZS4gVGhlIHJlbWFpbmluZyBvdXRwdXQgdHlwZXMgYXJlIGFsbCBkaWZmZXJlbnQgZmxhdm9ycyBvZlxubGlicmFyaWVzLCBhbmQgdGhlIGBsaWJgIHR5cGUgY2FuIGJlIHNlZW4gYXMgYW4gYWxpYXMgZm9yIG9uZSBvZiB0aGVtIChidXQgdGhlXG5hY3R1YWwgb25lIGlzIGNvbXBpbGVyLWRlZmluZWQpLiIsCiAgICAgICAgICAgICAgICAgICJBIFwiUnVzdCBsaWJyYXJ5XCIgZmlsZSB3aWxsIGJlIHByb2R1Y2VkLiBUaGlzIGlzIHVzZWQgYXMgYW4gaW50ZXJtZWRpYXRlIGFydGlmYWN0IGFuZCBjYW4gYmUgdGhvdWdodCBvZiBhcyBhXG5cInN0YXRpYyBSdXN0IGxpYnJhcnlcIi4gVGhlc2UgYHJsaWJgIGZpbGVzLCB1bmxpa2UgYHN0YXRpY2xpYmAgZmlsZXMsIGFyZVxuaW50ZXJwcmV0ZWQgYnkgdGhlIGNvbXBpbGVyIGluIGZ1dHVyZSBsaW5rYWdlLiBUaGlzIGVzc2VudGlhbGx5IG1lYW5zXG50aGF0IGBydXN0Y2Agd2lsbCBsb29rIGZvciBtZXRhZGF0YSBpbiBgcmxpYmAgZmlsZXMgbGlrZSBpdCBsb29rcyBmb3IgbWV0YWRhdGFcbmluIGR5bmFtaWMgbGlicmFyaWVzLiBUaGlzIGZvcm0gb2Ygb3V0cHV0IGlzIHVzZWQgdG8gcHJvZHVjZSBzdGF0aWNhbGx5IGxpbmtlZFxuZXhlY3V0YWJsZXMgYXMgd2VsbCBhcyBgc3RhdGljbGliYCBvdXRwdXRzLiIsCiAgICAgICAgICAgICAgICAgICJBIGR5bmFtaWMgUnVzdCBsaWJyYXJ5IHdpbGwgYmUgcHJvZHVjZWQuIFRoaXMgaXMgZGlmZmVyZW50IGZyb20gdGhlIGBsaWJgIG91dHB1dCB0eXBlIGluIHRoYXQgdGhpcyBmb3JjZXNcbmR5bmFtaWMgbGlicmFyeSBnZW5lcmF0aW9uLiBUaGUgcmVzdWx0aW5nIGR5bmFtaWMgbGlicmFyeSBjYW4gYmUgdXNlZCBhcyBhXG5kZXBlbmRlbmN5IGZvciBvdGhlciBsaWJyYXJpZXMgYW5kL29yIGV4ZWN1dGFibGVzLiBUaGlzIG91dHB1dCB0eXBlIHdpbGxcbmNyZWF0ZSBgKi5zb2AgZmlsZXMgb24gbGludXgsIGAqLmR5bGliYCBmaWxlcyBvbiBvc3gsIGFuZCBgKi5kbGxgIGZpbGVzIG9uXG53aW5kb3dzLiIsCiAgICAgICAgICAgICAgICAgICJBIGR5bmFtaWMgc3lzdGVtIGxpYnJhcnkgd2lsbCBiZSBwcm9kdWNlZC4gVGhpcyBpcyB1c2VkIHdoZW4gY29tcGlsaW5nXG5hIGR5bmFtaWMgbGlicmFyeSB0byBiZSBsb2FkZWQgZnJvbSBhbm90aGVyIGxhbmd1YWdlLiAgVGhpcyBvdXRwdXQgdHlwZSB3aWxsXG5jcmVhdGUgYCouc29gIGZpbGVzIG9uIExpbnV4LCBgKi5keWxpYmAgZmlsZXMgb24gbWFjT1MsIGFuZCBgKi5kbGxgIGZpbGVzIG9uXG5XaW5kb3dzLiIsCiAgICAgICAgICAgICAgICAgICJBIHN0YXRpYyBzeXN0ZW0gbGlicmFyeSB3aWxsIGJlIHByb2R1Y2VkLiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIG90aGVyIGxpYnJhcnkgb3V0cHV0cyBpbiB0aGF0XG50aGUgY29tcGlsZXIgd2lsbCBuZXZlciBhdHRlbXB0IHRvIGxpbmsgdG8gYHN0YXRpY2xpYmAgb3V0cHV0cy4gVGhlXG5wdXJwb3NlIG9mIHRoaXMgb3V0cHV0IHR5cGUgaXMgdG8gY3JlYXRlIGEgc3RhdGljIGxpYnJhcnkgY29udGFpbmluZyBhbGwgb2ZcbnRoZSBsb2NhbCBjcmF0ZSdzIGNvZGUgYWxvbmcgd2l0aCBhbGwgdXBzdHJlYW0gZGVwZW5kZW5jaWVzLiBUaGUgc3RhdGljXG5saWJyYXJ5IGlzIGFjdHVhbGx5IGEgYCouYWAgYXJjaGl2ZSBvbiBsaW51eCBhbmQgb3N4IGFuZCBhIGAqLmxpYmAgZmlsZSBvblxud2luZG93cy4gVGhpcyBmb3JtYXQgaXMgcmVjb21tZW5kZWQgZm9yIHVzZSBpbiBzaXR1YXRpb25zIHN1Y2ggYXMgbGlua2luZ1xuUnVzdCBjb2RlIGludG8gYW4gZXhpc3Rpbmcgbm9uLVJ1c3QgYXBwbGljYXRpb24gYmVjYXVzZSBpdCB3aWxsIG5vdCBoYXZlXG5keW5hbWljIGRlcGVuZGVuY2llcyBvbiBvdGhlciBSdXN0IGNvZGUuIiwKICAgICAgICAgICAgICAgICAgIlRoZSBvdXRwdXQgcHJvZHVjZWQgaXMgbm90IHNwZWNpZmllZCwgYnV0IGlmIGEgYC1MYCBwYXRoIGlzIHByb3ZpZGVkIHRvIGl0IHRoZW4gdGhlXG5jb21waWxlciB3aWxsIHJlY29nbml6ZSB0aGUgb3V0cHV0IGFydGlmYWN0cyBhcyBhIG1hY3JvIGFuZCBpdCBjYW4gYmUgbG9hZGVkXG5mb3IgYSBwcm9ncmFtLiBDcmF0ZXMgY29tcGlsZWQgd2l0aCB0aGlzIGNyYXRlIHR5cGUgIG11c3Qgb25seSBleHBvcnRcbltwcm9jZWR1cmFsIG1hY3Jvc10oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9yZWZlcmVuY2UvcHJvY2VkdXJhbC1tYWNyb3MuaHRtbCkuIFRoZSBjb21waWxlciB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSBgcHJvY19tYWNyb2Bcbltjb25maWd1cmF0aW9uIG9wdGlvbl0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9yZWZlcmVuY2UvY29uZGl0aW9uYWwtY29tcGlsYXRpb24uaHRtbCkuIFRoZSBjcmF0ZXMgYXJlIGFsd2F5cyBjb21waWxlZCB3aXRoIHRoZSBzYW1lIHRhcmdldFxudGhhdCB0aGUgY29tcGlsZXIgaXRzZWxmIHdhcyBidWlsdCB3aXRoLiBGb3IgZXhhbXBsZSwgaWYgeW91IGFyZSBleGVjdXRpbmdcbnRoZSBjb21waWxlciBmcm9tIExpbnV4IHdpdGggYW4gYHg4Nl82NGAgQ1BVLCB0aGUgdGFyZ2V0IHdpbGwgYmVcbmB4ODZfNjQtdW5rbm93bi1saW51eC1nbnVgIGV2ZW4gaWYgdGhlIGNyYXRlIGlzIGEgZGVwZW5kZW5jeSBvZiBhbm90aGVyIGNyYXRlXG5iZWluZyBidWlsdCBmb3IgYSBkaWZmZXJlbnQgdGFyZ2V0LiIKICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI3RoZS1jcmF0ZS10eXBlLWZpZWxkIgogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAiZG9jcyI6IHsKICAgICAgICAgICAgICAiZW51bVZhbHVlcyI6IFsKICAgICAgICAgICAgICAgICJBIHJ1bm5hYmxlIGV4ZWN1dGFibGUgd2lsbCBiZSBwcm9kdWNlZC4gVGhpcyByZXF1aXJlcyB0aGF0IHRoZXJlIGlzIGEgYG1haW5gIGZ1bmN0aW9uIGluIHRoZSBjcmF0ZSB3aGljaFxud2lsbCBiZSBydW4gd2hlbiB0aGUgcHJvZ3JhbSBiZWdpbnMgZXhlY3V0aW5nLiBUaGlzIHdpbGwgbGluayBpbiBhbGwgUnVzdCBhbmRcbm5hdGl2ZSBkZXBlbmRlbmNpZXMsIHByb2R1Y2luZyBhIGRpc3RyaWJ1dGFibGUgYmluYXJ5LiIsCiAgICAgICAgICAgICAgICAiQSBSdXN0IGxpYnJhcnkgd2lsbCBiZSBwcm9kdWNlZC5cblRoaXMgaXMgYW4gYW1iaWd1b3VzIGNvbmNlcHQgYXMgdG8gd2hhdCBleGFjdGx5IGlzIHByb2R1Y2VkIGJlY2F1c2UgYSBsaWJyYXJ5XG5jYW4gbWFuaWZlc3QgaXRzZWxmIGluIHNldmVyYWwgZm9ybXMuIFRoZSBwdXJwb3NlIG9mIHRoaXMgZ2VuZXJpYyBgbGliYCBvcHRpb25cbmlzIHRvIGdlbmVyYXRlIHRoZSBcImNvbXBpbGVyIHJlY29tbWVuZGVkXCIgc3R5bGUgb2YgbGlicmFyeS4gVGhlIG91dHB1dCBsaWJyYXJ5XG53aWxsIGFsd2F5cyBiZSB1c2FibGUgYnkgcnVzdGMsIGJ1dCB0aGUgYWN0dWFsIHR5cGUgb2YgbGlicmFyeSBtYXkgY2hhbmdlIGZyb21cbnRpbWUtdG8tdGltZS4gVGhlIHJlbWFpbmluZyBvdXRwdXQgdHlwZXMgYXJlIGFsbCBkaWZmZXJlbnQgZmxhdm9ycyBvZlxubGlicmFyaWVzLCBhbmQgdGhlIGBsaWJgIHR5cGUgY2FuIGJlIHNlZW4gYXMgYW4gYWxpYXMgZm9yIG9uZSBvZiB0aGVtIChidXQgdGhlXG5hY3R1YWwgb25lIGlzIGNvbXBpbGVyLWRlZmluZWQpLiIsCiAgICAgICAgICAgICAgICAiQSBcIlJ1c3QgbGlicmFyeVwiIGZpbGUgd2lsbCBiZSBwcm9kdWNlZC4gVGhpcyBpcyB1c2VkIGFzIGFuIGludGVybWVkaWF0ZSBhcnRpZmFjdCBhbmQgY2FuIGJlIHRob3VnaHQgb2YgYXMgYVxuXCJzdGF0aWMgUnVzdCBsaWJyYXJ5XCIuIFRoZXNlIGBybGliYCBmaWxlcywgdW5saWtlIGBzdGF0aWNsaWJgIGZpbGVzLCBhcmVcbmludGVycHJldGVkIGJ5IHRoZSBjb21waWxlciBpbiBmdXR1cmUgbGlua2FnZS4gVGhpcyBlc3NlbnRpYWxseSBtZWFuc1xudGhhdCBgcnVzdGNgIHdpbGwgbG9vayBmb3IgbWV0YWRhdGEgaW4gYHJsaWJgIGZpbGVzIGxpa2UgaXQgbG9va3MgZm9yIG1ldGFkYXRhXG5pbiBkeW5hbWljIGxpYnJhcmllcy4gVGhpcyBmb3JtIG9mIG91dHB1dCBpcyB1c2VkIHRvIHByb2R1Y2Ugc3RhdGljYWxseSBsaW5rZWRcbmV4ZWN1dGFibGVzIGFzIHdlbGwgYXMgYHN0YXRpY2xpYmAgb3V0cHV0cy4iLAogICAgICAgICAgICAgICAgIkEgZHluYW1pYyBSdXN0IGxpYnJhcnkgd2lsbCBiZSBwcm9kdWNlZC4gVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYGxpYmAgb3V0cHV0IHR5cGUgaW4gdGhhdCB0aGlzIGZvcmNlc1xuZHluYW1pYyBsaWJyYXJ5IGdlbmVyYXRpb24uIFRoZSByZXN1bHRpbmcgZHluYW1pYyBsaWJyYXJ5IGNhbiBiZSB1c2VkIGFzIGFcbmRlcGVuZGVuY3kgZm9yIG90aGVyIGxpYnJhcmllcyBhbmQvb3IgZXhlY3V0YWJsZXMuIFRoaXMgb3V0cHV0IHR5cGUgd2lsbFxuY3JlYXRlIGAqLnNvYCBmaWxlcyBvbiBsaW51eCwgYCouZHlsaWJgIGZpbGVzIG9uIG9zeCwgYW5kIGAqLmRsbGAgZmlsZXMgb25cbndpbmRvd3MuIiwKICAgICAgICAgICAgICAgICJBIGR5bmFtaWMgc3lzdGVtIGxpYnJhcnkgd2lsbCBiZSBwcm9kdWNlZC4gVGhpcyBpcyB1c2VkIHdoZW4gY29tcGlsaW5nXG5hIGR5bmFtaWMgbGlicmFyeSB0byBiZSBsb2FkZWQgZnJvbSBhbm90aGVyIGxhbmd1YWdlLiAgVGhpcyBvdXRwdXQgdHlwZSB3aWxsXG5jcmVhdGUgYCouc29gIGZpbGVzIG9uIExpbnV4LCBgKi5keWxpYmAgZmlsZXMgb24gbWFjT1MsIGFuZCBgKi5kbGxgIGZpbGVzIG9uXG5XaW5kb3dzLiIsCiAgICAgICAgICAgICAgICAiQSBzdGF0aWMgc3lzdGVtIGxpYnJhcnkgd2lsbCBiZSBwcm9kdWNlZC4gVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBvdGhlciBsaWJyYXJ5IG91dHB1dHMgaW4gdGhhdFxudGhlIGNvbXBpbGVyIHdpbGwgbmV2ZXIgYXR0ZW1wdCB0byBsaW5rIHRvIGBzdGF0aWNsaWJgIG91dHB1dHMuIFRoZVxucHVycG9zZSBvZiB0aGlzIG91dHB1dCB0eXBlIGlzIHRvIGNyZWF0ZSBhIHN0YXRpYyBsaWJyYXJ5IGNvbnRhaW5pbmcgYWxsIG9mXG50aGUgbG9jYWwgY3JhdGUncyBjb2RlIGFsb25nIHdpdGggYWxsIHVwc3RyZWFtIGRlcGVuZGVuY2llcy4gVGhlIHN0YXRpY1xubGlicmFyeSBpcyBhY3R1YWxseSBhIGAqLmFgIGFyY2hpdmUgb24gbGludXggYW5kIG9zeCBhbmQgYSBgKi5saWJgIGZpbGUgb25cbndpbmRvd3MuIFRoaXMgZm9ybWF0IGlzIHJlY29tbWVuZGVkIGZvciB1c2UgaW4gc2l0dWF0aW9ucyBzdWNoIGFzIGxpbmtpbmdcblJ1c3QgY29kZSBpbnRvIGFuIGV4aXN0aW5nIG5vbi1SdXN0IGFwcGxpY2F0aW9uIGJlY2F1c2UgaXQgd2lsbCBub3QgaGF2ZVxuZHluYW1pYyBkZXBlbmRlbmNpZXMgb24gb3RoZXIgUnVzdCBjb2RlLiIsCiAgICAgICAgICAgICAgICAiVGhlIG91dHB1dCBwcm9kdWNlZCBpcyBub3Qgc3BlY2lmaWVkLCBidXQgaWYgYSBgLUxgIHBhdGggaXMgcHJvdmlkZWQgdG8gaXQgdGhlbiB0aGVcbmNvbXBpbGVyIHdpbGwgcmVjb2duaXplIHRoZSBvdXRwdXQgYXJ0aWZhY3RzIGFzIGEgbWFjcm8gYW5kIGl0IGNhbiBiZSBsb2FkZWRcbmZvciBhIHByb2dyYW0uIENyYXRlcyBjb21waWxlZCB3aXRoIHRoaXMgY3JhdGUgdHlwZSAgbXVzdCBvbmx5IGV4cG9ydFxuW3Byb2NlZHVyYWwgbWFjcm9zXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL3JlZmVyZW5jZS9wcm9jZWR1cmFsLW1hY3Jvcy5odG1sKS4gVGhlIGNvbXBpbGVyIHdpbGwgYXV0b21hdGljYWxseSBzZXQgdGhlIGBwcm9jX21hY3JvYFxuW2NvbmZpZ3VyYXRpb24gb3B0aW9uXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL3JlZmVyZW5jZS9jb25kaXRpb25hbC1jb21waWxhdGlvbi5odG1sKS4gVGhlIGNyYXRlcyBhcmUgYWx3YXlzIGNvbXBpbGVkIHdpdGggdGhlIHNhbWUgdGFyZ2V0XG50aGF0IHRoZSBjb21waWxlciBpdHNlbGYgd2FzIGJ1aWx0IHdpdGguIEZvciBleGFtcGxlLCBpZiB5b3UgYXJlIGV4ZWN1dGluZ1xudGhlIGNvbXBpbGVyIGZyb20gTGludXggd2l0aCBhbiBgeDg2XzY0YCBDUFUsIHRoZSB0YXJnZXQgd2lsbCBiZVxuYHg4Nl82NC11bmtub3duLWxpbnV4LWdudWAgZXZlbiBpZiB0aGUgY3JhdGUgaXMgYSBkZXBlbmRlbmN5IG9mIGFub3RoZXIgY3JhdGVcbmJlaW5nIGJ1aWx0IGZvciBhIGRpZmZlcmVudCB0YXJnZXQuIgogICAgICAgICAgICAgIF0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI3RoZS1jcmF0ZS10eXBlLWZpZWxkIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiY3JhdGVfdHlwZSI6IHsKICAgICAgICAgICJ0eXBlIjogImFycmF5IiwKICAgICAgICAgICJpdGVtcyI6IHsKICAgICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICAgImhpZGRlbiI6IHRydWUKICAgICAgICAgICAgfQogICAgICAgICAgfSwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAiaGlkZGVuIjogdHJ1ZQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgImRvYyI6IHsKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYGRvY2AgZmllbGQgaW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSB0YXJnZXQgaXMgaW5jbHVkZWQgaW4gdGhlXG5kb2N1bWVudGF0aW9uIGdlbmVyYXRlZCBieSBbYGNhcmdvIGRvY2BdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vY29tbWFuZHMvY2FyZ28tZG9jLmh0bWwpIGJ5IGRlZmF1bHQuIFRoZSBkZWZhdWx0IGlzIGB0cnVlYCBmb3JcbmxpYnJhcmllcyBhbmQgYmluYXJpZXMuXG5cbj4gKipOb3RlKio6IFRoZSBiaW5hcnkgd2lsbCBiZSBza2lwcGVkIGlmIGl0cyBuYW1lIGlzIHRoZSBzYW1lIGFzIHRoZSBsaWJcbj4gdGFyZ2V0LiIsCiAgICAgICAgICAidHlwZSI6ICJib29sZWFuIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9jYXJnby10YXJnZXRzLmh0bWwjdGhlLWRvYy1maWVsZCIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgImRvY3Rlc3QiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGBkb2N0ZXN0YCBmaWVsZCBpbmRpY2F0ZXMgd2hldGhlciBvciBub3QgW2RvY3VtZW50YXRpb24gZXhhbXBsZXNdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvcnVzdGRvYy9kb2N1bWVudGF0aW9uLXRlc3RzLmh0bWwpIGFyZVxudGVzdGVkIGJ5IGRlZmF1bHQgYnkgW2BjYXJnbyB0ZXN0YF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9jb21tYW5kcy9jYXJnby10ZXN0Lmh0bWwpLiBUaGlzIGlzIG9ubHkgcmVsZXZhbnQgZm9yIGxpYnJhcmllcywgaXRcbmhhcyBubyBlZmZlY3Qgb24gb3RoZXIgc2VjdGlvbnMuIFRoZSBkZWZhdWx0IGlzIGB0cnVlYCBmb3IgdGhlIGxpYnJhcnkuXG4iLAogICAgICAgICAgInR5cGUiOiAiYm9vbGVhbiIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI3RoZS1kb2N0ZXN0LWZpZWxkIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiZWRpdGlvbiI6IHsKICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvRWRpdGlvbiIKICAgICAgICB9LAogICAgICAgICJoYXJuZXNzIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgaGFybmVzc2AgZmllbGQgaW5kaWNhdGVzIHRoYXQgdGhlIFtgLS10ZXN0YCBmbGFnXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL3J1c3RjL2NvbW1hbmQtbGluZS1hcmd1bWVudHMuaHRtbCNvcHRpb24tdGVzdCkgd2lsbCBiZSBwYXNzZWQgdG9cbmBydXN0Y2Agd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGluY2x1ZGUgdGhlIGxpYnRlc3QgbGlicmFyeSB3aGljaCBpcyB0aGVcbmRyaXZlciBmb3IgY29sbGVjdGluZyBhbmQgcnVubmluZyB0ZXN0cyBtYXJrZWQgd2l0aCB0aGUgW2AjW3Rlc3RdYCBhdHRyaWJ1dGVdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvcmVmZXJlbmNlL2F0dHJpYnV0ZXMvdGVzdGluZy5odG1sI3RoZS10ZXN0LWF0dHJpYnV0ZSkgb3IgYmVuY2htYXJrcyB3aXRoIHRoZSBgI1tiZW5jaF1gIGF0dHJpYnV0ZS4gVGhlXG5kZWZhdWx0IGlzIGB0cnVlYCBmb3IgYWxsIHRhcmdldHMuXG5cbklmIHNldCB0byBgZmFsc2VgLCB0aGVuIHlvdSBhcmUgcmVzcG9uc2libGUgZm9yIGRlZmluaW5nIGEgYG1haW4oKWAgZnVuY3Rpb25cbnRvIHJ1biB0ZXN0cyBhbmQgYmVuY2htYXJrcy5cblxuVGVzdHMgaGF2ZSB0aGUgW2BjZmcodGVzdClgIGNvbmRpdGlvbmFsIGV4cHJlc3Npb25dKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvcmVmZXJlbmNlL2NvbmRpdGlvbmFsLWNvbXBpbGF0aW9uLmh0bWwjdGVzdCkgZW5hYmxlZCB3aGV0aGVyXG5vciBub3QgdGhlIGhhcm5lc3MgaXMgZW5hYmxlZC4iLAogICAgICAgICAgInR5cGUiOiAiYm9vbGVhbiIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI3RoZS1oYXJuZXNzLWZpZWxkIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAibmFtZSI6IHsKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYG5hbWVgIGZpZWxkIHNwZWNpZmllcyB0aGUgbmFtZSBvZiB0aGUgdGFyZ2V0LCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGVcbmZpbGVuYW1lIG9mIHRoZSBhcnRpZmFjdCB0aGF0IHdpbGwgYmUgZ2VuZXJhdGVkLiBGb3IgYSBsaWJyYXJ5LCB0aGlzIGlzIHRoZVxuY3JhdGUgbmFtZSB0aGF0IGRlcGVuZGVuY2llcyB3aWxsIHVzZSB0byByZWZlcmVuY2UgaXQuXG5cbkZvciB0aGUgYFtsaWJdYCBhbmQgdGhlIGRlZmF1bHQgYmluYXJ5IChgc3JjL21haW4ucnNgKSwgdGhpcyBkZWZhdWx0cyB0byB0aGVcbm5hbWUgb2YgdGhlIHBhY2thZ2UsIHdpdGggYW55IGRhc2hlcyByZXBsYWNlZCB3aXRoIHVuZGVyc2NvcmVzLiBGb3Igb3RoZXJcblthdXRvIGRpc2NvdmVyZWRdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2NhcmdvLXRhcmdldHMuaHRtbCN0YXJnZXQtYXV0by1kaXNjb3ZlcnkpIHRhcmdldHMsIGl0IGRlZmF1bHRzIHRvIHRoZVxuZGlyZWN0b3J5IG9yIGZpbGUgbmFtZS5cblxuVGhpcyBpcyByZXF1aXJlZCBmb3IgYWxsIHRhcmdldHMgZXhjZXB0IGBbbGliXWAuIiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI3RoZS1uYW1lLWZpZWxkIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAicGF0aCI6IHsKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYHBhdGhgIGZpZWxkIHNwZWNpZmllcyB3aGVyZSB0aGUgc291cmNlIGZvciB0aGUgY3JhdGUgaXMgbG9jYXRlZCwgcmVsYXRpdmVcbnRvIHRoZSBgQ2FyZ28udG9tbGAgZmlsZS5cblxuSWYgbm90IHNwZWNpZmllZCwgdGhlIFtpbmZlcnJlZCBwYXRoXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9jYXJnby10YXJnZXRzLmh0bWwjdGFyZ2V0LWF1dG8tZGlzY292ZXJ5KSBpcyB1c2VkIGJhc2VkIG9uXG50aGUgdGFyZ2V0IG5hbWUuIiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI3RoZS1wYXRoLWZpZWxkIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAicGx1Z2luIjogewogICAgICAgICAgInR5cGUiOiAiYm9vbGVhbiIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImhpZGRlbiI6IHRydWUKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICJwcm9jLW1hY3JvIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgcHJvYy1tYWNyb2AgZmllbGQgaW5kaWNhdGVzIHRoYXQgdGhlIGxpYnJhcnkgaXMgYSBbcHJvY2VkdXJhbCBtYWNyb10oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9ib29rL2NoMTktMDYtbWFjcm9zLmh0bWwpXG4oW3JlZmVyZW5jZV0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9yZWZlcmVuY2UvcHJvY2VkdXJhbC1tYWNyb3MuaHRtbCkpLiBUaGlzIGlzIG9ubHkgdmFsaWQgZm9yIHRoZSBgW2xpYl1gXG50YXJnZXQuIiwKICAgICAgICAgICJ0eXBlIjogImJvb2xlYW4iLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2NhcmdvLXRhcmdldHMuaHRtbCN0aGUtcHJvYy1tYWNyby1maWVsZCIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgInByb2NfbWFjcm8iOiB7CiAgICAgICAgICAidHlwZSI6ICJib29sZWFuIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAiaGlkZGVuIjogdHJ1ZQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgInJlcXVpcmVkLWZlYXR1cmVzIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgcmVxdWlyZWQtZmVhdHVyZXNgIGZpZWxkIHNwZWNpZmllcyB3aGljaCBbZmVhdHVyZXNdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2ZlYXR1cmVzLmh0bWwpIHRoZSB0YXJnZXQgbmVlZHMgaW5cbm9yZGVyIHRvIGJlIGJ1aWx0LiBJZiBhbnkgb2YgdGhlIHJlcXVpcmVkIGZlYXR1cmVzIGFyZSBub3QgZW5hYmxlZCwgdGhlXG50YXJnZXQgd2lsbCBiZSBza2lwcGVkLiBUaGlzIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHRoZSBgW1tiaW5dXWAsIGBbW2JlbmNoXV1gLFxuYFtbdGVzdF1dYCwgYW5kIGBbW2V4YW1wbGVdXWAgc2VjdGlvbnMsIGl0IGhhcyBubyBlZmZlY3Qgb24gYFtsaWJdYC5cblxuYGBgdG9tbFxuW2ZlYXR1cmVzXVxuIyAuLi5cbnBvc3RncmVzID0gW11cbnNxbGl0ZSA9IFtdXG50b29scyA9IFtdXG5cbltbYmluXV1cbm5hbWUgPSBcIm15LXBnLXRvb2xcIlxucmVxdWlyZWQtZmVhdHVyZXMgPSBbXCJwb3N0Z3Jlc1wiLCBcInRvb2xzXCJdXG5gYGBcbiIsCiAgICAgICAgICAidHlwZSI6ICJhcnJheSIsCiAgICAgICAgICAiaXRlbXMiOiB7CiAgICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYHJlcXVpcmVkLWZlYXR1cmVzYCBmaWVsZCBzcGVjaWZpZXMgd2hpY2ggW2ZlYXR1cmVzXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9mZWF0dXJlcy5odG1sKSB0aGUgdGFyZ2V0IG5lZWRzIGluXG5vcmRlciB0byBiZSBidWlsdC4gSWYgYW55IG9mIHRoZSByZXF1aXJlZCBmZWF0dXJlcyBhcmUgbm90IGVuYWJsZWQsIHRoZVxudGFyZ2V0IHdpbGwgYmUgc2tpcHBlZC4gVGhpcyBpcyBvbmx5IHJlbGV2YW50IGZvciB0aGUgYFtbYmluXV1gLCBgW1tiZW5jaF1dYCxcbmBbW3Rlc3RdXWAsIGFuZCBgW1tleGFtcGxlXV1gIHNlY3Rpb25zLCBpdCBoYXMgbm8gZWZmZWN0IG9uIGBbbGliXWAuXG5cbmBgYHRvbWxcbltmZWF0dXJlc11cbiMgLi4uXG5wb3N0Z3JlcyA9IFtdXG5zcWxpdGUgPSBbXVxudG9vbHMgPSBbXVxuXG5bW2Jpbl1dXG5uYW1lID0gXCJteS1wZy10b29sXCJcbnJlcXVpcmVkLWZlYXR1cmVzID0gW1wicG9zdGdyZXNcIiwgXCJ0b29sc1wiXVxuYGBgXG4iLAogICAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2NhcmdvLXRhcmdldHMuaHRtbCN0aGUtcmVxdWlyZWQtZmVhdHVyZXMtZmllbGQiCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9LAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2NhcmdvLXRhcmdldHMuaHRtbCN0aGUtcmVxdWlyZWQtZmVhdHVyZXMtZmllbGQiCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICJ0ZXN0IjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgdGVzdGAgZmllbGQgaW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSB0YXJnZXQgaXMgdGVzdGVkIGJ5IGRlZmF1bHQgYnlcbltgY2FyZ28gdGVzdGBdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vY29tbWFuZHMvY2FyZ28tdGVzdC5odG1sKS4gVGhlIGRlZmF1bHQgaXMgYHRydWVgIGZvciBsaWIsIGJpbnMsIGFuZCB0ZXN0cy5cblxuPiAqKk5vdGUqKjogRXhhbXBsZXMgYXJlIGJ1aWx0IGJ5IFtgY2FyZ28gdGVzdGBdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vY29tbWFuZHMvY2FyZ28tdGVzdC5odG1sKSBieSBkZWZhdWx0IHRvIGVuc3VyZSB0aGV5XG4\u002BIGNvbnRpbnVlIHRvIGNvbXBpbGUsIGJ1dCB0aGV5IGFyZSBub3QgKnRlc3RlZCogYnkgZGVmYXVsdC4gU2V0dGluZyBgdGVzdCA9XG4\u002BIHRydWVgIGZvciBhbiBleGFtcGxlIHdpbGwgYWxzbyBidWlsZCBpdCBhcyBhIHRlc3QgYW5kIHJ1biBhbnlcbj4gW2AjW3Rlc3RdYF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9yZWZlcmVuY2UvYXR0cmlidXRlcy90ZXN0aW5nLmh0bWwjdGhlLXRlc3QtYXR0cmlidXRlKSBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGUgZXhhbXBsZS4iLAogICAgICAgICAgInR5cGUiOiAiYm9vbGVhbiIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI3RoZS10ZXN0LWZpZWxkIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgIldvcmtzcGFjZSI6IHsKICAgICAgInRpdGxlIjogIldvcmtzcGFjZSIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYFt3b3Jrc3BhY2VdYCB0YWJsZSBpbiBgQ2FyZ28udG9tbGAgZGVmaW5lcyB3aGljaCBwYWNrYWdlcyBhcmUgbWVtYmVycyBvZlxudGhlIHdvcmtzcGFjZTpcblxuYGBgdG9tbFxuW3dvcmtzcGFjZV1cbm1lbWJlcnMgPSBbXCJtZW1iZXIxXCIsIFwicGF0aC90by9tZW1iZXIyXCIsIFwiY3JhdGVzLypcIl1cbmV4Y2x1ZGUgPSBbXCJjcmF0ZXMvZm9vXCIsIFwicGF0aC90by9vdGhlclwiXVxuYGBgXG5cbkFuIGVtcHR5IGBbd29ya3NwYWNlXWAgdGFibGUgY2FuIGJlIHVzZWQgd2l0aCBhIGBbcGFja2FnZV1gIHRvIGNvbnZlbmllbnRseVxuY3JlYXRlIGEgd29ya3NwYWNlIHdpdGggdGhlIHBhY2thZ2UgYW5kIGFsbCBvZiBpdHMgcGF0aCBkZXBlbmRlbmNpZXMuXG5cbkFsbCBbYHBhdGhgIGRlcGVuZGVuY2llc10oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMuaHRtbCNzcGVjaWZ5aW5nLXBhdGgtZGVwZW5kZW5jaWVzKSByZXNpZGluZyBpbiB0aGUgd29ya3NwYWNlIGRpcmVjdG9yeSBhdXRvbWF0aWNhbGx5XG5iZWNvbWUgbWVtYmVycy4gQWRkaXRpb25hbCBtZW1iZXJzIGNhbiBiZSBsaXN0ZWQgd2l0aCB0aGUgYG1lbWJlcnNgIGtleSwgd2hpY2hcbnNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIGNvbnRhaW5pbmcgZGlyZWN0b3JpZXMgd2l0aCBgQ2FyZ28udG9tbGAgZmlsZXMuXG5cblRoZSBgbWVtYmVyc2AgbGlzdCBhbHNvIHN1cHBvcnRzIFtnbG9ic10oaHR0cHM6Ly9kb2NzLnJzL2dsb2IvMC4zLjAvZ2xvYi9zdHJ1Y3QuUGF0dGVybi5odG1sKSB0byBtYXRjaCBtdWx0aXBsZSBwYXRocywgdXNpbmdcbnR5cGljYWwgZmlsZW5hbWUgZ2xvYiBwYXR0ZXJucyBsaWtlIGAqYCBhbmQgYD9gLlxuXG5UaGUgYGV4Y2x1ZGVgIGtleSBjYW4gYmUgdXNlZCB0byBwcmV2ZW50IHBhdGhzIGZyb20gYmVpbmcgaW5jbHVkZWQgaW4gYVxud29ya3NwYWNlLiBUaGlzIGNhbiBiZSB1c2VmdWwgaWYgc29tZSBwYXRoIGRlcGVuZGVuY2llcyBhcmVuJ3QgZGVzaXJlZCB0byBiZVxuaW4gdGhlIHdvcmtzcGFjZSBhdCBhbGwsIG9yIHVzaW5nIGEgZ2xvYiBwYXR0ZXJuIGFuZCB5b3Ugd2FudCB0byByZW1vdmUgYVxuZGlyZWN0b3J5LlxuXG5BbiBlbXB0eSBgW3dvcmtzcGFjZV1gIHRhYmxlIGNhbiBiZSB1c2VkIHdpdGggYSBgW3BhY2thZ2VdYCB0byBjb252ZW5pZW50bHlcbmNyZWF0ZSBhIHdvcmtzcGFjZSB3aXRoIHRoZSBwYWNrYWdlIGFuZCBhbGwgb2YgaXRzIHBhdGggZGVwZW5kZW5jaWVzLiIsCiAgICAgICJ0eXBlIjogIm9iamVjdCIsCiAgICAgICJwcm9wZXJ0aWVzIjogewogICAgICAgICJkZWZhdWx0LW1lbWJlcnMiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIG9wdGlvbmFsIGBkZWZhdWx0LW1lbWJlcnNgIGtleSBjYW4gYmUgc3BlY2lmaWVkIHRvIHNldCB0aGUgbWVtYmVycyB0b1xub3BlcmF0ZSBvbiB3aGVuIGluIHRoZSB3b3Jrc3BhY2Ugcm9vdCBhbmQgdGhlIHBhY2thZ2Ugc2VsZWN0aW9uIGZsYWdzIGFyZSBub3RcbnVzZWQ6XG5cbmBgYHRvbWxcblt3b3Jrc3BhY2VdXG5tZW1iZXJzID0gW1wicGF0aC90by9tZW1iZXIxXCIsIFwicGF0aC90by9tZW1iZXIyXCIsIFwicGF0aC90by9tZW1iZXIzLypcIl1cbmRlZmF1bHQtbWVtYmVycyA9IFtcInBhdGgvdG8vbWVtYmVyMlwiLCBcInBhdGgvdG8vbWVtYmVyMy9mb29cIl1cbmBgYFxuXG5XaGVuIHNwZWNpZmllZCwgYGRlZmF1bHQtbWVtYmVyc2AgbXVzdCBleHBhbmQgdG8gYSBzdWJzZXQgb2YgYG1lbWJlcnNgLiIsCiAgICAgICAgICAidHlwZSI6ICJhcnJheSIsCiAgICAgICAgICAiaXRlbXMiOiB7CiAgICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgb3B0aW9uYWwgYGRlZmF1bHQtbWVtYmVyc2Aga2V5IGNhbiBiZSBzcGVjaWZpZWQgdG8gc2V0IHRoZSBtZW1iZXJzIHRvXG5vcGVyYXRlIG9uIHdoZW4gaW4gdGhlIHdvcmtzcGFjZSByb290IGFuZCB0aGUgcGFja2FnZSBzZWxlY3Rpb24gZmxhZ3MgYXJlIG5vdFxudXNlZDpcblxuYGBgdG9tbFxuW3dvcmtzcGFjZV1cbm1lbWJlcnMgPSBbXCJwYXRoL3RvL21lbWJlcjFcIiwgXCJwYXRoL3RvL21lbWJlcjJcIiwgXCJwYXRoL3RvL21lbWJlcjMvKlwiXVxuZGVmYXVsdC1tZW1iZXJzID0gW1wicGF0aC90by9tZW1iZXIyXCIsIFwicGF0aC90by9tZW1iZXIzL2Zvb1wiXVxuYGBgXG5cbldoZW4gc3BlY2lmaWVkLCBgZGVmYXVsdC1tZW1iZXJzYCBtdXN0IGV4cGFuZCB0byBhIHN1YnNldCBvZiBgbWVtYmVyc2AuIiwKICAgICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS93b3Jrc3BhY2VzLmh0bWwjdGhlLXdvcmtzcGFjZS1zZWN0aW9uIgogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS93b3Jrc3BhY2VzLmh0bWwjdGhlLXdvcmtzcGFjZS1zZWN0aW9uIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiZGVwZW5kZW5jaWVzIjogewogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgd29ya3NwYWNlLmRlcGVuZGVuY2llc2AgdGFibGUgaXMgd2hlcmUgeW91IGRlZmluZSBkZXBlbmRlbmNpZXMgdG8gYmVcbmluaGVyaXRlZCBieSBtZW1iZXJzIG9mIGEgd29ya3NwYWNlLlxuXG5TcGVjaWZ5aW5nIGEgd29ya3NwYWNlIGRlcGVuZGVuY3kgaXMgc2ltaWxhciB0byBbcGFja2FnZSBkZXBlbmRlbmNpZXNdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwpIGV4Y2VwdDpcbi0gRGVwZW5kZW5jaWVzIGZyb20gdGhpcyB0YWJsZSBjYW5ub3QgYmUgZGVjbGFyZWQgYXMgYG9wdGlvbmFsYFxuLSBbYGZlYXR1cmVzYF1bZmVhdHVyZXNdIGRlY2xhcmVkIGluIHRoaXMgdGFibGUgYXJlIGFkZGl0aXZlIHdpdGggdGhlIGBmZWF0dXJlc2AgZnJvbSBgW2RlcGVuZGVuY2llc11gXG5cbllvdSBjYW4gdGhlbiBbaW5oZXJpdCB0aGUgd29ya3NwYWNlIGRlcGVuZGVuY3kgYXMgYSBwYWNrYWdlIGRlcGVuZGVuY3ldKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwjaW5oZXJpdGluZy1hLWRlcGVuZGVuY3ktZnJvbS1hLXdvcmtzcGFjZSlcblxuRXhhbXBsZTpcbmBgYHRvbWxcbiMgW1BST0pFQ1RfRElSXS9DYXJnby50b21sXG5bd29ya3NwYWNlXVxubWVtYmVycyA9IFtcImJhclwiXVxuXG5bd29ya3NwYWNlLmRlcGVuZGVuY2llc11cbmNjID0gXCIxLjAuNzNcIlxucmFuZCA9IFwiMC44LjVcIlxucmVnZXggPSB7IHZlcnNpb24gPSBcIjEuNi4wXCIsIGRlZmF1bHQtZmVhdHVyZXMgPSBmYWxzZSwgZmVhdHVyZXMgPSBbXCJzdGRcIl0gfVxuYGBgXG5cbmBgYHRvbWxcbiMgW1BST0pFQ1RfRElSXS9iYXIvQ2FyZ28udG9tbFxuW3BhY2thZ2VdXG5uYW1lID0gXCJiYXJcIlxudmVyc2lvbiA9IFwiMC4yLjBcIlxuXG5bZGVwZW5kZW5jaWVzXVxucmVnZXggPSB7IHdvcmtzcGFjZSA9IHRydWUsIGZlYXR1cmVzID0gW1widW5pY29kZVwiXSB9XG5cbltidWlsZC1kZXBlbmRlbmNpZXNdXG5jYy53b3Jrc3BhY2UgPSB0cnVlXG5cbltkZXYtZGVwZW5kZW5jaWVzXVxucmFuZC53b3Jrc3BhY2UgPSB0cnVlXG5gYGAiLAogICAgICAgICAgInR5cGUiOiAib2JqZWN0IiwKICAgICAgICAgICJhZGRpdGlvbmFsUHJvcGVydGllcyI6IHsKICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9EZXBlbmRlbmN5IgogICAgICAgICAgfSwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS93b3Jrc3BhY2VzLmh0bWwjdGhlLXdvcmtzcGFjZS1zZWN0aW9uIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiZXhjbHVkZSI6IHsKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYGV4Y2x1ZGVgIGtleSBjYW4gYmUgdXNlZCB0byBwcmV2ZW50IHBhdGhzIGZyb20gYmVpbmcgaW5jbHVkZWQgaW4gYVxud29ya3NwYWNlLiBUaGlzIGNhbiBiZSB1c2VmdWwgaWYgc29tZSBwYXRoIGRlcGVuZGVuY2llcyBhcmVuJ3QgZGVzaXJlZCB0byBiZVxuaW4gdGhlIHdvcmtzcGFjZSBhdCBhbGwsIG9yIHVzaW5nIGEgZ2xvYiBwYXR0ZXJuIGFuZCB5b3Ugd2FudCB0byByZW1vdmUgYVxuZGlyZWN0b3J5LiIsCiAgICAgICAgICAidHlwZSI6ICJhcnJheSIsCiAgICAgICAgICAiaXRlbXMiOiB7CiAgICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYGV4Y2x1ZGVgIGtleSBjYW4gYmUgdXNlZCB0byBwcmV2ZW50IHBhdGhzIGZyb20gYmVpbmcgaW5jbHVkZWQgaW4gYVxud29ya3NwYWNlLiBUaGlzIGNhbiBiZSB1c2VmdWwgaWYgc29tZSBwYXRoIGRlcGVuZGVuY2llcyBhcmVuJ3QgZGVzaXJlZCB0byBiZVxuaW4gdGhlIHdvcmtzcGFjZSBhdCBhbGwsIG9yIHVzaW5nIGEgZ2xvYiBwYXR0ZXJuIGFuZCB5b3Ugd2FudCB0byByZW1vdmUgYVxuZGlyZWN0b3J5LiIsCiAgICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvd29ya3NwYWNlcy5odG1sI3RoZS13b3Jrc3BhY2Utc2VjdGlvbiIKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0sCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvd29ya3NwYWNlcy5odG1sI3RoZS13b3Jrc3BhY2Utc2VjdGlvbiIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgIm1lbWJlcnMiOiB7CiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiQWxsIFtgcGF0aGAgZGVwZW5kZW5jaWVzXSByZXNpZGluZyBpbiB0aGUgd29ya3NwYWNlIGRpcmVjdG9yeSBhdXRvbWF0aWNhbGx5XG5iZWNvbWUgbWVtYmVycy4gQWRkaXRpb25hbCBtZW1iZXJzIGNhbiBiZSBsaXN0ZWQgd2l0aCB0aGUgYG1lbWJlcnNgIGtleSwgd2hpY2hcbnNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIGNvbnRhaW5pbmcgZGlyZWN0b3JpZXMgd2l0aCBgQ2FyZ28udG9tbGAgZmlsZXMuXG5cblRoZSBgbWVtYmVyc2AgbGlzdCBhbHNvIHN1cHBvcnRzIFtnbG9ic10gdG8gbWF0Y2ggbXVsdGlwbGUgcGF0aHMsIHVzaW5nXG50eXBpY2FsIGZpbGVuYW1lIGdsb2IgcGF0dGVybnMgbGlrZSBgKmAgYW5kIGA/YC4iLAogICAgICAgICAgInR5cGUiOiAiYXJyYXkiLAogICAgICAgICAgIml0ZW1zIjogewogICAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiQWxsIFtgcGF0aGAgZGVwZW5kZW5jaWVzXSByZXNpZGluZyBpbiB0aGUgd29ya3NwYWNlIGRpcmVjdG9yeSBhdXRvbWF0aWNhbGx5XG5iZWNvbWUgbWVtYmVycy4gQWRkaXRpb25hbCBtZW1iZXJzIGNhbiBiZSBsaXN0ZWQgd2l0aCB0aGUgYG1lbWJlcnNgIGtleSwgd2hpY2hcbnNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIGNvbnRhaW5pbmcgZGlyZWN0b3JpZXMgd2l0aCBgQ2FyZ28udG9tbGAgZmlsZXMuXG5cblRoZSBgbWVtYmVyc2AgbGlzdCBhbHNvIHN1cHBvcnRzIFtnbG9ic10gdG8gbWF0Y2ggbXVsdGlwbGUgcGF0aHMsIHVzaW5nXG50eXBpY2FsIGZpbGVuYW1lIGdsb2IgcGF0dGVybnMgbGlrZSBgKmAgYW5kIGA/YC4iLAogICAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3dvcmtzcGFjZXMuaHRtbCN0aGUtd29ya3NwYWNlLXNlY3Rpb24iCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9LAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3dvcmtzcGFjZXMuaHRtbCN0aGUtd29ya3NwYWNlLXNlY3Rpb24iCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYHdvcmtzcGFjZS5tZXRhZGF0YWAgdGFibGUgaXMgaWdub3JlZCBieSBDYXJnbyBhbmQgd2lsbCBub3QgYmUgd2FybmVkXG5hYm91dC4gVGhpcyBzZWN0aW9uIGNhbiBiZSB1c2VkIGZvciB0b29scyB0aGF0IHdvdWxkIGxpa2UgdG8gc3RvcmUgd29ya3NwYWNlXG5jb25maWd1cmF0aW9uIGluIGBDYXJnby50b21sYC4gRm9yIGV4YW1wbGU6XG5cbmBgYHRvbWxcblt3b3Jrc3BhY2VdXG5tZW1iZXJzID0gW1wibWVtYmVyMVwiLCBcIm1lbWJlcjJcIl1cblxuW3dvcmtzcGFjZS5tZXRhZGF0YS53ZWJjb250ZW50c11cbnJvb3QgPSBcInBhdGgvdG8vd2VicHJvamVjdFwiXG50b29sID0gW1wibnBtXCIsIFwicnVuXCIsIFwiYnVpbGRcIl1cbiMgLi4uXG5gYGBcblxuVGhlcmUgaXMgYSBzaW1pbGFyIHNldCBvZiB0YWJsZXMgYXQgdGhlIHBhY2thZ2UgbGV2ZWwgYXRcbmBwYWNrYWdlLm1ldGFkYXRhYC4gV2hpbGUgY2FyZ28gZG9lcyBub3Qgc3BlY2lmeSBhXG5mb3JtYXQgZm9yIHRoZSBjb250ZW50IG9mIGVpdGhlciBvZiB0aGVzZSB0YWJsZXMsIGl0IGlzIHN1Z2dlc3RlZCB0aGF0XG5leHRlcm5hbCB0b29scyBtYXkgd2lzaCB0byB1c2UgdGhlbSBpbiBhIGNvbnNpc3RlbnQgZmFzaGlvbiwgc3VjaCBhcyByZWZlcnJpbmdcbnRvIHRoZSBkYXRhIGluIGB3b3Jrc3BhY2UubWV0YWRhdGFgIGlmIGRhdGEgaXMgbWlzc2luZyBmcm9tIGBwYWNrYWdlLm1ldGFkYXRhYCxcbmlmIHRoYXQgbWFrZXMgc2Vuc2UgZm9yIHRoZSB0b29sIGluIHF1ZXN0aW9uLlxuIiwKICAgICAgICAgICJ0eXBlIjogIm9iamVjdCIsCiAgICAgICAgICAiYWRkaXRpb25hbFByb3BlcnRpZXMiOiB0cnVlLAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3dvcmtzcGFjZXMuaHRtbCN0aGUtd29ya3NwYWNlLXNlY3Rpb24iCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICJyZXNvbHZlciI6IHsKICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvUmVzb2x2ZXIiCiAgICAgICAgfSwKICAgICAgICAicGFja2FnZSI6IHsKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYHdvcmtzcGFjZS5wYWNrYWdlYCB0YWJsZSBpcyB3aGVyZSB5b3UgZGVmaW5lIGtleXMgdGhhdCBjYW4gYmVcbmluaGVyaXRlZCBieSBtZW1iZXJzIG9mIGEgd29ya3NwYWNlLiBUaGVzZSBrZXlzIGNhbiBiZSBpbmhlcml0ZWQgYnlcbmRlZmluaW5nIHRoZW0gaW4gdGhlIG1lbWJlciBwYWNrYWdlIHdpdGggYHtrZXl9LndvcmtzcGFjZSA9IHRydWVgLlxuXG5LZXlzIHRoYXQgYXJlIHN1cHBvcnRlZDpcblxufCAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB8XG58LS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXxcbnwgYGF1dGhvcnNgICAgICAgfCBgY2F0ZWdvcmllc2AgICAgfFxufCBgZGVzY3JpcHRpb25gICB8IGBkb2N1bWVudGF0aW9uYCB8XG58IGBlZGl0aW9uYCAgICAgIHwgYGV4Y2x1ZGVgICAgICAgIHxcbnwgYGhvbWVwYWdlYCAgICAgfCBgaW5jbHVkZWAgICAgICAgfFxufCBga2V5d29yZHNgICAgICB8IGBsaWNlbnNlYCAgICAgICB8XG58IGBsaWNlbnNlLWZpbGVgIHwgYHB1Ymxpc2hgICAgICAgIHxcbnwgYHJlYWRtZWAgICAgICAgfCBgcmVwb3NpdG9yeWAgICAgfFxufCBgcnVzdC12ZXJzaW9uYCB8IGB2ZXJzaW9uYCAgICAgICB8XG5cbi0gYGxpY2Vuc2UtZmlsZWAgYW5kIGByZWFkbWVgIGFyZSByZWxhdGl2ZSB0byB0aGUgd29ya3NwYWNlIHJvb3Rcbi0gYGluY2x1ZGVgIGFuZCBgZXhjbHVkZWAgYXJlIHJlbGF0aXZlIHRvIHlvdXIgcGFja2FnZSByb290XG5cbkV4YW1wbGU6XG5gYGB0b21sXG4jIFtQUk9KRUNUX0RJUl0vQ2FyZ28udG9tbFxuW3dvcmtzcGFjZV1cbm1lbWJlcnMgPSBbXCJiYXJcIl1cblxuW3dvcmtzcGFjZS5wYWNrYWdlXVxudmVyc2lvbiA9IFwiMS4yLjNcIlxuYXV0aG9ycyA9IFtcIk5pY2UgRm9sa3NcIl1cbmRlc2NyaXB0aW9uID0gXCJBIHNob3J0IGRlc2NyaXB0aW9uIG9mIG15IHBhY2thZ2VcIlxuZG9jdW1lbnRhdGlvbiA9IFwiaHR0cHM6Ly9leGFtcGxlLmNvbS9iYXJcIlxuYGBgXG5cbmBgYHRvbWxcbiMgW1BST0pFQ1RfRElSXS9iYXIvQ2FyZ28udG9tbFxuW3BhY2thZ2VdXG5uYW1lID0gXCJiYXJcIlxudmVyc2lvbi53b3Jrc3BhY2UgPSB0cnVlXG5hdXRob3JzLndvcmtzcGFjZSA9IHRydWVcbmRlc2NyaXB0aW9uLndvcmtzcGFjZSA9IHRydWVcbmRvY3VtZW50YXRpb24ud29ya3NwYWNlID0gdHJ1ZVxuYGBgIiwKICAgICAgICAgICJ0eXBlIjogIm9iamVjdCIsCiAgICAgICAgICAicHJvcGVydGllcyI6IHsKICAgICAgICAgICAgImF1dGhvcnMiOiB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9BdXRob3JzIgogICAgICAgICAgICB9LAogICAgICAgICAgICAiY2F0ZWdvcmllcyI6IHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL0NhdGVnb3JpZXMiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgICJkZXNjcmlwdGlvbiI6IHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL0Rlc2NyaXB0aW9uIgogICAgICAgICAgICB9LAogICAgICAgICAgICAiZG9jdW1lbnRhdGlvbiI6IHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL0RvY3VtZW50YXRpb24iCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgICJlZGl0aW9uIjogewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvRWRpdGlvbiIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgImV4Y2x1ZGUiOiB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9FeGNsdWRlIgogICAgICAgICAgICB9LAogICAgICAgICAgICAiaG9tZXBhZ2UiOiB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9Ib21lcGFnZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgImluY2x1ZGUiOiB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9JbmNsdWRlIgogICAgICAgICAgICB9LAogICAgICAgICAgICAia2V5d29yZHMiOiB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9LZXl3b3JkcyIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgImxpY2Vuc2UiOiB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9MaWNlbnNlIgogICAgICAgICAgICB9LAogICAgICAgICAgICAibGljZW5zZS1maWxlIjogewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvTGljZW5zZUZpbGUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgICJwdWJsaXNoIjogewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvUHVibGlzaCIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgInJlYWRtZSI6IHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1JlYWRtZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgInJlcG9zaXRvcnkiOiB7CiAgICAgICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9SZXBvc2l0b3J5IgogICAgICAgICAgICB9LAogICAgICAgICAgICAicnVzdC12ZXJzaW9uIjogewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvUnVzdFZlcnNpb24iCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgICJ2ZXJzaW9uIjogewogICAgICAgICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvU2VtVmVyIgogICAgICAgICAgICB9CiAgICAgICAgICB9LAogICAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3dvcmtzcGFjZXMuaHRtbCN0aGUtcGFja2FnZS10YWJsZSIKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS93b3Jrc3BhY2VzLmh0bWwiCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgIkF1dGhvcnMiOiB7CiAgICAgICJ0aXRsZSI6ICJBdXRob3JzIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgYXV0aG9yc2AgZmllbGQgbGlzdHMgcGVvcGxlIG9yIG9yZ2FuaXphdGlvbnMgdGhhdCBhcmUgY29uc2lkZXJlZCB0aGVcblwiYXV0aG9yc1wiIG9mIHRoZSBwYWNrYWdlLiBUaGUgZXhhY3QgbWVhbmluZyBpcyBvcGVuIHRvIGludGVycHJldGF0aW9uIOKAlCBpdCBtYXlcbmxpc3QgdGhlIG9yaWdpbmFsIG9yIHByaW1hcnkgYXV0aG9ycywgY3VycmVudCBtYWludGFpbmVycywgb3Igb3duZXJzIG9mIHRoZVxucGFja2FnZS4gVGhlc2UgbmFtZXMgd2lsbCBiZSBsaXN0ZWQgb24gdGhlIGNyYXRlJ3MgcGFnZSBvblxuW2NyYXRlcy5pb10oaHR0cHM6Ly9jcmF0ZXMuaW8pLiBBbiBvcHRpb25hbCBlbWFpbCBhZGRyZXNzIG1heSBiZSBpbmNsdWRlZCB3aXRoaW4gYW5nbGVkXG5icmFja2V0cyBhdCB0aGUgZW5kIG9mIGVhY2ggYXV0aG9yLlxuXG4\u002BICoqTm90ZSoqOiBbY3JhdGVzLmlvXShodHRwczovL2NyYXRlcy5pbykgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGF1dGhvciB0byBiZSBsaXN0ZWQuIiwKICAgICAgInR5cGUiOiAiYXJyYXkiLAogICAgICAiaXRlbXMiOiB7CiAgICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgYXV0aG9yc2AgZmllbGQgbGlzdHMgcGVvcGxlIG9yIG9yZ2FuaXphdGlvbnMgdGhhdCBhcmUgY29uc2lkZXJlZCB0aGVcblwiYXV0aG9yc1wiIG9mIHRoZSBwYWNrYWdlLiBUaGUgZXhhY3QgbWVhbmluZyBpcyBvcGVuIHRvIGludGVycHJldGF0aW9uIOKAlCBpdCBtYXlcbmxpc3QgdGhlIG9yaWdpbmFsIG9yIHByaW1hcnkgYXV0aG9ycywgY3VycmVudCBtYWludGFpbmVycywgb3Igb3duZXJzIG9mIHRoZVxucGFja2FnZS4gVGhlc2UgbmFtZXMgd2lsbCBiZSBsaXN0ZWQgb24gdGhlIGNyYXRlJ3MgcGFnZSBvblxuW2NyYXRlcy5pb10oaHR0cHM6Ly9jcmF0ZXMuaW8pLiBBbiBvcHRpb25hbCBlbWFpbCBhZGRyZXNzIG1heSBiZSBpbmNsdWRlZCB3aXRoaW4gYW5nbGVkXG5icmFja2V0cyBhdCB0aGUgZW5kIG9mIGVhY2ggYXV0aG9yLlxuXG4\u002BICoqTm90ZSoqOiBbY3JhdGVzLmlvXShodHRwczovL2NyYXRlcy5pbykgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGF1dGhvciB0byBiZSBsaXN0ZWQuIiwKICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL21hbmlmZXN0Lmh0bWwjdGhlLWF1dGhvcnMtZmllbGQiCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LAogICAgICAieC10YXBsbyI6IHsKICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL21hbmlmZXN0Lmh0bWwjdGhlLWF1dGhvcnMtZmllbGQiCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgIkNhdGVnb3JpZXMiOiB7CiAgICAgICJ0aXRsZSI6ICJDYXRlZ29yaWVzIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgY2F0ZWdvcmllc2AgZmllbGQgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncyBvZiB0aGUgY2F0ZWdvcmllcyB0aGlzIHBhY2thZ2VcbmJlbG9uZ3MgdG8uXG5cbmBgYHRvbWxcbmNhdGVnb3JpZXMgPSBbXCJjb21tYW5kLWxpbmUtdXRpbGl0aWVzXCIsIFwiZGV2ZWxvcG1lbnQtdG9vbHM6OmNhcmdvLXBsdWdpbnNcIl1cbmBgYFxuXG4\u002BICoqTm90ZSoqOiBbY3JhdGVzLmlvXShodHRwczovL2NyYXRlcy5pbykgaGFzIGEgbWF4aW11bSBvZiA1IGNhdGVnb3JpZXMuIEVhY2ggY2F0ZWdvcnkgc2hvdWxkXG4\u002BIG1hdGNoIG9uZSBvZiB0aGUgc3RyaW5ncyBhdmFpbGFibGUgYXQgaHR0cHM6Ly9jcmF0ZXMuaW8vY2F0ZWdvcnlfc2x1Z3MsIGFuZFxuPiBtdXN0IG1hdGNoIGV4YWN0bHkuIiwKICAgICAgInR5cGUiOiAiYXJyYXkiLAogICAgICAiaXRlbXMiOiB7CiAgICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgY2F0ZWdvcmllc2AgZmllbGQgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncyBvZiB0aGUgY2F0ZWdvcmllcyB0aGlzIHBhY2thZ2VcbmJlbG9uZ3MgdG8uXG5cbmBgYHRvbWxcbmNhdGVnb3JpZXMgPSBbXCJjb21tYW5kLWxpbmUtdXRpbGl0aWVzXCIsIFwiZGV2ZWxvcG1lbnQtdG9vbHM6OmNhcmdvLXBsdWdpbnNcIl1cbmBgYFxuXG4\u002BICoqTm90ZSoqOiBbY3JhdGVzLmlvXShodHRwczovL2NyYXRlcy5pbykgaGFzIGEgbWF4aW11bSBvZiA1IGNhdGVnb3JpZXMuIEVhY2ggY2F0ZWdvcnkgc2hvdWxkXG4\u002BIG1hdGNoIG9uZSBvZiB0aGUgc3RyaW5ncyBhdmFpbGFibGUgYXQgaHR0cHM6Ly9jcmF0ZXMuaW8vY2F0ZWdvcnlfc2x1Z3MsIGFuZFxuPiBtdXN0IG1hdGNoIGV4YWN0bHkuIiwKICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL21hbmlmZXN0Lmh0bWwjdGhlLWNhdGVnb3JpZXMtZmllbGQiCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LAogICAgICAieC10YXBsbyI6IHsKICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL21hbmlmZXN0Lmh0bWwjdGhlLWNhdGVnb3JpZXMtZmllbGQiCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgIkRlc2NyaXB0aW9uIjogewogICAgICAidGl0bGUiOiAiRGVzY3JpcHRpb24iLAogICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGRlc2NyaXB0aW9uIGlzIGEgc2hvcnQgYmx1cmIgYWJvdXQgdGhlIHBhY2thZ2UuIFtjcmF0ZXMuaW9dKGh0dHBzOi8vY3JhdGVzLmlvKSB3aWxsIGRpc3BsYXlcbnRoaXMgd2l0aCB5b3VyIHBhY2thZ2UuIFRoaXMgc2hvdWxkIGJlIHBsYWluIHRleHQgKG5vdCBNYXJrZG93bikuXG5cbmBgYHRvbWxcbltwYWNrYWdlXVxuIyAuLi5cbmRlc2NyaXB0aW9uID0gXCJBIHNob3J0IGRlc2NyaXB0aW9uIG9mIG15IHBhY2thZ2VcIlxuYGBgXG5cbj4gKipOb3RlKio6IFtjcmF0ZXMuaW9dKGh0dHBzOi8vY3JhdGVzLmlvKSByZXF1aXJlcyB0aGUgYGRlc2NyaXB0aW9uYCB0byBiZSBzZXQuIiwKICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9tYW5pZmVzdC5odG1sI3RoZS1kZXNjcmlwdGlvbi1maWVsZCIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAiRG9jdW1lbnRhdGlvbiI6IHsKICAgICAgInRpdGxlIjogIkRvY3VtZW50YXRpb24iLAogICAgICAiZGVzY3JpcHRpb24iOiAiXG5UaGUgYGRvY3VtZW50YXRpb25gIGZpZWxkIHNwZWNpZmllcyBhIFVSTCB0byBhIHdlYnNpdGUgaG9zdGluZyB0aGUgY3JhdGUnc1xuZG9jdW1lbnRhdGlvbi4gSWYgbm8gVVJMIGlzIHNwZWNpZmllZCBpbiB0aGUgbWFuaWZlc3QgZmlsZSwgW2NyYXRlcy5pb10oaHR0cHM6Ly9jcmF0ZXMuaW8pIHdpbGxcbmF1dG9tYXRpY2FsbHkgbGluayB5b3VyIGNyYXRlIHRvIHRoZSBjb3JyZXNwb25kaW5nIFtkb2NzLnJzXShodHRwczovL2RvY3MucnMpIHBhZ2UuXG5cbmBgYHRvbWxcbltwYWNrYWdlXVxuIyAuLi5cbmRvY3VtZW50YXRpb24gPSBcImh0dHBzOi8vZG9jcy5ycy9iaXRmbGFnc1wiXG5gYGBcbiIsCiAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvbWFuaWZlc3QuaHRtbCN0aGUtZG9jdW1lbnRhdGlvbi1maWVsZCIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAiRXhjbHVkZSI6IHsKICAgICAgInRpdGxlIjogIkV4Y2x1ZGUiLAogICAgICAiZGVzY3JpcHRpb24iOiAiWW91IGNhbiBleHBsaWNpdGx5IHNwZWNpZnkgdGhhdCBhIHNldCBvZiBmaWxlIHBhdHRlcm5zIHNob3VsZCBiZSBpZ25vcmVkIG9yXG5pbmNsdWRlZCBmb3IgdGhlIHB1cnBvc2VzIG9mIHBhY2thZ2luZy4gVGhlIHBhdHRlcm5zIHNwZWNpZmllZCBpbiB0aGVcbmBleGNsdWRlYCBmaWVsZCBpZGVudGlmeSBhIHNldCBvZiBmaWxlcyB0aGF0IGFyZSBub3QgaW5jbHVkZWQsIGFuZCB0aGVcbnBhdHRlcm5zIGluIGBpbmNsdWRlYCBzcGVjaWZ5IGZpbGVzIHRoYXQgYXJlIGV4cGxpY2l0bHkgaW5jbHVkZWQuXG5cblRoZSBwYXR0ZXJucyBzaG91bGQgYmUgW2dpdGlnbm9yZV0oaHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdGlnbm9yZSktc3R5bGUgcGF0dGVybnMuIEJyaWVmbHk6XG5cbi0gYGZvb2AgbWF0Y2hlcyBhbnkgZmlsZSBvciBkaXJlY3Rvcnkgd2l0aCB0aGUgbmFtZSBgZm9vYCBhbnl3aGVyZSBpbiB0aGVcbiAgcGFja2FnZS4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIHRoZSBwYXR0ZXJuIGAqKi9mb29gLlxuLSBgL2Zvb2AgbWF0Y2hlcyBhbnkgZmlsZSBvciBkaXJlY3Rvcnkgd2l0aCB0aGUgbmFtZSBgZm9vYCBvbmx5IGluIHRoZSByb290IG9mXG4gIHRoZSBwYWNrYWdlLlxuLSBgZm9vL2AgbWF0Y2hlcyBhbnkgKmRpcmVjdG9yeSogd2l0aCB0aGUgbmFtZSBgZm9vYCBhbnl3aGVyZSBpbiB0aGUgcGFja2FnZS5cbi0gQ29tbW9uIGdsb2IgcGF0dGVybnMgbGlrZSBgKmAsIGA/YCwgYW5kIGBbXWAgYXJlIHN1cHBvcnRlZDpcbiAgLSBgKmAgbWF0Y2hlcyB6ZXJvIG9yIG1vcmUgY2hhcmFjdGVycyBleGNlcHQgYC9gLiAgRm9yIGV4YW1wbGUsIGAqLmh0bWxgXG4gICAgbWF0Y2hlcyBhbnkgZmlsZSBvciBkaXJlY3Rvcnkgd2l0aCB0aGUgYC5odG1sYCBleHRlbnNpb24gYW55d2hlcmUgaW4gdGhlXG4gICAgcGFja2FnZS5cbiAgLSBgP2AgbWF0Y2hlcyBhbnkgY2hhcmFjdGVyIGV4Y2VwdCBgL2AuIEZvciBleGFtcGxlLCBgZm9vP2AgbWF0Y2hlcyBgZm9vZGAsXG4gICAgYnV0IG5vdCBgZm9vYC5cbiAgLSBgW11gIGFsbG93cyBmb3IgbWF0Y2hpbmcgYSByYW5nZSBvZiBjaGFyYWN0ZXJzLiBGb3IgZXhhbXBsZSwgYFthYl1gXG4gICAgbWF0Y2hlcyBlaXRoZXIgYGFgIG9yIGBiYC4gYFthLXpdYCBtYXRjaGVzIGxldHRlcnMgYSB0aHJvdWdoIHouXG4tIGAqKi9gIHByZWZpeCBtYXRjaGVzIGluIGFueSBkaXJlY3RvcnkuIEZvciBleGFtcGxlLCBgKiovZm9vL2JhcmAgbWF0Y2hlcyB0aGVcbiAgZmlsZSBvciBkaXJlY3RvcnkgYGJhcmAgYW55d2hlcmUgdGhhdCBpcyBkaXJlY3RseSB1bmRlciBkaXJlY3RvcnkgYGZvb2AuXG4tIGAvKipgIHN1ZmZpeCBtYXRjaGVzIGV2ZXJ5dGhpbmcgaW5zaWRlLiBGb3IgZXhhbXBsZSwgYGZvby8qKmAgbWF0Y2hlcyBhbGxcbiAgZmlsZXMgaW5zaWRlIGRpcmVjdG9yeSBgZm9vYCwgaW5jbHVkaW5nIGFsbCBmaWxlcyBpbiBzdWJkaXJlY3RvcmllcyBiZWxvd1xuICBgZm9vYC5cbi0gYC8qKi9gIG1hdGNoZXMgemVybyBvciBtb3JlIGRpcmVjdG9yaWVzLiBGb3IgZXhhbXBsZSwgYGEvKiovYmAgbWF0Y2hlc1xuICBgYS9iYCwgYGEveC9iYCwgYGEveC95L2JgLCBhbmQgc28gb24uXG4tIGAhYCBwcmVmaXggbmVnYXRlcyBhIHBhdHRlcm4uIEZvciBleGFtcGxlLCBhIHBhdHRlcm4gb2YgYHNyYy8qKi5yc2AgYW5kXG4gIGAhZm9vLnJzYCB3b3VsZCBtYXRjaCBhbGwgZmlsZXMgd2l0aCB0aGUgYC5yc2AgZXh0ZW5zaW9uIGluc2lkZSB0aGUgYHNyY2BcbiAgZGlyZWN0b3J5LCBleGNlcHQgZm9yIGFueSBmaWxlIG5hbWVkIGBmb28ucnNgLlxuXG5JZiBnaXQgaXMgYmVpbmcgdXNlZCBmb3IgYSBwYWNrYWdlLCB0aGUgYGV4Y2x1ZGVgIGZpZWxkIHdpbGwgYmUgc2VlZGVkIHdpdGhcbnRoZSBgZ2l0aWdub3JlYCBzZXR0aW5ncyBmcm9tIHRoZSByZXBvc2l0b3J5LlxuXG5gYGB0b21sXG5bcGFja2FnZV1cbiMgLi4uXG5leGNsdWRlID0gW1wiYnVpbGQvKiovKi5vXCIsIFwiZG9jLyoqLyouaHRtbFwiXVxuYGBgXG5cbmBgYHRvbWxcbltwYWNrYWdlXVxuIyAuLi5cbmluY2x1ZGUgPSBbXCJzcmMvKiovKlwiLCBcIkNhcmdvLnRvbWxcIl1cbmBgYFxuXG5UaGUgb3B0aW9ucyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlOiBzZXR0aW5nIGBpbmNsdWRlYCB3aWxsIG92ZXJyaWRlIGFuXG5gZXhjbHVkZWAuIE5vdGUgdGhhdCBgaW5jbHVkZWAgbXVzdCBiZSBhbiBleGhhdXN0aXZlIGxpc3Qgb2YgZmlsZXMgYXMgb3RoZXJ3aXNlXG5uZWNlc3Nhcnkgc291cmNlIGZpbGVzIG1heSBub3QgYmUgaW5jbHVkZWQuIFRoZSBwYWNrYWdlJ3MgYENhcmdvLnRvbWxgIGlzXG5hdXRvbWF0aWNhbGx5IGluY2x1ZGVkLlxuXG5UaGUgaW5jbHVkZS9leGNsdWRlIGxpc3QgaXMgYWxzbyB1c2VkIGZvciBjaGFuZ2UgdHJhY2tpbmcgaW4gc29tZSBzaXR1YXRpb25zLlxuRm9yIHRhcmdldHMgYnVpbHQgd2l0aCBgcnVzdGRvY2AsIGl0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBsaXN0IG9mIGZpbGVzIHRvXG50cmFjayB0byBkZXRlcm1pbmUgaWYgdGhlIHRhcmdldCBzaG91bGQgYmUgcmVidWlsdC4gSWYgdGhlIHBhY2thZ2UgaGFzIGFcbltidWlsZCBzY3JpcHRdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2J1aWxkLXNjcmlwdHMuaHRtbCkgdGhhdCBkb2VzIG5vdCBlbWl0IGFueSBgcmVydW4taWYtKmAgZGlyZWN0aXZlcywgdGhlbiB0aGVcbmluY2x1ZGUvZXhjbHVkZSBsaXN0IGlzIHVzZWQgZm9yIHRyYWNraW5nIGlmIHRoZSBidWlsZCBzY3JpcHQgc2hvdWxkIGJlIHJlLXJ1blxuaWYgYW55IG9mIHRob3NlIGZpbGVzIGNoYW5nZS4iLAogICAgICAidHlwZSI6ICJhcnJheSIsCiAgICAgICJpdGVtcyI6IHsKICAgICAgICAiZGVzY3JpcHRpb24iOiAiWW91IGNhbiBleHBsaWNpdGx5IHNwZWNpZnkgdGhhdCBhIHNldCBvZiBmaWxlIHBhdHRlcm5zIHNob3VsZCBiZSBpZ25vcmVkIG9yXG5pbmNsdWRlZCBmb3IgdGhlIHB1cnBvc2VzIG9mIHBhY2thZ2luZy4gVGhlIHBhdHRlcm5zIHNwZWNpZmllZCBpbiB0aGVcbmBleGNsdWRlYCBmaWVsZCBpZGVudGlmeSBhIHNldCBvZiBmaWxlcyB0aGF0IGFyZSBub3QgaW5jbHVkZWQsIGFuZCB0aGVcbnBhdHRlcm5zIGluIGBpbmNsdWRlYCBzcGVjaWZ5IGZpbGVzIHRoYXQgYXJlIGV4cGxpY2l0bHkgaW5jbHVkZWQuXG5cblRoZSBwYXR0ZXJucyBzaG91bGQgYmUgW2dpdGlnbm9yZV0oaHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdGlnbm9yZSktc3R5bGUgcGF0dGVybnMuIEJyaWVmbHk6XG5cbi0gYGZvb2AgbWF0Y2hlcyBhbnkgZmlsZSBvciBkaXJlY3Rvcnkgd2l0aCB0aGUgbmFtZSBgZm9vYCBhbnl3aGVyZSBpbiB0aGVcbiAgcGFja2FnZS4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIHRoZSBwYXR0ZXJuIGAqKi9mb29gLlxuLSBgL2Zvb2AgbWF0Y2hlcyBhbnkgZmlsZSBvciBkaXJlY3Rvcnkgd2l0aCB0aGUgbmFtZSBgZm9vYCBvbmx5IGluIHRoZSByb290IG9mXG4gIHRoZSBwYWNrYWdlLlxuLSBgZm9vL2AgbWF0Y2hlcyBhbnkgKmRpcmVjdG9yeSogd2l0aCB0aGUgbmFtZSBgZm9vYCBhbnl3aGVyZSBpbiB0aGUgcGFja2FnZS5cbi0gQ29tbW9uIGdsb2IgcGF0dGVybnMgbGlrZSBgKmAsIGA/YCwgYW5kIGBbXWAgYXJlIHN1cHBvcnRlZDpcbiAgLSBgKmAgbWF0Y2hlcyB6ZXJvIG9yIG1vcmUgY2hhcmFjdGVycyBleGNlcHQgYC9gLiAgRm9yIGV4YW1wbGUsIGAqLmh0bWxgXG4gICAgbWF0Y2hlcyBhbnkgZmlsZSBvciBkaXJlY3Rvcnkgd2l0aCB0aGUgYC5odG1sYCBleHRlbnNpb24gYW55d2hlcmUgaW4gdGhlXG4gICAgcGFja2FnZS5cbiAgLSBgP2AgbWF0Y2hlcyBhbnkgY2hhcmFjdGVyIGV4Y2VwdCBgL2AuIEZvciBleGFtcGxlLCBgZm9vP2AgbWF0Y2hlcyBgZm9vZGAsXG4gICAgYnV0IG5vdCBgZm9vYC5cbiAgLSBgW11gIGFsbG93cyBmb3IgbWF0Y2hpbmcgYSByYW5nZSBvZiBjaGFyYWN0ZXJzLiBGb3IgZXhhbXBsZSwgYFthYl1gXG4gICAgbWF0Y2hlcyBlaXRoZXIgYGFgIG9yIGBiYC4gYFthLXpdYCBtYXRjaGVzIGxldHRlcnMgYSB0aHJvdWdoIHouXG4tIGAqKi9gIHByZWZpeCBtYXRjaGVzIGluIGFueSBkaXJlY3RvcnkuIEZvciBleGFtcGxlLCBgKiovZm9vL2JhcmAgbWF0Y2hlcyB0aGVcbiAgZmlsZSBvciBkaXJlY3RvcnkgYGJhcmAgYW55d2hlcmUgdGhhdCBpcyBkaXJlY3RseSB1bmRlciBkaXJlY3RvcnkgYGZvb2AuXG4tIGAvKipgIHN1ZmZpeCBtYXRjaGVzIGV2ZXJ5dGhpbmcgaW5zaWRlLiBGb3IgZXhhbXBsZSwgYGZvby8qKmAgbWF0Y2hlcyBhbGxcbiAgZmlsZXMgaW5zaWRlIGRpcmVjdG9yeSBgZm9vYCwgaW5jbHVkaW5nIGFsbCBmaWxlcyBpbiBzdWJkaXJlY3RvcmllcyBiZWxvd1xuICBgZm9vYC5cbi0gYC8qKi9gIG1hdGNoZXMgemVybyBvciBtb3JlIGRpcmVjdG9yaWVzLiBGb3IgZXhhbXBsZSwgYGEvKiovYmAgbWF0Y2hlc1xuICBgYS9iYCwgYGEveC9iYCwgYGEveC95L2JgLCBhbmQgc28gb24uXG4tIGAhYCBwcmVmaXggbmVnYXRlcyBhIHBhdHRlcm4uIEZvciBleGFtcGxlLCBhIHBhdHRlcm4gb2YgYHNyYy8qKi5yc2AgYW5kXG4gIGAhZm9vLnJzYCB3b3VsZCBtYXRjaCBhbGwgZmlsZXMgd2l0aCB0aGUgYC5yc2AgZXh0ZW5zaW9uIGluc2lkZSB0aGUgYHNyY2BcbiAgZGlyZWN0b3J5LCBleGNlcHQgZm9yIGFueSBmaWxlIG5hbWVkIGBmb28ucnNgLlxuXG5JZiBnaXQgaXMgYmVpbmcgdXNlZCBmb3IgYSBwYWNrYWdlLCB0aGUgYGV4Y2x1ZGVgIGZpZWxkIHdpbGwgYmUgc2VlZGVkIHdpdGhcbnRoZSBgZ2l0aWdub3JlYCBzZXR0aW5ncyBmcm9tIHRoZSByZXBvc2l0b3J5LlxuXG5gYGB0b21sXG5bcGFja2FnZV1cbiMgLi4uXG5leGNsdWRlID0gW1wiYnVpbGQvKiovKi5vXCIsIFwiZG9jLyoqLyouaHRtbFwiXVxuYGBgXG5cbmBgYHRvbWxcbltwYWNrYWdlXVxuIyAuLi5cbmluY2x1ZGUgPSBbXCJzcmMvKiovKlwiLCBcIkNhcmdvLnRvbWxcIl1cbmBgYFxuXG5UaGUgb3B0aW9ucyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlOiBzZXR0aW5nIGBpbmNsdWRlYCB3aWxsIG92ZXJyaWRlIGFuXG5gZXhjbHVkZWAuIE5vdGUgdGhhdCBgaW5jbHVkZWAgbXVzdCBiZSBhbiBleGhhdXN0aXZlIGxpc3Qgb2YgZmlsZXMgYXMgb3RoZXJ3aXNlXG5uZWNlc3Nhcnkgc291cmNlIGZpbGVzIG1heSBub3QgYmUgaW5jbHVkZWQuIFRoZSBwYWNrYWdlJ3MgYENhcmdvLnRvbWxgIGlzXG5hdXRvbWF0aWNhbGx5IGluY2x1ZGVkLlxuXG5UaGUgaW5jbHVkZS9leGNsdWRlIGxpc3QgaXMgYWxzbyB1c2VkIGZvciBjaGFuZ2UgdHJhY2tpbmcgaW4gc29tZSBzaXR1YXRpb25zLlxuRm9yIHRhcmdldHMgYnVpbHQgd2l0aCBgcnVzdGRvY2AsIGl0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBsaXN0IG9mIGZpbGVzIHRvXG50cmFjayB0byBkZXRlcm1pbmUgaWYgdGhlIHRhcmdldCBzaG91bGQgYmUgcmVidWlsdC4gSWYgdGhlIHBhY2thZ2UgaGFzIGFcbltidWlsZCBzY3JpcHRdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2J1aWxkLXNjcmlwdHMuaHRtbCkgdGhhdCBkb2VzIG5vdCBlbWl0IGFueSBgcmVydW4taWYtKmAgZGlyZWN0aXZlcywgdGhlbiB0aGVcbmluY2x1ZGUvZXhjbHVkZSBsaXN0IGlzIHVzZWQgZm9yIHRyYWNraW5nIGlmIHRoZSBidWlsZCBzY3JpcHQgc2hvdWxkIGJlIHJlLXJ1blxuaWYgYW55IG9mIHRob3NlIGZpbGVzIGNoYW5nZS4iLAogICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvbWFuaWZlc3QuaHRtbCN0aGUtZXhjbHVkZS1hbmQtaW5jbHVkZS1maWVsZHMiCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LAogICAgICAieC10YXBsbyI6IHsKICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL21hbmlmZXN0Lmh0bWwjdGhlLWV4Y2x1ZGUtYW5kLWluY2x1ZGUtZmllbGRzIgogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJIb21lcGFnZSI6IHsKICAgICAgInRpdGxlIjogIkhvbWVwYWdlIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgaG9tZXBhZ2VgIGZpZWxkIHNob3VsZCBiZSBhIFVSTCB0byBhIHNpdGUgdGhhdCBpcyB0aGUgaG9tZSBwYWdlIGZvciB5b3VyXG5wYWNrYWdlLlxuXG5gYGB0b21sXG5bcGFja2FnZV1cbiMgLi4uXG5ob21lcGFnZSA9IFwiaHR0cHM6Ly9zZXJkZS5ycy9cIlxuYGBgIiwKICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9tYW5pZmVzdC5odG1sI3RoZS1ob21lcGFnZS1maWVsZCIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAiSW5jbHVkZSI6IHsKICAgICAgImRlc2NyaXB0aW9uIjogIllvdSBjYW4gZXhwbGljaXRseSBzcGVjaWZ5IHRoYXQgYSBzZXQgb2YgZmlsZSBwYXR0ZXJucyBzaG91bGQgYmUgaWdub3JlZCBvclxuaW5jbHVkZWQgZm9yIHRoZSBwdXJwb3NlcyBvZiBwYWNrYWdpbmcuIFRoZSBwYXR0ZXJucyBzcGVjaWZpZWQgaW4gdGhlXG5gZXhjbHVkZWAgZmllbGQgaWRlbnRpZnkgYSBzZXQgb2YgZmlsZXMgdGhhdCBhcmUgbm90IGluY2x1ZGVkLCBhbmQgdGhlXG5wYXR0ZXJucyBpbiBgaW5jbHVkZWAgc3BlY2lmeSBmaWxlcyB0aGF0IGFyZSBleHBsaWNpdGx5IGluY2x1ZGVkLlxuXG5UaGUgcGF0dGVybnMgc2hvdWxkIGJlIFtnaXRpZ25vcmVdKGh0dHBzOi8vZ2l0LXNjbS5jb20vZG9jcy9naXRpZ25vcmUpLXN0eWxlIHBhdHRlcm5zLiBCcmllZmx5OlxuXG4tIGBmb29gIG1hdGNoZXMgYW55IGZpbGUgb3IgZGlyZWN0b3J5IHdpdGggdGhlIG5hbWUgYGZvb2AgYW55d2hlcmUgaW4gdGhlXG4gIHBhY2thZ2UuIFRoaXMgaXMgZXF1aXZhbGVudCB0byB0aGUgcGF0dGVybiBgKiovZm9vYC5cbi0gYC9mb29gIG1hdGNoZXMgYW55IGZpbGUgb3IgZGlyZWN0b3J5IHdpdGggdGhlIG5hbWUgYGZvb2Agb25seSBpbiB0aGUgcm9vdCBvZlxuICB0aGUgcGFja2FnZS5cbi0gYGZvby9gIG1hdGNoZXMgYW55ICpkaXJlY3RvcnkqIHdpdGggdGhlIG5hbWUgYGZvb2AgYW55d2hlcmUgaW4gdGhlIHBhY2thZ2UuXG4tIENvbW1vbiBnbG9iIHBhdHRlcm5zIGxpa2UgYCpgLCBgP2AsIGFuZCBgW11gIGFyZSBzdXBwb3J0ZWQ6XG4gIC0gYCpgIG1hdGNoZXMgemVybyBvciBtb3JlIGNoYXJhY3RlcnMgZXhjZXB0IGAvYC4gIEZvciBleGFtcGxlLCBgKi5odG1sYFxuICAgIG1hdGNoZXMgYW55IGZpbGUgb3IgZGlyZWN0b3J5IHdpdGggdGhlIGAuaHRtbGAgZXh0ZW5zaW9uIGFueXdoZXJlIGluIHRoZVxuICAgIHBhY2thZ2UuXG4gIC0gYD9gIG1hdGNoZXMgYW55IGNoYXJhY3RlciBleGNlcHQgYC9gLiBGb3IgZXhhbXBsZSwgYGZvbz9gIG1hdGNoZXMgYGZvb2RgLFxuICAgIGJ1dCBub3QgYGZvb2AuXG4gIC0gYFtdYCBhbGxvd3MgZm9yIG1hdGNoaW5nIGEgcmFuZ2Ugb2YgY2hhcmFjdGVycy4gRm9yIGV4YW1wbGUsIGBbYWJdYFxuICAgIG1hdGNoZXMgZWl0aGVyIGBhYCBvciBgYmAuIGBbYS16XWAgbWF0Y2hlcyBsZXR0ZXJzIGEgdGhyb3VnaCB6LlxuLSBgKiovYCBwcmVmaXggbWF0Y2hlcyBpbiBhbnkgZGlyZWN0b3J5LiBGb3IgZXhhbXBsZSwgYCoqL2Zvby9iYXJgIG1hdGNoZXMgdGhlXG4gIGZpbGUgb3IgZGlyZWN0b3J5IGBiYXJgIGFueXdoZXJlIHRoYXQgaXMgZGlyZWN0bHkgdW5kZXIgZGlyZWN0b3J5IGBmb29gLlxuLSBgLyoqYCBzdWZmaXggbWF0Y2hlcyBldmVyeXRoaW5nIGluc2lkZS4gRm9yIGV4YW1wbGUsIGBmb28vKipgIG1hdGNoZXMgYWxsXG4gIGZpbGVzIGluc2lkZSBkaXJlY3RvcnkgYGZvb2AsIGluY2x1ZGluZyBhbGwgZmlsZXMgaW4gc3ViZGlyZWN0b3JpZXMgYmVsb3dcbiAgYGZvb2AuXG4tIGAvKiovYCBtYXRjaGVzIHplcm8gb3IgbW9yZSBkaXJlY3Rvcmllcy4gRm9yIGV4YW1wbGUsIGBhLyoqL2JgIG1hdGNoZXNcbiAgYGEvYmAsIGBhL3gvYmAsIGBhL3gveS9iYCwgYW5kIHNvIG9uLlxuLSBgIWAgcHJlZml4IG5lZ2F0ZXMgYSBwYXR0ZXJuLiBGb3IgZXhhbXBsZSwgYSBwYXR0ZXJuIG9mIGBzcmMvKioucnNgIGFuZFxuICBgIWZvby5yc2Agd291bGQgbWF0Y2ggYWxsIGZpbGVzIHdpdGggdGhlIGAucnNgIGV4dGVuc2lvbiBpbnNpZGUgdGhlIGBzcmNgXG4gIGRpcmVjdG9yeSwgZXhjZXB0IGZvciBhbnkgZmlsZSBuYW1lZCBgZm9vLnJzYC5cblxuSWYgZ2l0IGlzIGJlaW5nIHVzZWQgZm9yIGEgcGFja2FnZSwgdGhlIGBleGNsdWRlYCBmaWVsZCB3aWxsIGJlIHNlZWRlZCB3aXRoXG50aGUgYGdpdGlnbm9yZWAgc2V0dGluZ3MgZnJvbSB0aGUgcmVwb3NpdG9yeS5cblxuYGBgdG9tbFxuW3BhY2thZ2VdXG4jIC4uLlxuZXhjbHVkZSA9IFtcImJ1aWxkLyoqLyoub1wiLCBcImRvYy8qKi8qLmh0bWxcIl1cbmBgYFxuXG5gYGB0b21sXG5bcGFja2FnZV1cbiMgLi4uXG5pbmNsdWRlID0gW1wic3JjLyoqLypcIiwgXCJDYXJnby50b21sXCJdXG5gYGBcblxuVGhlIG9wdGlvbnMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZTogc2V0dGluZyBgaW5jbHVkZWAgd2lsbCBvdmVycmlkZSBhblxuYGV4Y2x1ZGVgLiBOb3RlIHRoYXQgYGluY2x1ZGVgIG11c3QgYmUgYW4gZXhoYXVzdGl2ZSBsaXN0IG9mIGZpbGVzIGFzIG90aGVyd2lzZVxubmVjZXNzYXJ5IHNvdXJjZSBmaWxlcyBtYXkgbm90IGJlIGluY2x1ZGVkLiBUaGUgcGFja2FnZSdzIGBDYXJnby50b21sYCBpc1xuYXV0b21hdGljYWxseSBpbmNsdWRlZC5cblxuVGhlIGluY2x1ZGUvZXhjbHVkZSBsaXN0IGlzIGFsc28gdXNlZCBmb3IgY2hhbmdlIHRyYWNraW5nIGluIHNvbWUgc2l0dWF0aW9ucy5cbkZvciB0YXJnZXRzIGJ1aWx0IHdpdGggYHJ1c3Rkb2NgLCBpdCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgbGlzdCBvZiBmaWxlcyB0b1xudHJhY2sgdG8gZGV0ZXJtaW5lIGlmIHRoZSB0YXJnZXQgc2hvdWxkIGJlIHJlYnVpbHQuIElmIHRoZSBwYWNrYWdlIGhhcyBhXG5bYnVpbGQgc2NyaXB0XShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9idWlsZC1zY3JpcHRzLmh0bWwpIHRoYXQgZG9lcyBub3QgZW1pdCBhbnkgYHJlcnVuLWlmLSpgIGRpcmVjdGl2ZXMsIHRoZW4gdGhlXG5pbmNsdWRlL2V4Y2x1ZGUgbGlzdCBpcyB1c2VkIGZvciB0cmFja2luZyBpZiB0aGUgYnVpbGQgc2NyaXB0IHNob3VsZCBiZSByZS1ydW5cbmlmIGFueSBvZiB0aG9zZSBmaWxlcyBjaGFuZ2UuIiwKICAgICAgInR5cGUiOiAiYXJyYXkiLAogICAgICAiaXRlbXMiOiB7CiAgICAgICAgImRlc2NyaXB0aW9uIjogIllvdSBjYW4gZXhwbGljaXRseSBzcGVjaWZ5IHRoYXQgYSBzZXQgb2YgZmlsZSBwYXR0ZXJucyBzaG91bGQgYmUgaWdub3JlZCBvclxuaW5jbHVkZWQgZm9yIHRoZSBwdXJwb3NlcyBvZiBwYWNrYWdpbmcuIFRoZSBwYXR0ZXJucyBzcGVjaWZpZWQgaW4gdGhlXG5gZXhjbHVkZWAgZmllbGQgaWRlbnRpZnkgYSBzZXQgb2YgZmlsZXMgdGhhdCBhcmUgbm90IGluY2x1ZGVkLCBhbmQgdGhlXG5wYXR0ZXJucyBpbiBgaW5jbHVkZWAgc3BlY2lmeSBmaWxlcyB0aGF0IGFyZSBleHBsaWNpdGx5IGluY2x1ZGVkLlxuXG5UaGUgcGF0dGVybnMgc2hvdWxkIGJlIFtnaXRpZ25vcmVdKGh0dHBzOi8vZ2l0LXNjbS5jb20vZG9jcy9naXRpZ25vcmUpLXN0eWxlIHBhdHRlcm5zLiBCcmllZmx5OlxuXG4tIGBmb29gIG1hdGNoZXMgYW55IGZpbGUgb3IgZGlyZWN0b3J5IHdpdGggdGhlIG5hbWUgYGZvb2AgYW55d2hlcmUgaW4gdGhlXG4gIHBhY2thZ2UuIFRoaXMgaXMgZXF1aXZhbGVudCB0byB0aGUgcGF0dGVybiBgKiovZm9vYC5cbi0gYC9mb29gIG1hdGNoZXMgYW55IGZpbGUgb3IgZGlyZWN0b3J5IHdpdGggdGhlIG5hbWUgYGZvb2Agb25seSBpbiB0aGUgcm9vdCBvZlxuICB0aGUgcGFja2FnZS5cbi0gYGZvby9gIG1hdGNoZXMgYW55ICpkaXJlY3RvcnkqIHdpdGggdGhlIG5hbWUgYGZvb2AgYW55d2hlcmUgaW4gdGhlIHBhY2thZ2UuXG4tIENvbW1vbiBnbG9iIHBhdHRlcm5zIGxpa2UgYCpgLCBgP2AsIGFuZCBgW11gIGFyZSBzdXBwb3J0ZWQ6XG4gIC0gYCpgIG1hdGNoZXMgemVybyBvciBtb3JlIGNoYXJhY3RlcnMgZXhjZXB0IGAvYC4gIEZvciBleGFtcGxlLCBgKi5odG1sYFxuICAgIG1hdGNoZXMgYW55IGZpbGUgb3IgZGlyZWN0b3J5IHdpdGggdGhlIGAuaHRtbGAgZXh0ZW5zaW9uIGFueXdoZXJlIGluIHRoZVxuICAgIHBhY2thZ2UuXG4gIC0gYD9gIG1hdGNoZXMgYW55IGNoYXJhY3RlciBleGNlcHQgYC9gLiBGb3IgZXhhbXBsZSwgYGZvbz9gIG1hdGNoZXMgYGZvb2RgLFxuICAgIGJ1dCBub3QgYGZvb2AuXG4gIC0gYFtdYCBhbGxvd3MgZm9yIG1hdGNoaW5nIGEgcmFuZ2Ugb2YgY2hhcmFjdGVycy4gRm9yIGV4YW1wbGUsIGBbYWJdYFxuICAgIG1hdGNoZXMgZWl0aGVyIGBhYCBvciBgYmAuIGBbYS16XWAgbWF0Y2hlcyBsZXR0ZXJzIGEgdGhyb3VnaCB6LlxuLSBgKiovYCBwcmVmaXggbWF0Y2hlcyBpbiBhbnkgZGlyZWN0b3J5LiBGb3IgZXhhbXBsZSwgYCoqL2Zvby9iYXJgIG1hdGNoZXMgdGhlXG4gIGZpbGUgb3IgZGlyZWN0b3J5IGBiYXJgIGFueXdoZXJlIHRoYXQgaXMgZGlyZWN0bHkgdW5kZXIgZGlyZWN0b3J5IGBmb29gLlxuLSBgLyoqYCBzdWZmaXggbWF0Y2hlcyBldmVyeXRoaW5nIGluc2lkZS4gRm9yIGV4YW1wbGUsIGBmb28vKipgIG1hdGNoZXMgYWxsXG4gIGZpbGVzIGluc2lkZSBkaXJlY3RvcnkgYGZvb2AsIGluY2x1ZGluZyBhbGwgZmlsZXMgaW4gc3ViZGlyZWN0b3JpZXMgYmVsb3dcbiAgYGZvb2AuXG4tIGAvKiovYCBtYXRjaGVzIHplcm8gb3IgbW9yZSBkaXJlY3Rvcmllcy4gRm9yIGV4YW1wbGUsIGBhLyoqL2JgIG1hdGNoZXNcbiAgYGEvYmAsIGBhL3gvYmAsIGBhL3gveS9iYCwgYW5kIHNvIG9uLlxuLSBgIWAgcHJlZml4IG5lZ2F0ZXMgYSBwYXR0ZXJuLiBGb3IgZXhhbXBsZSwgYSBwYXR0ZXJuIG9mIGBzcmMvKioucnNgIGFuZFxuICBgIWZvby5yc2Agd291bGQgbWF0Y2ggYWxsIGZpbGVzIHdpdGggdGhlIGAucnNgIGV4dGVuc2lvbiBpbnNpZGUgdGhlIGBzcmNgXG4gIGRpcmVjdG9yeSwgZXhjZXB0IGZvciBhbnkgZmlsZSBuYW1lZCBgZm9vLnJzYC5cblxuSWYgZ2l0IGlzIGJlaW5nIHVzZWQgZm9yIGEgcGFja2FnZSwgdGhlIGBleGNsdWRlYCBmaWVsZCB3aWxsIGJlIHNlZWRlZCB3aXRoXG50aGUgYGdpdGlnbm9yZWAgc2V0dGluZ3MgZnJvbSB0aGUgcmVwb3NpdG9yeS5cblxuYGBgdG9tbFxuW3BhY2thZ2VdXG4jIC4uLlxuZXhjbHVkZSA9IFtcImJ1aWxkLyoqLyoub1wiLCBcImRvYy8qKi8qLmh0bWxcIl1cbmBgYFxuXG5gYGB0b21sXG5bcGFja2FnZV1cbiMgLi4uXG5pbmNsdWRlID0gW1wic3JjLyoqLypcIiwgXCJDYXJnby50b21sXCJdXG5gYGBcblxuVGhlIG9wdGlvbnMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZTogc2V0dGluZyBgaW5jbHVkZWAgd2lsbCBvdmVycmlkZSBhblxuYGV4Y2x1ZGVgLiBOb3RlIHRoYXQgYGluY2x1ZGVgIG11c3QgYmUgYW4gZXhoYXVzdGl2ZSBsaXN0IG9mIGZpbGVzIGFzIG90aGVyd2lzZVxubmVjZXNzYXJ5IHNvdXJjZSBmaWxlcyBtYXkgbm90IGJlIGluY2x1ZGVkLiBUaGUgcGFja2FnZSdzIGBDYXJnby50b21sYCBpc1xuYXV0b21hdGljYWxseSBpbmNsdWRlZC5cblxuVGhlIGluY2x1ZGUvZXhjbHVkZSBsaXN0IGlzIGFsc28gdXNlZCBmb3IgY2hhbmdlIHRyYWNraW5nIGluIHNvbWUgc2l0dWF0aW9ucy5cbkZvciB0YXJnZXRzIGJ1aWx0IHdpdGggYHJ1c3Rkb2NgLCBpdCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgbGlzdCBvZiBmaWxlcyB0b1xudHJhY2sgdG8gZGV0ZXJtaW5lIGlmIHRoZSB0YXJnZXQgc2hvdWxkIGJlIHJlYnVpbHQuIElmIHRoZSBwYWNrYWdlIGhhcyBhXG5bYnVpbGQgc2NyaXB0XShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9idWlsZC1zY3JpcHRzLmh0bWwpIHRoYXQgZG9lcyBub3QgZW1pdCBhbnkgYHJlcnVuLWlmLSpgIGRpcmVjdGl2ZXMsIHRoZW4gdGhlXG5pbmNsdWRlL2V4Y2x1ZGUgbGlzdCBpcyB1c2VkIGZvciB0cmFja2luZyBpZiB0aGUgYnVpbGQgc2NyaXB0IHNob3VsZCBiZSByZS1ydW5cbmlmIGFueSBvZiB0aG9zZSBmaWxlcyBjaGFuZ2UuIiwKICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL21hbmlmZXN0Lmh0bWwjdGhlLWV4Y2x1ZGUtYW5kLWluY2x1ZGUtZmllbGRzIgogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9tYW5pZmVzdC5odG1sI3RoZS1leGNsdWRlLWFuZC1pbmNsdWRlLWZpZWxkcyIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAiS2V5d29yZHMiOiB7CiAgICAgICJ0aXRsZSI6ICJLZXl3b3JkcyIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYGtleXdvcmRzYCBmaWVsZCBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgZGVzY3JpYmUgdGhpcyBwYWNrYWdlLiBUaGlzXG5jYW4gaGVscCB3aGVuIHNlYXJjaGluZyBmb3IgdGhlIHBhY2thZ2Ugb24gYSByZWdpc3RyeSwgYW5kIHlvdSBtYXkgY2hvb3NlIGFueVxud29yZHMgdGhhdCB3b3VsZCBoZWxwIHNvbWVvbmUgZmluZCB0aGlzIGNyYXRlLlxuXG5gYGB0b21sXG5bcGFja2FnZV1cbiMgLi4uXG5rZXl3b3JkcyA9IFtcImdhbWVkZXZcIiwgXCJncmFwaGljc1wiXVxuYGBgXG5cbj4gKipOb3RlKio6IFtjcmF0ZXMuaW9dKGh0dHBzOi8vY3JhdGVzLmlvKSBoYXMgYSBtYXhpbXVtIG9mIDUga2V5d29yZHMuIEVhY2gga2V5d29yZCBtdXN0IGJlXG4\u002BIEFTQ0lJIHRleHQsIHN0YXJ0IHdpdGggYSBsZXR0ZXIsIGFuZCBvbmx5IGNvbnRhaW4gbGV0dGVycywgbnVtYmVycywgYF9gIG9yXG4\u002BIGAtYCwgYW5kIGhhdmUgYXQgbW9zdCAyMCBjaGFyYWN0ZXJzLiIsCiAgICAgICJ0eXBlIjogImFycmF5IiwKICAgICAgIml0ZW1zIjogewogICAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYGtleXdvcmRzYCBmaWVsZCBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgZGVzY3JpYmUgdGhpcyBwYWNrYWdlLiBUaGlzXG5jYW4gaGVscCB3aGVuIHNlYXJjaGluZyBmb3IgdGhlIHBhY2thZ2Ugb24gYSByZWdpc3RyeSwgYW5kIHlvdSBtYXkgY2hvb3NlIGFueVxud29yZHMgdGhhdCB3b3VsZCBoZWxwIHNvbWVvbmUgZmluZCB0aGlzIGNyYXRlLlxuXG5gYGB0b21sXG5bcGFja2FnZV1cbiMgLi4uXG5rZXl3b3JkcyA9IFtcImdhbWVkZXZcIiwgXCJncmFwaGljc1wiXVxuYGBgXG5cbj4gKipOb3RlKio6IFtjcmF0ZXMuaW9dKGh0dHBzOi8vY3JhdGVzLmlvKSBoYXMgYSBtYXhpbXVtIG9mIDUga2V5d29yZHMuIEVhY2gga2V5d29yZCBtdXN0IGJlXG4\u002BIEFTQ0lJIHRleHQsIHN0YXJ0IHdpdGggYSBsZXR0ZXIsIGFuZCBvbmx5IGNvbnRhaW4gbGV0dGVycywgbnVtYmVycywgYF9gIG9yXG4\u002BIGAtYCwgYW5kIGhhdmUgYXQgbW9zdCAyMCBjaGFyYWN0ZXJzLiIsCiAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9tYW5pZmVzdC5odG1sI3RoZS1rZXl3b3Jkcy1maWVsZCIKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvbWFuaWZlc3QuaHRtbCN0aGUta2V5d29yZHMtZmllbGQiCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgIkxpY2Vuc2UiOiB7CiAgICAgICJ0aXRsZSI6ICJMaWNlbnNlIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgbGljZW5zZWAgZmllbGQgY29udGFpbnMgdGhlIG5hbWUgb2YgdGhlIHNvZnR3YXJlIGxpY2Vuc2UgdGhhdCB0aGUgcGFja2FnZVxuaXMgcmVsZWFzZWQgdW5kZXIuXG5cbltjcmF0ZXMuaW9dKGh0dHBzOi8vY3JhdGVzLmlvLykgaW50ZXJwcmV0cyB0aGUgYGxpY2Vuc2VgIGZpZWxkIGFzIGFuIFtTUERYIDIuMSBsaWNlbnNlXG5leHByZXNzaW9uXShodHRwczovL3NwZHgub3JnL3NwZHgtc3BlY2lmaWNhdGlvbi0yMS13ZWItdmVyc2lvbiNoLmp4cGZ4MHlreWI2MCkuIFRoZSBuYW1lIG11c3QgYmUgYSBrbm93biBsaWNlbnNlXG5mcm9tIHRoZSBbU1BEWCBsaWNlbnNlIGxpc3QgMy42XShodHRwczovL2dpdGh1Yi5jb20vc3BkeC9saWNlbnNlLWxpc3QtZGF0YS90cmVlL3YzLjYpLiBQYXJlbnRoZXNlcyBhcmUgbm90XG5jdXJyZW50bHkgc3VwcG9ydGVkLiBTZWUgdGhlIFtTUERYIHNpdGVdKGh0dHBzOi8vc3BkeC5vcmcvbGljZW5zZS1saXN0KSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuU1BEWCBsaWNlbnNlIGV4cHJlc3Npb25zIHN1cHBvcnQgQU5EIGFuZCBPUiBvcGVyYXRvcnMgdG8gY29tYmluZSBtdWx0aXBsZVxubGljZW5zZXMuXG5cbmBgYHRvbWxcbltwYWNrYWdlXVxuIyAuLi5cbmxpY2Vuc2UgPSBcIk1JVCBPUiBBcGFjaGUtMi4wXCJcbmBgYFxuXG5Vc2luZyBgT1JgIGluZGljYXRlcyB0aGUgdXNlciBtYXkgY2hvb3NlIGVpdGhlciBsaWNlbnNlLiBVc2luZyBgQU5EYCBpbmRpY2F0ZXNcbnRoZSB1c2VyIG11c3QgY29tcGx5IHdpdGggYm90aCBsaWNlbnNlcyBzaW11bHRhbmVvdXNseS4gVGhlIGBXSVRIYCBvcGVyYXRvclxuaW5kaWNhdGVzIGEgbGljZW5zZSB3aXRoIGEgc3BlY2lhbCBleGNlcHRpb24uIFNvbWUgZXhhbXBsZXM6XG5cbiogYE1JVCBPUiBBcGFjaGUtMi4wYFxuKiBgTEdQTC0yLjEgQU5EIE1JVCBBTkQgQlNELTItQ2xhdXNlYFxuKiBgR1BMLTIuMCsgV0lUSCBCaXNvbi1leGNlcHRpb24tMi4yYFxuXG5JZiBhIHBhY2thZ2UgaXMgdXNpbmcgYSBub25zdGFuZGFyZCBsaWNlbnNlLCB0aGVuIHRoZSBgbGljZW5zZS1maWxlYCBmaWVsZCBtYXlcbmJlIHNwZWNpZmllZCBpbiBsaWV1IG9mIHRoZSBgbGljZW5zZWAgZmllbGQuIiwKICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9tYW5pZmVzdC5odG1sI3RoZS1saWNlbnNlLWFuZC1saWNlbnNlLWZpbGUtZmllbGRzIgogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJMaWNlbnNlRmlsZSI6IHsKICAgICAgInRpdGxlIjogIkxpY2Vuc2VGaWxlIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRoZSBgbGljZW5zZS1maWxlYCBmaWVsZCBjb250YWlucyB0aGUgcGF0aCB0byBhIGZpbGVcbmNvbnRhaW5pbmcgdGhlIHRleHQgb2YgdGhlIGxpY2Vuc2UgKHJlbGF0aXZlIHRvIHRoaXMgYENhcmdvLnRvbWxgKS5cblxuYGBgdG9tbFxuW3BhY2thZ2VdXG4jIC4uLlxubGljZW5zZS1maWxlID0gXCJMSUNFTlNFLnR4dFwiXG5gYGBcblxuPiAqKk5vdGUqKjogW2NyYXRlcy5pb10oaHR0cHM6Ly9jcmF0ZXMuaW8pIHJlcXVpcmVzIGVpdGhlciBgbGljZW5zZWAgb3IgYGxpY2Vuc2UtZmlsZWAgdG8gYmUgc2V0LiIsCiAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvbWFuaWZlc3QuaHRtbCN0aGUtbGljZW5zZS1hbmQtbGljZW5zZS1maWxlLWZpZWxkcyIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAiUmVwb3NpdG9yeSI6IHsKICAgICAgInRpdGxlIjogIlJlcG9zaXRvcnkiLAogICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGByZXBvc2l0b3J5YCBmaWVsZCBzaG91bGQgYmUgYSBVUkwgdG8gdGhlIHNvdXJjZSByZXBvc2l0b3J5IGZvciB5b3VyXG5wYWNrYWdlLlxuXG5gYGB0b21sXG5bcGFja2FnZV1cbiMgLi4uXG5yZXBvc2l0b3J5ID0gXCJodHRwczovL2dpdGh1Yi5jb20vcnVzdC1sYW5nL2NhcmdvL1wiXG5gYGAiLAogICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAieC10YXBsbyI6IHsKICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL21hbmlmZXN0Lmh0bWwjdGhlLXJlcG9zaXRvcnktZmllbGQiCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgIlJ1c3RWZXJzaW9uIjogewogICAgICAidGl0bGUiOiAiUnVzdFZlcnNpb24iLAogICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGBydXN0LXZlcnNpb25gIGZpZWxkIGlzIGFuIG9wdGlvbmFsIGtleSB0aGF0IHRlbGxzIGNhcmdvIHdoYXQgdmVyc2lvbiBvZiB0aGVcblJ1c3QgbGFuZ3VhZ2UgYW5kIGNvbXBpbGVyIHlvdXIgcGFja2FnZSBjYW4gYmUgY29tcGlsZWQgd2l0aC4gSWYgdGhlIGN1cnJlbnRseVxuc2VsZWN0ZWQgdmVyc2lvbiBvZiB0aGUgUnVzdCBjb21waWxlciBpcyBvbGRlciB0aGFuIHRoZSBzdGF0ZWQgdmVyc2lvbiwgY2FyZ29cbndpbGwgZXhpdCB3aXRoIGFuIGVycm9yLCB0ZWxsaW5nIHRoZSB1c2VyIHdoYXQgdmVyc2lvbiBpcyByZXF1aXJlZC5cblxuVGhlIGZpcnN0IHZlcnNpb24gb2YgQ2FyZ28gdGhhdCBzdXBwb3J0cyB0aGlzIGZpZWxkIHdhcyByZWxlYXNlZCB3aXRoIFJ1c3QgMS41Ni4wLlxuSW4gb2xkZXIgcmVsZWFzZXMsIHRoZSBmaWVsZCB3aWxsIGJlIGlnbm9yZWQsIGFuZCBDYXJnbyB3aWxsIGRpc3BsYXkgYSB3YXJuaW5nLlxuXG5gYGB0b21sXG5bcGFja2FnZV1cbiMgLi4uXG5ydXN0LXZlcnNpb24gPSBcIjEuNTZcIlxuYGBgXG5cblRoZSBSdXN0IHZlcnNpb24gbXVzdCBiZSBhIGJhcmUgdmVyc2lvbiBudW1iZXIgd2l0aCB0d28gb3IgdGhyZWUgY29tcG9uZW50czsgaXRcbmNhbm5vdCBpbmNsdWRlIHNlbXZlciBvcGVyYXRvcnMgb3IgcHJlLXJlbGVhc2UgaWRlbnRpZmllcnMuIENvbXBpbGVyIHByZS1yZWxlYXNlXG5pZGVudGlmaWVycyBzdWNoIGFzIC1uaWdodGx5IHdpbGwgYmUgaWdub3JlZCB3aGlsZSBjaGVja2luZyB0aGUgUnVzdCB2ZXJzaW9uLlxuVGhlIGBydXN0LXZlcnNpb25gIG11c3QgYmUgZXF1YWwgdG8gb3IgbmV3ZXIgdGhhbiB0aGUgdmVyc2lvbiB0aGF0IGZpcnN0XG5pbnRyb2R1Y2VkIHRoZSBjb25maWd1cmVkIGBlZGl0aW9uYC5cblxuVGhlIGBydXN0LXZlcnNpb25gIG1heSBiZSBpZ25vcmVkIHVzaW5nIHRoZSBgLS1pZ25vcmUtcnVzdC12ZXJzaW9uYCBvcHRpb24uXG5cblNldHRpbmcgdGhlIGBydXN0LXZlcnNpb25gIGtleSBpbiBgW3BhY2thZ2VdYCB3aWxsIGFmZmVjdCBhbGwgdGFyZ2V0cy9jcmF0ZXMgaW5cbnRoZSBwYWNrYWdlLCBpbmNsdWRpbmcgdGVzdCBzdWl0ZXMsIGJlbmNobWFya3MsIGJpbmFyaWVzLCBleGFtcGxlcywgZXRjLiIsCiAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvbWFuaWZlc3QuaHRtbCN0aGUtcnVzdC12ZXJzaW9uLWZpZWxkIgogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJXb3Jrc3BhY2VJbmhlcml0YW5jZSI6IHsKICAgICAgInRpdGxlIjogIldvcmtzcGFjZSIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgYHdvcmtzcGFjZWAgZmllbGQgYWxsb3cga2V5cyB0byBiZSBpbmhlcml0ZWQgYnkgZGVmaW5pbmcgdGhlbSBpbiB0aGUgbWVtYmVyIHBhY2thZ2Ugd2l0aCBge2tleX0ud29ya3NwYWNlID0gdHJ1ZWAiLAogICAgICAidHlwZSI6ICJvYmplY3QiLAogICAgICAicHJvcGVydGllcyI6IHsKICAgICAgICAid29ya3NwYWNlIjogewogICAgICAgICAgInR5cGUiOiAiYm9vbGVhbiIsCiAgICAgICAgICAiZW51bSI6IFt0cnVlXQogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJQbGF5ZGF0ZU1ldGFkYXRhIjogewogICAgICAidGl0bGUiOiAiUGxheWRhdGUgUGFja2FnZSBNZXRhZGF0YSIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJNZXRhZGF0YSBhbmQgYnVpbGQgY29uZmlndXJhdGlvbi4iLAogICAgICAidHlwZSI6ICJvYmplY3QiLAogICAgICAicmVxdWlyZWQiOiBbImJ1bmRsZS1pZCJdLAogICAgICAicHJvcGVydGllcyI6IHsKICAgICAgICAiYnVuZGxlLWlkIjogewogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB5b3VyIGdhbWUsIGluIHJldmVyc2UgRE5TIG5vdGF0aW9uLiIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9zZGsucGxheS5kYXRlLyNwZHhpbmZvIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAibmFtZSI6IHsKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiQSBnYW1lIHZlcnNpb24gbnVtYmVyLCBmb3JtYXR0ZWQgYW55IHdheSB5b3Ugd2lzaCwgdGhhdCBpcyBkaXNwbGF5ZWQgdG8gcGxheWVycy4gSXQgaXMgbm90IHVzZWQgdG8gY29tcHV0ZSB3aGVuIHVwZGF0ZXMgc2hvdWxkIG9jY3VyLiIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9zZGsucGxheS5kYXRlLyNwZHhpbmZvIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiYXV0aG9yIjogewogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL3Nkay5wbGF5LmRhdGUvI3BkeGluZm8iCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICJkZXNjcmlwdGlvbiI6IHsKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9zZGsucGxheS5kYXRlLyNwZHhpbmZvIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAidmVyc2lvbiI6IHsKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9zZGsucGxheS5kYXRlLyNwZHhpbmZvIgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAiYnVpbGQtbnVtYmVyIjogewogICAgICAgICAgInR5cGUiOiAiaW50ZWdlciIsCiAgICAgICAgICAiZXhjbHVzaXZlTWluaW11bSI6IDAsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9zZGsucGxheS5kYXRlLyNwZHhpbmZvIgogICAgICAgICAgICB9CiAgICAgICAgICB9LAogICAgICAgICAgImRlc2NyaXB0aW9uIjogIkEgbW9ub3RvbmljYWxseS1pbmNyZWFzaW5nIGludGVnZXIgdmFsdWUgdXNlZCB0byBpbmRpY2F0ZSBhIHVuaXF1ZSB2ZXJzaW9uIG9mIHlvdXIgZ2FtZS4gVGhpcyBjYW4gYmUgc2V0IHVzaW5nIGFuIGF1dG9tYXRlZCBidWlsZCBwcm9jZXNzIGxpa2UgQ29udGludW91cyBJbnRlZ3JhdGlvbiB0byBhdm9pZCBoYXZpbmcgdG8gc2V0IHRoZSB2YWx1ZSBieSBoYW5kLlxuXG5Gb3Igc2lkZWxvYWRlZCBnYW1lcywgYnVpbGROdW1iZXIgaXMgcmVxdWlyZWQgYW5kIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZW4gYSBuZXdlciB2ZXJzaW9uIGlzIGF2YWlsYWJsZSB0byBkb3dubG9hZC4iCiAgICAgICAgfSwKICAgICAgICAiaW1hZ2UtcGF0aCI6IHsKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9zZGsucGxheS5kYXRlLyNwZHhpbmZvIgogICAgICAgICAgICB9CiAgICAgICAgICB9LAogICAgICAgICAgImRlc2NyaXB0aW9uIjogIkEgZGlyZWN0b3J5IG9mIGltYWdlcyB0aGF0IHdpbGwgYmUgdXNlZCBieSB0aGUgbGF1bmNoZXIuXG5cbk1vcmUgaW4gW29mZmljaWFsIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vc2RrLnBsYXkuZGF0ZS8jcGR4aW5mbykuIgogICAgICAgIH0sCiAgICAgICAgImxhdW5jaC1zb3VuZC1wYXRoIjogewogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL3Nkay5wbGF5LmRhdGUvI3BkeGluZm8iCiAgICAgICAgICAgIH0KICAgICAgICAgIH0sCiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiU2hvdWxkIHBvaW50IHRvIHRoZSBwYXRoIG9mIGEgc2hvcnQgYXVkaW8gZmlsZSB0byBiZSBwbGF5ZWQgYXMgdGhlIGdhbWUgbGF1bmNoIGFuaW1hdGlvbiBpcyB0YWtpbmcgcGxhY2UuXG5cbk1vcmUgaW4gW29mZmljaWFsIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vc2RrLnBsYXkuZGF0ZS8jcGR4aW5mbykuIgogICAgICAgIH0sCiAgICAgICAgImNvbnRlbnQtd2FybmluZyI6IHsKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9zZGsucGxheS5kYXRlLyNwZHhpbmZvIgogICAgICAgICAgICB9CiAgICAgICAgICB9LAogICAgICAgICAgImRlc2NyaXB0aW9uIjogIk9wdGlvbmFsLiBBIGNvbnRlbnQgd2FybmluZyB0aGF0IGRpc3BsYXlzIHdoZW4gdGhlIHVzZXIgbGF1bmNoZXMgeW91ciBnYW1lIGZvciB0aGUgZmlyc3QgdGltZS4gVGhlIHVzZXIgd2lsbCBoYXZlIHRoZSBvcHRpb24gb2YgYmFja2luZyBvdXQgYW5kIG5vdCBsYXVuY2hpbmcgeW91ciBnYW1lIGlmIHRoZXkgY2hvb3NlLiIKICAgICAgICB9LAogICAgICAgICJjb250ZW50LXdhcm5pbmcyIjogewogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICAgImtleSI6ICJodHRwczovL3Nkay5wbGF5LmRhdGUvI3BkeGluZm8iCiAgICAgICAgICAgIH0KICAgICAgICAgIH0sCiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiT3B0aW9uYWwuIEEgc2Vjb25kIGNvbnRlbnQgd2FybmluZyB0aGF0IGRpc3BsYXlzIG9uIGEgc2Vjb25kIHNjcmVlbiB3aGVuIHRoZSB1c2VyIGxhdW5jaGVzIHlvdXIgZ2FtZSBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoZSB1c2VyIHdpbGwgaGF2ZSB0aGUgb3B0aW9uIG9mIGJhY2tpbmcgb3V0IGFuZCBub3QgbGF1bmNoaW5nIHlvdXIgZ2FtZSBpZiB0aGV5IGNob29zZS5cblxuTm90ZTogYGNvbnRlbnQtd2FybmluZzJgIHdpbGwgb25seSBkaXNwbGF5IGlmIGEgYGNvbnRlbnQtd2FybmluZ2AgYXR0cmlidXRlIGlzIGFsc28gc3BlY2lmaWVkLlxuXG5UaGUgc3RyaW5nIGRpc3BsYXllZCBvbiB0aGUgY29udGVudCB3YXJuaW5nIHNjcmVlbiBjYW4gb25seSBiZSBzbyBsb25nIGJlZm9yZSBpdCB3aWxsIGJlIHRydW5jYXRlZCB3aXRoIGFuIFwi4oCmXCIgY2hhcmFjdGVyLiBCZSBzdXJlIHRvIGtlZXAgdGhpcyBpbiBtaW5kIHdoZW4gZGVzaWduaW5nIHlvdXIgYGNvbnRlbnQtd2FybmluZ2AgYW5kIGBjb250ZW50LXdhcm5pbmcyYCB0ZXh0LiIKICAgICAgICB9LAogICAgICAgICJhc3NldHMiOiB7CiAgICAgICAgICAiYW55T2YiOiBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1BsYXlkYXRlTWV0YWRhdGFBc3NldHNNYXAiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1BsYXlkYXRlTWV0YWRhdGFBc3NldHNBcnJheSIKICAgICAgICAgICAgfQogICAgICAgICAgXQogICAgICAgIH0sCiAgICAgICAgImRldi1hc3NldHMiOiB7CiAgICAgICAgICAiYW55T2YiOiBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1BsYXlkYXRlTWV0YWRhdGFBc3NldHNNYXAiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1BsYXlkYXRlTWV0YWRhdGFBc3NldHNBcnJheSIKICAgICAgICAgICAgfQogICAgICAgICAgXQogICAgICAgIH0sCiAgICAgICAgIm9wdGlvbnMiOiB7CiAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1BsYXlkYXRlTWV0YWRhdGFPcHRpb25zIgogICAgICAgIH0sCiAgICAgICAgInN1cHBvcnQiOiB7CiAgICAgICAgICAidHlwZSI6ICJvYmplY3QiLAogICAgICAgICAgInByb3BlcnRpZXMiOiB7fSwKICAgICAgICAgICJhZGRpdGlvbmFsUHJvcGVydGllcyI6IHRydWUKICAgICAgICB9CiAgICAgIH0sCiAgICAgICJhZGRpdGlvbmFsUHJvcGVydGllcyI6IGZhbHNlLAogICAgICAieC10YXBsbyI6IHsKICAgICAgICAiaW5pdEtleXMiOiBbCiAgICAgICAgICAiYnVuZGxlLWlkIiwKICAgICAgICAgICJuYW1lIiwKICAgICAgICAgICJkZXNjcmlwdGlvbiIsCiAgICAgICAgICAiYXV0aG9yIiwKICAgICAgICAgICJpbWFnZS1wYXRoIiwKICAgICAgICAgICJsYXVuY2gtc291bmQtcGF0aCIKICAgICAgICBdLAogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9zZGsucGxheS5kYXRlLyNwZHhpbmZvIgogICAgICAgIH0KICAgICAgfSwKICAgICAgIngtdGFwbG8taW5mbyI6IHsKICAgICAgICAiYXV0aG9ycyI6IFsiQWxleCBLb3ouIChodHRwczovL2dpdGh1Yi5jb20vYm9vem9vaykiXQogICAgICB9CiAgICB9LAogICAgIlBsYXlkYXRlTWV0YWRhdGFBc3NldHNBcnJheSI6IHsKICAgICAgInR5cGUiOiAiYXJyYXkiLAogICAgICAidGl0bGUiOiAiQXNzZXRzIGxpc3QiLAogICAgICAiZGVzY3JpcHRpb24iOiAiTGlzdCBvZiBwYXRocyB0byBpbmNsdWRlLiIsCiAgICAgICJ1bmlxdWVJdGVtcyI6IHRydWUsCiAgICAgICJpdGVtcyI6IHsKICAgICAgICAidGl0bGUiOiAiUGF0aCIsCiAgICAgICAgImRlc2NyaXB0aW9uIjogIlBhdGggdG8gaW5jbHVkZS4iLAogICAgICAgICJ0eXBlIjogInN0cmluZyIKICAgICAgfSwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2dpdGh1Yi5jb20vYm9vem9vay9wbGF5ZGF0ZS9ibG9iL21haW4vc3VwcG9ydC9idWlsZC9SRUFETUUubWQjYXNzZXRzLWxpc3QiCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgIlBsYXlkYXRlTWV0YWRhdGFBc3NldHNNYXAiOiB7CiAgICAgICJ0eXBlIjogIm9iamVjdCIsCiAgICAgICJ0aXRsZSI6ICJBc3NldHMgcnVsZXMiLAogICAgICAiZGVzY3JpcHRpb24iOiAiUnVsZXMgdXNlZCB0byByZXNvbHZlIHBhdGhzIHRvIGluY2x1ZGUuIiwKICAgICAgInByb3BlcnRpZXMiOiB7CiAgICAgICAgIm9wdGlvbnMiOiB7CiAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1BsYXlkYXRlTWV0YWRhdGFBc3NldHNPcHRpb25zIgogICAgICAgIH0KICAgICAgfSwKICAgICAgImFkZGl0aW9uYWxQcm9wZXJ0aWVzIjogewogICAgICAgICJhbnlPZiI6IFsKICAgICAgICAgIHsKICAgICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICAgInRpdGxlIjogIlBhdGgiLAogICAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiUGF0aCBvZiBmaWxlcyB0byBpbmNsdWRlLiBDYW4gYmUgYWJzb2x1dGUsIHJlbGF0aXZlIHRvIHRoZSBjcmF0ZSByb290LCBvci9hbmQgZ2xvYi5cblxuTGVmdCBoYW5kIGlzIHdoZXJlIHRvIHB1dCBmaWxlcywgcGF0aCBpbiB0aGUgcmVzdWx0aW5nIHBhY2thZ2UuXG5cblJpZ2h0IGhhbmQgaXMgYSBwYXRoIG9yIHBhdHRlcm4gdG8gbWF0Y2ggZmlsZXMgdG8gaW5jbHVkZS4iCiAgICAgICAgICB9LAogICAgICAgICAgewogICAgICAgICAgICAidHlwZSI6ICJib29sZWFuIiwKICAgICAgICAgICAgInRpdGxlIjogIkluY2x1ZGUiLAogICAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiSW5jbHVkZSBvciBleGNsdWRlIHRoZSBmaWxlIG9yIGdsb2ItcGF0dGVybi4iCiAgICAgICAgICB9CiAgICAgICAgXQogICAgICB9LAogICAgICAieC10YXBsbyI6IHsKICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAia2V5IjogImh0dHBzOi8vZ2l0aHViLmNvbS9ib296b29rL3BsYXlkYXRlL2Jsb2IvbWFpbi9zdXBwb3J0L2J1aWxkL1JFQURNRS5tZCNhc3NldHMtdGFibGUiCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgIlBsYXlkYXRlTWV0YWRhdGFBc3NldHNPcHRpb25zIjogewogICAgICAidHlwZSI6ICJvYmplY3QiLAogICAgICAidGl0bGUiOiAiQXNzZXRzIENvbmZpZ3VyYXRpb24iLAogICAgICAiZGVzY3JpcHRpb24iOiAiT3B0aW9ucyBmb3IgYXNzZXRzIHBhdGhzIHJlc29sdXRpb24gYW5kIGhvdyB0byBidWlsZCBhc3NldHMgY29sbGVjdGlvbiIsCiAgICAgICJhZGRpdGlvbmFsUHJvcGVydGllcyI6IGZhbHNlLAogICAgICAicHJvcGVydGllcyI6IHsKICAgICAgICAib3ZlcndyaXRlIjogewogICAgICAgICAgInR5cGUiOiAiYm9vbGVhbiIsCiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiQWxsb3cgb3ZlcndyaXRpbmcgZXhpc3RpbmcgZmlsZXMuIgogICAgICAgIH0sCiAgICAgICAgImZvbGxvdy1zeW1saW5rcyI6IHsKICAgICAgICAgICJ0eXBlIjogImJvb2xlYW4iCiAgICAgICAgfSwKICAgICAgICAibWV0aG9kIjogewogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJlbnVtIjogWyJjb3B5IiwgImxpbmsiXQogICAgICAgIH0sCiAgICAgICAgImRlcGVuZGVuY2llcyI6IHsKICAgICAgICAgICJ0eXBlIjogImJvb2xlYW4iLAogICAgICAgICAgImRlc2NyaXB0aW9uIjogIkFsbG93IGJ1aWxkIGFzc2V0cyBmb3IgZGVwZW5kZW5jaWVzLiIKICAgICAgICB9CiAgICAgIH0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9naXRodWIuY29tL2Jvb3pvb2svcGxheWRhdGUvYmxvYi9tYWluL3N1cHBvcnQvYnVpbGQvUkVBRE1FLm1kI2Fzc2V0cy1vcHRpb25zIgogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJQbGF5ZGF0ZU1ldGFkYXRhT3B0aW9ucyI6IHsKICAgICAgInR5cGUiOiAib2JqZWN0IiwKICAgICAgInRpdGxlIjogIkNvbmZpZ3VyYXRpb24iLAogICAgICAiZGVzY3JpcHRpb24iOiAiUGFja2FnZSBidWlsZCBvcHRpb25zLiIsCiAgICAgICJhZGRpdGlvbmFsUHJvcGVydGllcyI6IHRydWUsCiAgICAgICJwcm9wZXJ0aWVzIjogewogICAgICAgICJhc3NldHMiOiB7CiAgICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1BsYXlkYXRlTWV0YWRhdGFBc3NldHNPcHRpb25zIgogICAgICAgIH0KICAgICAgfSwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2dpdGh1Yi5jb20vYm9vem9vay9wbGF5ZGF0ZS9ibG9iL21haW4vc3VwcG9ydC9idWlsZC9SRUFETUUubWQjb3B0aW9ucyIKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9LAogICJkZXNjcmlwdGlvbiI6ICJBIHNjaGVtYSBmb3IgQ2FyZ28udG9tbC4iLAogICJwcm9wZXJ0aWVzIjogewogICAgImJhZGdlcyI6IHsKICAgICAgImRlc2NyaXB0aW9uIjogIltjcmF0ZXMuaW9dKGh0dHBzOi8vY3JhdGVzLmlvKSBjYW4gZGlzcGxheSB2YXJpb3VzIGJhZGdlcyBmb3IgYnVpbGQgc3RhdHVzLCB0ZXN0IGNvdmVyYWdlLCBldGMuIGZvclxuZWFjaCBjcmF0ZS4gQWxsIGJhZGdlcyBhcmUgb3B0aW9uYWwuXG5cbi0gVGhlIGJhZGdlcyBwZXJ0YWluaW5nIHRvIGJ1aWxkIHN0YXR1cyB0aGF0IGFyZSBjdXJyZW50bHkgYXZhaWxhYmxlIGFyZVxuICBBcHB2ZXlvciwgQ2lyY2xlQ0ksIENpcnJ1cyBDSSwgR2l0TGFiLCBBenVyZSBEZXZPcHMsIFRyYXZpcyBDSSBhbmQgQml0YnVja2V0XG4gIFBpcGVsaW5lcy5cbi0gQXZhaWxhYmxlIGJhZGdlcyBwZXJ0YWluaW5nIHRvIGNvZGUgdGVzdCBjb3ZlcmFnZSBhcmUgQ29kZWNvdiBhbmQgQ292ZXJhbGxzLlxuLSBUaGVyZSBhcmUgYWxzbyBtYWludGVuYW5jZS1yZWxhdGVkIGJhZGdlcyBiYXNlZCBvbiBpc2l0bWFpbnRhaW5lZC5jb21cbiAgd2hpY2ggc3RhdGUgdGhlIGlzc3VlIHJlc29sdXRpb24gdGltZSwgcGVyY2VudCBvZiBvcGVuIGlzc3VlcywgYW5kIGZ1dHVyZVxuICBtYWludGVuYW5jZSBpbnRlbnRpb25zLlxuXG5Nb3N0IGJhZGdlIHNwZWNpZmljYXRpb25zIHJlcXVpcmUgYSBgcmVwb3NpdG9yeWAga2V5LiBJdCBpcyBleHBlY3RlZCB0byBiZSBpblxuYHVzZXIvcmVwb2AgZm9ybWF0LlxuXG5gYGB0b21sXG5bYmFkZ2VzXVxuXG4jIEFwcHZleW9yOiBgcmVwb3NpdG9yeWAgaXMgcmVxdWlyZWQuIGBicmFuY2hgIGlzIG9wdGlvbmFsOyBkZWZhdWx0IGlzIGBtYXN0ZXJgXG4jIGBzZXJ2aWNlYCBpcyBvcHRpb25hbDsgdmFsaWQgdmFsdWVzIGFyZSBgZ2l0aHViYCAoZGVmYXVsdCksIGBiaXRidWNrZXRgLCBhbmRcbiMgYGdpdGxhYmA7IGBpZGAgaXMgb3B0aW9uYWw7IHlvdSBjYW4gc3BlY2lmeSB0aGUgYXBwdmV5b3IgcHJvamVjdCBpZCBpZiB5b3VcbiMgd2FudCB0byB1c2UgdGhhdCBpbnN0ZWFkLiBgcHJvamVjdF9uYW1lYCBpcyBvcHRpb25hbDsgdXNlIHdoZW4gdGhlIHJlcG9zaXRvcnlcbiMgbmFtZSBkaWZmZXJzIGZyb20gdGhlIGFwcHZleW9yIHByb2plY3QgbmFtZS5cbmFwcHZleW9yID0geyByZXBvc2l0b3J5ID0gXCIuLi5cIiwgYnJhbmNoID0gXCJtYXN0ZXJcIiwgc2VydmljZSA9IFwiZ2l0aHViXCIgfVxuXG4jIENpcmNsZSBDSTogYHJlcG9zaXRvcnlgIGlzIHJlcXVpcmVkLiBgYnJhbmNoYCBpcyBvcHRpb25hbDsgZGVmYXVsdCBpcyBgbWFzdGVyYFxuY2lyY2xlLWNpID0geyByZXBvc2l0b3J5ID0gXCIuLi5cIiwgYnJhbmNoID0gXCJtYXN0ZXJcIiB9XG5cbiMgQ2lycnVzIENJOiBgcmVwb3NpdG9yeWAgaXMgcmVxdWlyZWQuIGBicmFuY2hgIGlzIG9wdGlvbmFsOyBkZWZhdWx0IGlzIGBtYXN0ZXJgXG5jaXJydXMtY2kgPSB7IHJlcG9zaXRvcnkgPSBcIi4uLlwiLCBicmFuY2ggPSBcIm1hc3RlclwiIH1cblxuIyBHaXRMYWI6IGByZXBvc2l0b3J5YCBpcyByZXF1aXJlZC4gYGJyYW5jaGAgaXMgb3B0aW9uYWw7IGRlZmF1bHQgaXMgYG1hc3RlcmBcbmdpdGxhYiA9IHsgcmVwb3NpdG9yeSA9IFwiLi4uXCIsIGJyYW5jaCA9IFwibWFzdGVyXCIgfVxuXG4jIEF6dXJlIERldk9wczogYHByb2plY3RgIGlzIHJlcXVpcmVkLiBgcGlwZWxpbmVgIGlzIHJlcXVpcmVkLiBgYnVpbGRgIGlzIG9wdGlvbmFsOyBkZWZhdWx0IGlzIGAxYFxuIyBOb3RlOiBwcm9qZWN0ID0gYG9yZ2FuaXphdGlvbi9wcm9qZWN0YCwgcGlwZWxpbmUgPSBgbmFtZV9vZl9waXBlbGluZWAsIGJ1aWxkID0gYGRlZmluaXRpb25JZGBcbmF6dXJlLWRldm9wcyA9IHsgcHJvamVjdCA9IFwiLi4uXCIsIHBpcGVsaW5lID0gXCIuLi5cIiwgYnVpbGQ9XCIyXCIgfVxuXG4jIFRyYXZpcyBDSTogYHJlcG9zaXRvcnlgIGluIGZvcm1hdCBcIjx1c2VyPi88cHJvamVjdD5cIiBpcyByZXF1aXJlZC5cbiMgYGJyYW5jaGAgaXMgb3B0aW9uYWw7IGRlZmF1bHQgaXMgYG1hc3RlcmBcbnRyYXZpcy1jaSA9IHsgcmVwb3NpdG9yeSA9IFwiLi4uXCIsIGJyYW5jaCA9IFwibWFzdGVyXCIgfVxuXG4jIEJpdGJ1Y2tldCBQaXBlbGluZXM6IGByZXBvc2l0b3J5YCBpcyByZXF1aXJlZC4gYGJyYW5jaGAgaXMgcmVxdWlyZWRcbmJpdGJ1Y2tldC1waXBlbGluZXMgPSB7IHJlcG9zaXRvcnkgPSBcIi4uLlwiLCBicmFuY2ggPSBcIm1hc3RlclwiIH1cblxuIyBDb2RlY292OiBgcmVwb3NpdG9yeWAgaXMgcmVxdWlyZWQuIGBicmFuY2hgIGlzIG9wdGlvbmFsOyBkZWZhdWx0IGlzIGBtYXN0ZXJgXG4jIGBzZXJ2aWNlYCBpcyBvcHRpb25hbDsgdmFsaWQgdmFsdWVzIGFyZSBgZ2l0aHViYCAoZGVmYXVsdCksIGBiaXRidWNrZXRgLCBhbmRcbiMgYGdpdGxhYmAuXG5jb2RlY292ID0geyByZXBvc2l0b3J5ID0gXCIuLi5cIiwgYnJhbmNoID0gXCJtYXN0ZXJcIiwgc2VydmljZSA9IFwiZ2l0aHViXCIgfVxuXG4jIENvdmVyYWxsczogYHJlcG9zaXRvcnlgIGlzIHJlcXVpcmVkLiBgYnJhbmNoYCBpcyBvcHRpb25hbDsgZGVmYXVsdCBpcyBgbWFzdGVyYFxuIyBgc2VydmljZWAgaXMgb3B0aW9uYWw7IHZhbGlkIHZhbHVlcyBhcmUgYGdpdGh1YmAgKGRlZmF1bHQpIGFuZCBgYml0YnVja2V0YC5cbmNvdmVyYWxscyA9IHsgcmVwb3NpdG9yeSA9IFwiLi4uXCIsIGJyYW5jaCA9IFwibWFzdGVyXCIsIHNlcnZpY2UgPSBcImdpdGh1YlwiIH1cblxuIyBJcyBpdCBtYWludGFpbmVkIHJlc29sdXRpb24gdGltZTogYHJlcG9zaXRvcnlgIGlzIHJlcXVpcmVkLlxuaXMtaXQtbWFpbnRhaW5lZC1pc3N1ZS1yZXNvbHV0aW9uID0geyByZXBvc2l0b3J5ID0gXCIuLi5cIiB9XG5cbiMgSXMgaXQgbWFpbnRhaW5lZCBwZXJjZW50YWdlIG9mIG9wZW4gaXNzdWVzOiBgcmVwb3NpdG9yeWAgaXMgcmVxdWlyZWQuXG5pcy1pdC1tYWludGFpbmVkLW9wZW4taXNzdWVzID0geyByZXBvc2l0b3J5ID0gXCIuLi5cIiB9XG5cbiMgTWFpbnRlbmFuY2U6IGBzdGF0dXNgIGlzIHJlcXVpcmVkLiBBdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4jIC0gYGFjdGl2ZWx5LWRldmVsb3BlZGA6IE5ldyBmZWF0dXJlcyBhcmUgYmVpbmcgYWRkZWQgYW5kIGJ1Z3MgYXJlIGJlaW5nIGZpeGVkLlxuIyAtIGBwYXNzaXZlbHktbWFpbnRhaW5lZGA6IFRoZXJlIGFyZSBubyBwbGFucyBmb3IgbmV3IGZlYXR1cmVzLCBidXQgdGhlIG1haW50YWluZXIgaW50ZW5kcyB0b1xuIyAgIHJlc3BvbmQgdG8gaXNzdWVzIHRoYXQgZ2V0IGZpbGVkLlxuIyAtIGBhcy1pc2A6IFRoZSBjcmF0ZSBpcyBmZWF0dXJlIGNvbXBsZXRlLCB0aGUgbWFpbnRhaW5lciBkb2VzIG5vdCBpbnRlbmQgdG8gY29udGludWUgd29ya2luZyBvblxuIyAgIGl0IG9yIHByb3ZpZGluZyBzdXBwb3J0LCBidXQgaXQgd29ya3MgZm9yIHRoZSBwdXJwb3NlcyBpdCB3YXMgZGVzaWduZWQgZm9yLlxuIyAtIGBleHBlcmltZW50YWxgOiBUaGUgYXV0aG9yIHdhbnRzIHRvIHNoYXJlIGl0IHdpdGggdGhlIGNvbW11bml0eSBidXQgaXMgbm90IGludGVuZGluZyB0byBtZWV0XG4jICAgYW55b25lJ3MgcGFydGljdWxhciB1c2UgY2FzZS5cbiMgLSBgbG9va2luZy1mb3ItbWFpbnRhaW5lcmA6IFRoZSBjdXJyZW50IG1haW50YWluZXIgd291bGQgbGlrZSB0byB0cmFuc2ZlciB0aGUgY3JhdGUgdG8gc29tZW9uZVxuIyAgIGVsc2UuXG4jIC0gYGRlcHJlY2F0ZWRgOiBUaGUgbWFpbnRhaW5lciBkb2VzIG5vdCByZWNvbW1lbmQgdXNpbmcgdGhpcyBjcmF0ZSAodGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBjcmF0ZVxuIyAgIGNhbiBkZXNjcmliZSB3aHksIHRoZXJlIGNvdWxkIGJlIGEgYmV0dGVyIHNvbHV0aW9uIGF2YWlsYWJsZSBvciB0aGVyZSBjb3VsZCBiZSBwcm9ibGVtcyB3aXRoXG4jICAgdGhlIGNyYXRlIHRoYXQgdGhlIGF1dGhvciBkb2VzIG5vdCB3YW50IHRvIGZpeCkuXG4jIC0gYG5vbmVgOiBEaXNwbGF5cyBubyBiYWRnZSBvbiBjcmF0ZXMuaW8sIHNpbmNlIHRoZSBtYWludGFpbmVyIGhhcyBub3QgY2hvc2VuIHRvIHNwZWNpZnlcbiMgICB0aGVpciBpbnRlbnRpb25zLCBwb3RlbnRpYWwgY3JhdGUgdXNlcnMgd2lsbCBuZWVkIHRvIGludmVzdGlnYXRlIG9uIHRoZWlyIG93bi5cbm1haW50ZW5hbmNlID0geyBzdGF0dXMgPSBcIi4uLlwiIH1cbmBgYCIsCiAgICAgICJ0eXBlIjogIm9iamVjdCIsCiAgICAgICJhZGRpdGlvbmFsUHJvcGVydGllcyI6IHsKICAgICAgICAidHlwZSI6ICJvYmplY3QiLAogICAgICAgICJhZGRpdGlvbmFsUHJvcGVydGllcyI6IHsKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIKICAgICAgICB9CiAgICAgIH0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvbWFuaWZlc3QuaHRtbCN0aGUtYmFkZ2VzLXNlY3Rpb24iCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgImJlbmNoIjogewogICAgICAiZGVzY3JpcHRpb24iOiAiQmVuY2htYXJrcyBwcm92aWRlIGEgd2F5IHRvIHRlc3QgdGhlIHBlcmZvcm1hbmNlIG9mIHlvdXIgY29kZSB1c2luZyB0aGVcbltgY2FyZ28gYmVuY2hgXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2NvbW1hbmRzL2NhcmdvLWJlbmNoLmh0bWwpIGNvbW1hbmQuIFRoZXkgZm9sbG93IHRoZSBzYW1lIHN0cnVjdHVyZSBhcyBbdGVzdHNdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2NhcmdvLXRhcmdldHMuaHRtbCN0ZXN0cyksXG53aXRoIGVhY2ggYmVuY2htYXJrIGZ1bmN0aW9uIGFubm90YXRlZCB3aXRoIHRoZSBgI1tiZW5jaF1gIGF0dHJpYnV0ZS5cblNpbWlsYXJseSB0byB0ZXN0czpcblxuKiBCZW5jaG1hcmtzIGFyZSBwbGFjZWQgaW4gdGhlIFtgYmVuY2hlc2AgZGlyZWN0b3J5XShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2d1aWRlL3Byb2plY3QtbGF5b3V0Lmh0bWwpLlxuKiBCZW5jaG1hcmsgZnVuY3Rpb25zIGRlZmluZWQgaW4gbGlicmFyaWVzIGFuZCBiaW5hcmllcyBoYXZlIGFjY2VzcyB0byB0aGVcbiAgKnByaXZhdGUqIEFQSSB3aXRoaW4gdGhlIHRhcmdldCB0aGV5IGFyZSBkZWZpbmVkIGluLiBCZW5jaG1hcmtzIGluIHRoZVxuICBgYmVuY2hlc2AgZGlyZWN0b3J5IG1heSB1c2UgdGhlICpwdWJsaWMqIEFQSS5cbiogW1RoZSBgYmVuY2hgIGZpZWxkXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9jYXJnby10YXJnZXRzLmh0bWwjdGhlLWJlbmNoLWZpZWxkKSBjYW4gYmUgdXNlZCB0byBkZWZpbmUgd2hpY2ggdGFyZ2V0c1xuICBhcmUgYmVuY2htYXJrZWQgYnkgZGVmYXVsdC5cbiogW1RoZSBgaGFybmVzc2AgZmllbGRdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2NhcmdvLXRhcmdldHMuaHRtbCN0aGUtaGFybmVzcy1maWVsZCkgY2FuIGJlIHVzZWQgdG8gZGlzYWJsZSB0aGVcbiAgYnVpbHQtaW4gaGFybmVzcy5cblxuPiAqKk5vdGUqKjogVGhlIFtgI1tiZW5jaF1gXG4\u002BIGF0dHJpYnV0ZV0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy91bnN0YWJsZS1ib29rL2xpYnJhcnktZmVhdHVyZXMvdGVzdC5odG1sKSBpcyBjdXJyZW50bHlcbj4gdW5zdGFibGUgYW5kIG9ubHkgYXZhaWxhYmxlIG9uIHRoZSBbbmlnaHRseSBjaGFubmVsXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2Jvb2svYXBwZW5kaXgtMDctbmlnaHRseS1ydXN0Lmh0bWwpLiBUaGVyZSBhcmUgc29tZVxuPiBwYWNrYWdlcyBhdmFpbGFibGUgb24gW2NyYXRlcy5pb10oaHR0cHM6Ly9jcmF0ZXMuaW8va2V5d29yZHMvYmVuY2htYXJrKSB0aGF0XG4\u002BIG1heSBoZWxwIHdpdGggcnVubmluZyBiZW5jaG1hcmtzIG9uIHRoZSBzdGFibGUgY2hhbm5lbCwgc3VjaCBhc1xuPiBbQ3JpdGVyaW9uXShodHRwczovL2NyYXRlcy5pby9jcmF0ZXMvY3JpdGVyaW9uKS4iLAogICAgICAidHlwZSI6ICJhcnJheSIsCiAgICAgICJpdGVtcyI6IHsKICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1RhcmdldCIsCiAgICAgICAgImRlc2NyaXB0aW9uIjogIkJlbmNobWFya3MgcHJvdmlkZSBhIHdheSB0byB0ZXN0IHRoZSBwZXJmb3JtYW5jZSBvZiB5b3VyIGNvZGUgdXNpbmcgdGhlXG5bYGNhcmdvIGJlbmNoYF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9jb21tYW5kcy9jYXJnby1iZW5jaC5odG1sKSBjb21tYW5kLiBUaGV5IGZvbGxvdyB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXMgW3Rlc3RzXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9jYXJnby10YXJnZXRzLmh0bWwjdGVzdHMpLFxud2l0aCBlYWNoIGJlbmNobWFyayBmdW5jdGlvbiBhbm5vdGF0ZWQgd2l0aCB0aGUgYCNbYmVuY2hdYCBhdHRyaWJ1dGUuXG5TaW1pbGFybHkgdG8gdGVzdHM6XG5cbiogQmVuY2htYXJrcyBhcmUgcGxhY2VkIGluIHRoZSBbYGJlbmNoZXNgIGRpcmVjdG9yeV0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9ndWlkZS9wcm9qZWN0LWxheW91dC5odG1sKS5cbiogQmVuY2htYXJrIGZ1bmN0aW9ucyBkZWZpbmVkIGluIGxpYnJhcmllcyBhbmQgYmluYXJpZXMgaGF2ZSBhY2Nlc3MgdG8gdGhlXG4gICpwcml2YXRlKiBBUEkgd2l0aGluIHRoZSB0YXJnZXQgdGhleSBhcmUgZGVmaW5lZCBpbi4gQmVuY2htYXJrcyBpbiB0aGVcbiAgYGJlbmNoZXNgIGRpcmVjdG9yeSBtYXkgdXNlIHRoZSAqcHVibGljKiBBUEkuXG4qIFtUaGUgYGJlbmNoYCBmaWVsZF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI3RoZS1iZW5jaC1maWVsZCkgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIHdoaWNoIHRhcmdldHNcbiAgYXJlIGJlbmNobWFya2VkIGJ5IGRlZmF1bHQuXG4qIFtUaGUgYGhhcm5lc3NgIGZpZWxkXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9jYXJnby10YXJnZXRzLmh0bWwjdGhlLWhhcm5lc3MtZmllbGQpIGNhbiBiZSB1c2VkIHRvIGRpc2FibGUgdGhlXG4gIGJ1aWx0LWluIGhhcm5lc3MuXG5cbj4gKipOb3RlKio6IFRoZSBbYCNbYmVuY2hdYFxuPiBhdHRyaWJ1dGVdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvdW5zdGFibGUtYm9vay9saWJyYXJ5LWZlYXR1cmVzL3Rlc3QuaHRtbCkgaXMgY3VycmVudGx5XG4\u002BIHVuc3RhYmxlIGFuZCBvbmx5IGF2YWlsYWJsZSBvbiB0aGUgW25pZ2h0bHkgY2hhbm5lbF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9ib29rL2FwcGVuZGl4LTA3LW5pZ2h0bHktcnVzdC5odG1sKS4gVGhlcmUgYXJlIHNvbWVcbj4gcGFja2FnZXMgYXZhaWxhYmxlIG9uIFtjcmF0ZXMuaW9dKGh0dHBzOi8vY3JhdGVzLmlvL2tleXdvcmRzL2JlbmNobWFyaykgdGhhdFxuPiBtYXkgaGVscCB3aXRoIHJ1bm5pbmcgYmVuY2htYXJrcyBvbiB0aGUgc3RhYmxlIGNoYW5uZWwsIHN1Y2ggYXNcbj4gW0NyaXRlcmlvbl0oaHR0cHM6Ly9jcmF0ZXMuaW8vY3JhdGVzL2NyaXRlcmlvbikuIiwKICAgICAgICAieC10YXBsbyI6IHsKICAgICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9jYXJnby10YXJnZXRzLmh0bWwjYmVuY2htYXJrcyIKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI2JlbmNobWFya3MiCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgImJpbiI6IHsKICAgICAgImRlc2NyaXB0aW9uIjogIkJpbmFyeSB0YXJnZXRzIGFyZSBleGVjdXRhYmxlIHByb2dyYW1zIHRoYXQgY2FuIGJlIHJ1biBhZnRlciBiZWluZyBjb21waWxlZC5cblRoZSBkZWZhdWx0IGJpbmFyeSBmaWxlbmFtZSBpcyBgc3JjL21haW4ucnNgLCB3aGljaCBkZWZhdWx0cyB0byB0aGUgbmFtZSBvZlxudGhlIHBhY2thZ2UuIEFkZGl0aW9uYWwgYmluYXJpZXMgYXJlIHN0b3JlZCBpbiB0aGUgW2BzcmMvYmluL2BcbmRpcmVjdG9yeV0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9ndWlkZS9wcm9qZWN0LWxheW91dC5odG1sKS4gVGhlIHNldHRpbmdzIGZvciBlYWNoIGJpbmFyeSBjYW4gYmUgW2N1c3RvbWl6ZWRdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2NhcmdvLXRhcmdldHMuaHRtbCNjb25maWd1cmluZy1hLXRhcmdldCkgaW4gdGhlIGBbW2Jpbl1dYCB0YWJsZXMgaW4gYENhcmdvLnRvbWxgLlxuXG5CaW5hcmllcyBjYW4gdXNlIHRoZSBwdWJsaWMgQVBJIG9mIHRoZSBwYWNrYWdlJ3MgbGlicmFyeS4gVGhleSBhcmUgYWxzbyBsaW5rZWRcbndpdGggdGhlIFtgW2RlcGVuZGVuY2llc11gXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9zcGVjaWZ5aW5nLWRlcGVuZGVuY2llcy5odG1sKSBkZWZpbmVkIGluIGBDYXJnby50b21sYC5cblxuWW91IGNhbiBydW4gaW5kaXZpZHVhbCBiaW5hcmllcyB3aXRoIHRoZSBbYGNhcmdvIHJ1bmBdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vY29tbWFuZHMvY2FyZ28tcnVuLmh0bWwpIGNvbW1hbmQgd2l0aCB0aGUgYC0tYmluXG48YmluLW5hbWU\u002BYCBvcHRpb24uIFtgY2FyZ28gaW5zdGFsbGBdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vY29tbWFuZHMvY2FyZ28taW5zdGFsbC5odG1sKSBjYW4gYmUgdXNlZCB0byBjb3B5IHRoZSBleGVjdXRhYmxlIHRvIGFcbmNvbW1vbiBsb2NhdGlvbi5cblxuYGBgdG9tbFxuIyBFeGFtcGxlIG9mIGN1c3RvbWl6aW5nIGJpbmFyaWVzIGluIENhcmdvLnRvbWwuXG5bW2Jpbl1dXG5uYW1lID0gXCJjb29sLXRvb2xcIlxudGVzdCA9IGZhbHNlXG5iZW5jaCA9IGZhbHNlXG5cbltbYmluXV1cbm5hbWUgPSBcImZyb2JuaWNhdG9yXCJcbnJlcXVpcmVkLWZlYXR1cmVzID0gW1wiZnJvYm5pY2F0ZVwiXVxuYGBgIiwKICAgICAgInR5cGUiOiAiYXJyYXkiLAogICAgICAiaXRlbXMiOiB7CiAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9UYXJnZXQiLAogICAgICAgICJkZXNjcmlwdGlvbiI6ICJCaW5hcnkgdGFyZ2V0cyBhcmUgZXhlY3V0YWJsZSBwcm9ncmFtcyB0aGF0IGNhbiBiZSBydW4gYWZ0ZXIgYmVpbmcgY29tcGlsZWQuXG5UaGUgZGVmYXVsdCBiaW5hcnkgZmlsZW5hbWUgaXMgYHNyYy9tYWluLnJzYCwgd2hpY2ggZGVmYXVsdHMgdG8gdGhlIG5hbWUgb2ZcbnRoZSBwYWNrYWdlLiBBZGRpdGlvbmFsIGJpbmFyaWVzIGFyZSBzdG9yZWQgaW4gdGhlIFtgc3JjL2Jpbi9gXG5kaXJlY3RvcnldKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vZ3VpZGUvcHJvamVjdC1sYXlvdXQuaHRtbCkuIFRoZSBzZXR0aW5ncyBmb3IgZWFjaCBiaW5hcnkgY2FuIGJlIFtjdXN0b21pemVkXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9jYXJnby10YXJnZXRzLmh0bWwjY29uZmlndXJpbmctYS10YXJnZXQpIGluIHRoZSBgW1tiaW5dXWAgdGFibGVzIGluIGBDYXJnby50b21sYC5cblxuQmluYXJpZXMgY2FuIHVzZSB0aGUgcHVibGljIEFQSSBvZiB0aGUgcGFja2FnZSdzIGxpYnJhcnkuIFRoZXkgYXJlIGFsc28gbGlua2VkXG53aXRoIHRoZSBbYFtkZXBlbmRlbmNpZXNdYF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMuaHRtbCkgZGVmaW5lZCBpbiBgQ2FyZ28udG9tbGAuXG5cbllvdSBjYW4gcnVuIGluZGl2aWR1YWwgYmluYXJpZXMgd2l0aCB0aGUgW2BjYXJnbyBydW5gXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2NvbW1hbmRzL2NhcmdvLXJ1bi5odG1sKSBjb21tYW5kIHdpdGggdGhlIGAtLWJpblxuPGJpbi1uYW1lPmAgb3B0aW9uLiBbYGNhcmdvIGluc3RhbGxgXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2NvbW1hbmRzL2NhcmdvLWluc3RhbGwuaHRtbCkgY2FuIGJlIHVzZWQgdG8gY29weSB0aGUgZXhlY3V0YWJsZSB0byBhXG5jb21tb24gbG9jYXRpb24uXG5cbmBgYHRvbWxcbiMgRXhhbXBsZSBvZiBjdXN0b21pemluZyBiaW5hcmllcyBpbiBDYXJnby50b21sLlxuW1tiaW5dXVxubmFtZSA9IFwiY29vbC10b29sXCJcbnRlc3QgPSBmYWxzZVxuYmVuY2ggPSBmYWxzZVxuXG5bW2Jpbl1dXG5uYW1lID0gXCJmcm9ibmljYXRvclwiXG5yZXF1aXJlZC1mZWF0dXJlcyA9IFtcImZyb2JuaWNhdGVcIl1cbmBgYCIsCiAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI2JpbmFyaWVzIgogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9jYXJnby10YXJnZXRzLmh0bWwjYmluYXJpZXMiCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgImJ1aWxkLWRlcGVuZGVuY2llcyI6IHsKICAgICAgImRlc2NyaXB0aW9uIjogIllvdSBjYW4gZGVwZW5kIG9uIG90aGVyIENhcmdvLWJhc2VkIGNyYXRlcyBmb3IgdXNlIGluIHlvdXIgYnVpbGQgc2NyaXB0cy5cbkRlcGVuZGVuY2llcyBhcmUgZGVjbGFyZWQgdGhyb3VnaCB0aGUgYGJ1aWxkLWRlcGVuZGVuY2llc2Agc2VjdGlvbiBvZiB0aGVcbm1hbmlmZXN0OlxuXG5gYGB0b21sXG5bYnVpbGQtZGVwZW5kZW5jaWVzXVxuY2MgPSBcIjEuMC4zXCJcbmBgYFxuXG5UaGUgYnVpbGQgc2NyaXB0ICoqZG9lcyBub3QqKiBoYXZlIGFjY2VzcyB0byB0aGUgZGVwZW5kZW5jaWVzIGxpc3RlZFxuaW4gdGhlIGBkZXBlbmRlbmNpZXNgIG9yIGBkZXYtZGVwZW5kZW5jaWVzYCBzZWN0aW9uLiBCdWlsZFxuZGVwZW5kZW5jaWVzIHdpbGwgbGlrZXdpc2Ugbm90IGJlIGF2YWlsYWJsZSB0byB0aGUgcGFja2FnZSBpdHNlbGZcbnVubGVzcyBsaXN0ZWQgdW5kZXIgdGhlIGBkZXBlbmRlbmNpZXNgIHNlY3Rpb24gYXMgd2VsbC4gQSBwYWNrYWdlXG5pdHNlbGYgYW5kIGl0cyBidWlsZCBzY3JpcHQgYXJlIGJ1aWx0IHNlcGFyYXRlbHksIHNvIHRoZWlyXG5kZXBlbmRlbmNpZXMgbmVlZCBub3QgY29pbmNpZGUuIENhcmdvIGlzIGtlcHQgc2ltcGxlciBhbmQgY2xlYW5lciBieVxudXNpbmcgaW5kZXBlbmRlbnQgZGVwZW5kZW5jaWVzIGZvciBpbmRlcGVuZGVudCBwdXJwb3Nlcy4iLAogICAgICAidHlwZSI6ICJvYmplY3QiLAogICAgICAiYWRkaXRpb25hbFByb3BlcnRpZXMiOiB7CiAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9EZXBlbmRlbmN5IgogICAgICB9LAogICAgICAieC10YXBsbyI6IHsKICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwjYnVpbGQtZGVwZW5kZW5jaWVzIgogICAgICAgIH0sCiAgICAgICAgInBsdWdpbnMiOiBbImNyYXRlcyJdLAogICAgICAgICJjcmF0ZXMiOiB7CiAgICAgICAgICAic2NoZW1hcyI6ICJkZXBlbmRlbmNpZXMiCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgImJ1aWxkX2RlcGVuZGVuY2llcyI6IHsKICAgICAgInR5cGUiOiAib2JqZWN0IiwKICAgICAgImFkZGl0aW9uYWxQcm9wZXJ0aWVzIjogewogICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvRGVwZW5kZW5jeSIKICAgICAgfSwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImhpZGRlbiI6IHRydWUKICAgICAgfQogICAgfSwKICAgICJjYXJnby1mZWF0dXJlcyI6IHsKICAgICAgInR5cGUiOiAiYXJyYXkiLAogICAgICAiaXRlbXMiOiB7CiAgICAgICAgInR5cGUiOiAic3RyaW5nIgogICAgICB9CiAgICB9LAogICAgImRlcGVuZGVuY2llcyI6IHsKICAgICAgImRlc2NyaXB0aW9uIjogIkNhcmdvIGlzIGNvbmZpZ3VyZWQgdG8gbG9vayBmb3IgZGVwZW5kZW5jaWVzIG9uIFtjcmF0ZXMuaW9dKGh0dHBzOi8vY3JhdGVzLmlvKSBieSBkZWZhdWx0LiBPbmx5XG50aGUgbmFtZSBhbmQgYSB2ZXJzaW9uIHN0cmluZyBhcmUgcmVxdWlyZWQgaW4gdGhpcyBjYXNlLiBJbiBbdGhlIGNhcmdvXG5ndWlkZV0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9ndWlkZS9pbmRleC5odG1sKSwgd2Ugc3BlY2lmaWVkIGEgZGVwZW5kZW5jeSBvbiB0aGUgYHRpbWVgIGNyYXRlOlxuXG5gYGB0b21sXG5bZGVwZW5kZW5jaWVzXVxudGltZSA9IFwiMC4xLjEyXCJcbmBgYFxuXG5UaGUgc3RyaW5nIGBcIjAuMS4xMlwiYCBpcyBhIFtzZW12ZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9zdGV2ZWtsYWJuaWsvc2VtdmVyI3JlcXVpcmVtZW50cykgdmVyc2lvbiByZXF1aXJlbWVudC4gU2luY2UgdGhpc1xuc3RyaW5nIGRvZXMgbm90IGhhdmUgYW55IG9wZXJhdG9ycyBpbiBpdCwgaXQgaXMgaW50ZXJwcmV0ZWQgdGhlIHNhbWUgd2F5IGFzXG5pZiB3ZSBoYWQgc3BlY2lmaWVkIGBcIl4wLjEuMTJcImAsIHdoaWNoIGlzIGNhbGxlZCBhIGNhcmV0IHJlcXVpcmVtZW50LlxuXG5BIGRlcGVuZGVuY3kgY2FuIGFsc28gYmUgZGVmaW5lZCBieSBhIHRhYmxlIHdpdGggYWRkaXRpb25hbCBvcHRpb25zOlxuXG5gYGB0b21sXG5bZGVwZW5kZW5jaWVzXVxudGltZSA9IHsgcGF0aCA9IFwiLi4vdGltZVwiLCB2ZXJzaW9uID0gXCIwLjEuMTJcIiB9XG5gYGAiLAogICAgICAidHlwZSI6ICJvYmplY3QiLAogICAgICAiYWRkaXRpb25hbFByb3BlcnRpZXMiOiB7CiAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9EZXBlbmRlbmN5IgogICAgICB9LAogICAgICAieC10YXBsbyI6IHsKICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwiCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgImRldi1kZXBlbmRlbmNpZXMiOiB7CiAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGUgZm9ybWF0IG9mIGBbZGV2LWRlcGVuZGVuY2llc11gIGlzIGVxdWl2YWxlbnQgdG8gYFtkZXBlbmRlbmNpZXNdYDpcblxuYGBgdG9tbFxuW2Rldi1kZXBlbmRlbmNpZXNdXG50ZW1wZGlyID0gXCIwLjNcIlxuYGBgXG5cbkRldi1kZXBlbmRlbmNpZXMgYXJlIG5vdCB1c2VkIHdoZW4gY29tcGlsaW5nXG5hIHBhY2thZ2UgZm9yIGJ1aWxkaW5nLCBidXQgYXJlIHVzZWQgZm9yIGNvbXBpbGluZyB0ZXN0cywgZXhhbXBsZXMsIGFuZFxuYmVuY2htYXJrcy5cblxuVGhlc2UgZGVwZW5kZW5jaWVzIGFyZSAqbm90KiBwcm9wYWdhdGVkIHRvIG90aGVyIHBhY2thZ2VzIHdoaWNoIGRlcGVuZCBvbiB0aGlzXG5wYWNrYWdlLlxuXG5Zb3UgY2FuIGFsc28gaGF2ZSB0YXJnZXQtc3BlY2lmaWMgZGV2ZWxvcG1lbnQgZGVwZW5kZW5jaWVzIGJ5IHVzaW5nXG5gZGV2LWRlcGVuZGVuY2llc2AgaW4gdGhlIHRhcmdldCBzZWN0aW9uIGhlYWRlciBpbnN0ZWFkIG9mIGBkZXBlbmRlbmNpZXNgLiBGb3JcbmV4YW1wbGU6XG5cbmBgYHRvbWxcblt0YXJnZXQuJ2NmZyh1bml4KScuZGV2LWRlcGVuZGVuY2llc11cbm1pbyA9IFwiMC4wLjFcIlxuYGBgXG5cbj4gKipOb3RlKio6IFdoZW4gYSBwYWNrYWdlIGlzIHB1Ymxpc2hlZCwgb25seSBkZXYtZGVwZW5kZW5jaWVzIHRoYXQgc3BlY2lmeSBhXG4\u002BIGB2ZXJzaW9uYCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBwdWJsaXNoZWQgY3JhdGUuIEZvciBtb3N0IHVzZSBjYXNlcyxcbj4gZGV2LWRlcGVuZGVuY2llcyBhcmUgbm90IG5lZWRlZCB3aGVuIHB1Ymxpc2hlZCwgdGhvdWdoIHNvbWUgdXNlcnMgKGxpa2UgT1Ncbj4gcGFja2FnZXJzKSBtYXkgd2FudCB0byBydW4gdGVzdHMgd2l0aGluIGEgY3JhdGUsIHNvIHByb3ZpZGluZyBhIGB2ZXJzaW9uYCBpZlxuPiBwb3NzaWJsZSBjYW4gc3RpbGwgYmUgYmVuZWZpY2lhbC5cbiIsCiAgICAgICJ0eXBlIjogIm9iamVjdCIsCiAgICAgICJhZGRpdGlvbmFsUHJvcGVydGllcyI6IHsKICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL0RlcGVuZGVuY3kiCiAgICAgIH0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMuaHRtbCNkZXZlbG9wbWVudC1kZXBlbmRlbmNpZXMiCiAgICAgICAgfSwKICAgICAgICAicGx1Z2lucyI6IFsiY3JhdGVzIl0sCiAgICAgICAgImNyYXRlcyI6IHsKICAgICAgICAgICJzY2hlbWFzIjogImRlcGVuZGVuY2llcyIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAiZGV2X2RlcGVuZGVuY2llcyI6IHsKICAgICAgInR5cGUiOiAib2JqZWN0IiwKICAgICAgImFkZGl0aW9uYWxQcm9wZXJ0aWVzIjogewogICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvRGVwZW5kZW5jeSIKICAgICAgfSwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImhpZGRlbiI6IHRydWUKICAgICAgfQogICAgfSwKICAgICJleGFtcGxlIjogewogICAgICAiZGVzY3JpcHRpb24iOiAiRmlsZXMgbG9jYXRlZCB1bmRlciB0aGUgW2V4YW1wbGVzIGRpcmVjdG9yeV0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9ndWlkZS9wcm9qZWN0LWxheW91dC5odG1sKSBhcmUgZXhhbXBsZSB1c2VzIG9mIHRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoZSBsaWJyYXJ5LiBXaGVuIGNvbXBpbGVkLCB0aGV5IGFyZSBwbGFjZWQgaW4gdGhlWyB0YXJnZXQvZGVidWcvZXhhbXBsZXMgZGlyZWN0b3J5XShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2d1aWRlL2J1aWxkLWNhY2hlLmh0bWwpLlxuXG5FeGFtcGxlcyBjYW4gdXNlIHRoZSBwdWJsaWMgQVBJIG9mIHRoZSBwYWNrYWdlJ3MgbGlicmFyeS4gVGhleSBhcmUgYWxzbyBsaW5rZWQgd2l0aCB0aGUgW2RlcGVuZGVuY2llc10oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMuaHRtbCkgYW5kIFtkZXYtZGVwZW5kZW5jaWVzXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9zcGVjaWZ5aW5nLWRlcGVuZGVuY2llcy5odG1sI2RldmVsb3BtZW50LWRlcGVuZGVuY2llcykgZGVmaW5lZCBpbiBDYXJnby50b21sLlxuXG5CeSBkZWZhdWx0LCBleGFtcGxlcyBhcmUgZXhlY3V0YWJsZSBiaW5hcmllcyAod2l0aCBhIGBtYWluKClgIGZ1bmN0aW9uKS4gWW91XG5jYW4gc3BlY2lmeSB0aGUgW2BjcmF0ZS10eXBlYCBmaWVsZF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI3RoZS1jcmF0ZS10eXBlLWZpZWxkKSB0byBtYWtlIGFuIGV4YW1wbGVcbmJlIGNvbXBpbGVkIGFzIGEgbGlicmFyeTpcblxuYGBgdG9tbFxuW1tleGFtcGxlXV1cbm5hbWUgPSBcImZvb1wiXG5jcmF0ZS10eXBlID0gW1wic3RhdGljbGliXCJdXG5gYGBcblxuWW91IGNhbiBydW4gaW5kaXZpZHVhbCBleGVjdXRhYmxlIGV4YW1wbGVzIHdpdGggdGhlIFtgY2FyZ28gcnVuYF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9jb21tYW5kcy9jYXJnby1ydW4uaHRtbCkgY29tbWFuZCB3aXRoXG50aGUgYC0tZXhhbXBsZSA8ZXhhbXBsZS1uYW1lPmAgb3B0aW9uLiBMaWJyYXJ5IGV4YW1wbGVzIGNhbiBiZSBidWlsdCB3aXRoXG5bYGNhcmdvIGJ1aWxkYF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9jb21tYW5kcy9jYXJnby1idWlsZC5odG1sKSB3aXRoIHRoZSBgLS1leGFtcGxlIDxleGFtcGxlLW5hbWU\u002BYCBvcHRpb24uIFtgY2FyZ28gaW5zdGFsbGBdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vY29tbWFuZHMvY2FyZ28taW5zdGFsbC5odG1sKVxud2l0aCB0aGUgYC0tZXhhbXBsZSA8ZXhhbXBsZS1uYW1lPmAgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIGNvcHkgZXhlY3V0YWJsZVxuYmluYXJpZXMgdG8gYSBjb21tb24gbG9jYXRpb24uIEV4YW1wbGVzIGFyZSBjb21waWxlZCBieSBbYGNhcmdvIHRlc3RgXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2NvbW1hbmRzL2NhcmdvLXRlc3QuaHRtbCkgYnlcbmRlZmF1bHQgdG8gcHJvdGVjdCB0aGVtIGZyb20gYml0LXJvdHRpbmcuIFNldCBbdGhlIGB0ZXN0YFxuZmllbGRdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2NhcmdvLXRhcmdldHMuaHRtbCN0aGUtdGVzdC1maWVsZCkgdG8gYHRydWVgIGlmIHlvdSBoYXZlIGAjW3Rlc3RdYCBmdW5jdGlvbnMgaW4gdGhlXG5leGFtcGxlIHRoYXQgeW91IHdhbnQgdG8gcnVuIHdpdGggW2BjYXJnbyB0ZXN0YF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9jb21tYW5kcy9jYXJnby10ZXN0Lmh0bWwpLlxuIiwKICAgICAgInR5cGUiOiAiYXJyYXkiLAogICAgICAiaXRlbXMiOiB7CiAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9UYXJnZXQiLAogICAgICAgICJkZXNjcmlwdGlvbiI6ICJGaWxlcyBsb2NhdGVkIHVuZGVyIHRoZSBbZXhhbXBsZXMgZGlyZWN0b3J5XShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2d1aWRlL3Byb2plY3QtbGF5b3V0Lmh0bWwpIGFyZSBleGFtcGxlIHVzZXMgb2YgdGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhlIGxpYnJhcnkuIFdoZW4gY29tcGlsZWQsIHRoZXkgYXJlIHBsYWNlZCBpbiB0aGVbIHRhcmdldC9kZWJ1Zy9leGFtcGxlcyBkaXJlY3RvcnldKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vZ3VpZGUvYnVpbGQtY2FjaGUuaHRtbCkuXG5cbkV4YW1wbGVzIGNhbiB1c2UgdGhlIHB1YmxpYyBBUEkgb2YgdGhlIHBhY2thZ2UncyBsaWJyYXJ5LiBUaGV5IGFyZSBhbHNvIGxpbmtlZCB3aXRoIHRoZSBbZGVwZW5kZW5jaWVzXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9zcGVjaWZ5aW5nLWRlcGVuZGVuY2llcy5odG1sKSBhbmQgW2Rldi1kZXBlbmRlbmNpZXNdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL3NwZWNpZnlpbmctZGVwZW5kZW5jaWVzLmh0bWwjZGV2ZWxvcG1lbnQtZGVwZW5kZW5jaWVzKSBkZWZpbmVkIGluIENhcmdvLnRvbWwuXG5cbkJ5IGRlZmF1bHQsIGV4YW1wbGVzIGFyZSBleGVjdXRhYmxlIGJpbmFyaWVzICh3aXRoIGEgYG1haW4oKWAgZnVuY3Rpb24pLiBZb3VcbmNhbiBzcGVjaWZ5IHRoZSBbYGNyYXRlLXR5cGVgIGZpZWxkXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9jYXJnby10YXJnZXRzLmh0bWwjdGhlLWNyYXRlLXR5cGUtZmllbGQpIHRvIG1ha2UgYW4gZXhhbXBsZVxuYmUgY29tcGlsZWQgYXMgYSBsaWJyYXJ5OlxuXG5gYGB0b21sXG5bW2V4YW1wbGVdXVxubmFtZSA9IFwiZm9vXCJcbmNyYXRlLXR5cGUgPSBbXCJzdGF0aWNsaWJcIl1cbmBgYFxuXG5Zb3UgY2FuIHJ1biBpbmRpdmlkdWFsIGV4ZWN1dGFibGUgZXhhbXBsZXMgd2l0aCB0aGUgW2BjYXJnbyBydW5gXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2NvbW1hbmRzL2NhcmdvLXJ1bi5odG1sKSBjb21tYW5kIHdpdGhcbnRoZSBgLS1leGFtcGxlIDxleGFtcGxlLW5hbWU\u002BYCBvcHRpb24uIExpYnJhcnkgZXhhbXBsZXMgY2FuIGJlIGJ1aWx0IHdpdGhcbltgY2FyZ28gYnVpbGRgXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2NvbW1hbmRzL2NhcmdvLWJ1aWxkLmh0bWwpIHdpdGggdGhlIGAtLWV4YW1wbGUgPGV4YW1wbGUtbmFtZT5gIG9wdGlvbi4gW2BjYXJnbyBpbnN0YWxsYF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9jb21tYW5kcy9jYXJnby1pbnN0YWxsLmh0bWwpXG53aXRoIHRoZSBgLS1leGFtcGxlIDxleGFtcGxlLW5hbWU\u002BYCBvcHRpb24gY2FuIGJlIHVzZWQgdG8gY29weSBleGVjdXRhYmxlXG5iaW5hcmllcyB0byBhIGNvbW1vbiBsb2NhdGlvbi4gRXhhbXBsZXMgYXJlIGNvbXBpbGVkIGJ5IFtgY2FyZ28gdGVzdGBdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vY29tbWFuZHMvY2FyZ28tdGVzdC5odG1sKSBieVxuZGVmYXVsdCB0byBwcm90ZWN0IHRoZW0gZnJvbSBiaXQtcm90dGluZy4gU2V0IFt0aGUgYHRlc3RgXG5maWVsZF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI3RoZS10ZXN0LWZpZWxkKSB0byBgdHJ1ZWAgaWYgeW91IGhhdmUgYCNbdGVzdF1gIGZ1bmN0aW9ucyBpbiB0aGVcbmV4YW1wbGUgdGhhdCB5b3Ugd2FudCB0byBydW4gd2l0aCBbYGNhcmdvIHRlc3RgXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2NvbW1hbmRzL2NhcmdvLXRlc3QuaHRtbCkuXG4iLAogICAgICAgICJ4LXRhcGxvIjogewogICAgICAgICAgImxpbmtzIjogewogICAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2NhcmdvLXRhcmdldHMuaHRtbCNleGFtcGxlcyIKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI2V4YW1wbGVzIgogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJmZWF0dXJlcyI6IHsKICAgICAgImRlc2NyaXB0aW9uIjogIkNhcmdvIHN1cHBvcnRzIGZlYXR1cmVzIHRvIGFsbG93IGV4cHJlc3Npb24gb2Y6XG5cbiogY29uZGl0aW9uYWwgY29tcGlsYXRpb24gb3B0aW9ucyAodXNhYmxlIHRocm91Z2ggYGNmZ2AgYXR0cmlidXRlcyk7XG4qIG9wdGlvbmFsIGRlcGVuZGVuY2llcywgd2hpY2ggZW5oYW5jZSBhIHBhY2thZ2UsIGJ1dCBhcmUgbm90IHJlcXVpcmVkOyBhbmRcbiogY2x1c3RlcnMgb2Ygb3B0aW9uYWwgZGVwZW5kZW5jaWVzLCBzdWNoIGFzIGBwb3N0Z3Jlcy1hbGxgLCB0aGF0IHdvdWxkIGluY2x1ZGUgdGhlXG4gIGBwb3N0Z3Jlc2AgcGFja2FnZSwgdGhlIGBwb3N0Z3Jlcy1tYWNyb3NgIHBhY2thZ2UsIGFuZCBwb3NzaWJseSBvdGhlciBwYWNrYWdlc1xuICAoc3VjaCBhcyBkZXZlbG9wbWVudC10aW1lIG1vY2tpbmcgbGlicmFyaWVzLCBkZWJ1Z2dpbmcgdG9vbHMsIGV0Yy4pLlxuXG5BIGZlYXR1cmUgb2YgYSBwYWNrYWdlIGlzIGVpdGhlciBhbiBvcHRpb25hbCBkZXBlbmRlbmN5LCBvciBhIHNldCBvZiBvdGhlclxuZmVhdHVyZXMuXG4iLAogICAgICAidHlwZSI6ICJvYmplY3QiLAogICAgICAiYWRkaXRpb25hbFByb3BlcnRpZXMiOiB7CiAgICAgICAgInR5cGUiOiAiYXJyYXkiLAogICAgICAgICJpdGVtcyI6IHsKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIKICAgICAgICB9CiAgICAgIH0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJsaW5rcyI6IHsKICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvZmVhdHVyZXMuaHRtbCIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAibGliIjogewogICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1RhcmdldCIsCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJkb2NzIjogewogICAgICAgICAgIm1haW4iOiAiVGhlIGxpYnJhcnkgdGFyZ2V0IGRlZmluZXMgYSBcImxpYnJhcnlcIiB0aGF0IGNhbiBiZSB1c2VkIGFuZCBsaW5rZWQgYnkgb3RoZXJcbmxpYnJhcmllcyBhbmQgZXhlY3V0YWJsZXMuIFRoZSBmaWxlbmFtZSBkZWZhdWx0cyB0byBgc3JjL2xpYi5yc2AsIGFuZCB0aGUgbmFtZVxub2YgdGhlIGxpYnJhcnkgZGVmYXVsdHMgdG8gdGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UuIEEgcGFja2FnZSBjYW4gaGF2ZSBvbmx5XG5vbmUgbGlicmFyeS4gVGhlIHNldHRpbmdzIGZvciB0aGUgbGlicmFyeSBjYW4gYmUgW2N1c3RvbWl6ZWRdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2NhcmdvLXRhcmdldHMuaHRtbCNjb25maWd1cmluZy1hLXRhcmdldCkgaW4gdGhlIGBbbGliXWBcbnRhYmxlIGluIGBDYXJnby50b21sYC5cblxuYGBgdG9tbFxuIyBFeGFtcGxlIG9mIGN1c3RvbWl6aW5nIHRoZSBsaWJyYXJ5IGluIENhcmdvLnRvbWwuXG5bbGliXVxuY3JhdGUtdHlwZSA9IFtcImNkeWxpYlwiXVxuYmVuY2ggPSBmYWxzZVxuYGBgXG4iCiAgICAgICAgfSwKICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAia2V5IjogImh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vcmVmZXJlbmNlL2NhcmdvLXRhcmdldHMuaHRtbCNsaWJyYXJ5IgogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJwYWNrYWdlIjogewogICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1BhY2thZ2UiCiAgICB9LAogICAgInBhdGNoIjogewogICAgICAiZGVzY3JpcHRpb24iOiAiVGhlIGBbcGF0Y2hdYCBzZWN0aW9uIG9mIGBDYXJnby50b21sYCBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSBkZXBlbmRlbmNpZXNcbndpdGggb3RoZXIgY29waWVzLiBUaGUgc3ludGF4IGlzIHNpbWlsYXIgdG8gdGhlXG5bYFtkZXBlbmRlbmNpZXNdYF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMuaHRtbCkgc2VjdGlvbi5cblxuIiwKICAgICAgInR5cGUiOiAib2JqZWN0IiwKICAgICAgImFkZGl0aW9uYWxQcm9wZXJ0aWVzIjogewogICAgICAgICJ0eXBlIjogIm9iamVjdCIsCiAgICAgICAgImFkZGl0aW9uYWxQcm9wZXJ0aWVzIjogewogICAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9EZXBlbmRlbmN5IgogICAgICAgIH0KICAgICAgfSwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9vdmVycmlkaW5nLWRlcGVuZGVuY2llcy5odG1sI3RoZS1wYXRjaC1zZWN0aW9uIgogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgICJwcm9maWxlIjogewogICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1Byb2ZpbGVzIgogICAgfSwKICAgICJwcm9qZWN0IjogewogICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL1BhY2thZ2UiLAogICAgICAieC10YXBsbyI6IHsKICAgICAgICAiaGlkZGVuIjogdHJ1ZQogICAgICB9CiAgICB9LAogICAgInJlcGxhY2UiOiB7CiAgICAgICJ0eXBlIjogIm9iamVjdCIsCiAgICAgICJhZGRpdGlvbmFsUHJvcGVydGllcyI6IHsKICAgICAgICAiJHJlZiI6ICIjL2RlZmluaXRpb25zL0RlcGVuZGVuY3kiCiAgICAgIH0sCiAgICAgICJ4LXRhcGxvIjogewogICAgICAgICJoaWRkZW4iOiB0cnVlCiAgICAgIH0KICAgIH0sCiAgICAidGFyZ2V0IjogewogICAgICAidHlwZSI6ICJvYmplY3QiLAogICAgICAiYWRkaXRpb25hbFByb3BlcnRpZXMiOiB7CiAgICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9QbGF0Zm9ybSIKICAgICAgfQogICAgfSwKICAgICJ0ZXN0IjogewogICAgICAiZGVzY3JpcHRpb24iOiAiRmlsZXMgbG9jYXRlZCB1bmRlciB0aGUgW2B0ZXN0c2AgZGlyZWN0b3J5XShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2d1aWRlL3Byb2plY3QtbGF5b3V0Lmh0bWwpIGFyZSBpbnRlZ3JhdGlvblxudGVzdHMuIFdoZW4geW91IHJ1biBbYGNhcmdvIHRlc3RgXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2NvbW1hbmRzL2NhcmdvLXRlc3QuaHRtbCksIENhcmdvIHdpbGwgY29tcGlsZSBlYWNoIG9mIHRoZXNlIGZpbGVzIGFzXG5hIHNlcGFyYXRlIGNyYXRlLCBhbmQgZXhlY3V0ZSB0aGVtLlxuXG5JbnRlZ3JhdGlvbiB0ZXN0cyBjYW4gdXNlIHRoZSBwdWJsaWMgQVBJIG9mIHRoZSBwYWNrYWdlJ3MgbGlicmFyeS4gVGhleSBhcmVcbmFsc28gbGlua2VkIHdpdGggdGhlIFtgW2RlcGVuZGVuY2llc11gXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9zcGVjaWZ5aW5nLWRlcGVuZGVuY2llcy5odG1sKSBhbmRcbltgW2Rldi1kZXBlbmRlbmNpZXNdYF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMuaHRtbCNkZXZlbG9wbWVudC1kZXBlbmRlbmNpZXMpIGRlZmluZWQgaW4gYENhcmdvLnRvbWxgLlxuXG5JZiB5b3Ugd2FudCB0byBzaGFyZSBjb2RlIGFtb25nIG11bHRpcGxlIGludGVncmF0aW9uIHRlc3RzLCB5b3UgY2FuIHBsYWNlIGl0XG5pbiBhIHNlcGFyYXRlIG1vZHVsZSBzdWNoIGFzIGB0ZXN0cy9jb21tb24vbW9kLnJzYCBhbmQgdGhlbiBwdXQgYG1vZCBjb21tb247YFxuaW4gZWFjaCB0ZXN0IHRvIGltcG9ydCBpdC5cblxuRWFjaCBpbnRlZ3JhdGlvbiB0ZXN0IHJlc3VsdHMgaW4gYSBzZXBhcmF0ZSBleGVjdXRhYmxlIGJpbmFyeSwgYW5kIFtgY2FyZ29cbnRlc3RgXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2NvbW1hbmRzL2NhcmdvLXRlc3QuaHRtbCkgd2lsbCBydW4gdGhlbSBzZXJpYWxseS4gSW4gc29tZSBjYXNlcyB0aGlzIGNhbiBiZSBpbmVmZmljaWVudCwgYXMgaXRcbmNhbiB0YWtlIGxvbmdlciB0byBjb21waWxlLCBhbmQgbWF5IG5vdCBtYWtlIGZ1bGwgdXNlIG9mIG11bHRpcGxlIENQVXMgd2hlblxucnVubmluZyB0aGUgdGVzdHMuIElmIHlvdSBoYXZlIGEgbG90IG9mIGludGVncmF0aW9uIHRlc3RzLCB5b3UgbWF5IHdhbnQgdG9cbmNvbnNpZGVyIGNyZWF0aW5nIGEgc2luZ2xlIGludGVncmF0aW9uIHRlc3QsIGFuZCBzcGxpdCB0aGUgdGVzdHMgaW50byBtdWx0aXBsZVxubW9kdWxlcy4gVGhlIGxpYnRlc3QgaGFybmVzcyB3aWxsIGF1dG9tYXRpY2FsbHkgZmluZCBhbGwgb2YgdGhlIGAjW3Rlc3RdYFxuYW5ub3RhdGVkIGZ1bmN0aW9ucyBhbmQgcnVuIHRoZW0gaW4gcGFyYWxsZWwuIFlvdSBjYW4gcGFzcyBtb2R1bGUgbmFtZXMgdG9cbltgY2FyZ28gdGVzdGBdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vY29tbWFuZHMvY2FyZ28tdGVzdC5odG1sKSB0byBvbmx5IHJ1biB0aGUgdGVzdHMgd2l0aGluIHRoYXQgbW9kdWxlLlxuXG5CaW5hcnkgdGFyZ2V0cyBhcmUgYXV0b21hdGljYWxseSBidWlsdCBpZiB0aGVyZSBpcyBhbiBpbnRlZ3JhdGlvbiB0ZXN0LiBUaGlzXG5hbGxvd3MgYW4gaW50ZWdyYXRpb24gdGVzdCB0byBleGVjdXRlIHRoZSBiaW5hcnkgdG8gZXhlcmNpc2UgYW5kIHRlc3QgaXRzXG5iZWhhdmlvci4gVGhlIGBDQVJHT19CSU5fRVhFXzxuYW1lPmAgW2Vudmlyb25tZW50IHZhcmlhYmxlXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9lbnZpcm9ubWVudC12YXJpYWJsZXMuaHRtbCNlbnZpcm9ubWVudC12YXJpYWJsZXMtY2FyZ28tc2V0cy1mb3ItY3JhdGVzKSBpcyBzZXQgd2hlbiB0aGVcbmludGVncmF0aW9uIHRlc3QgaXMgYnVpbHQgc28gdGhhdCBpdCBjYW4gdXNlIHRoZSBbYGVudmAgbWFjcm9dKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvc3RkL21hY3JvLmVudi5odG1sKSB0byBsb2NhdGUgdGhlXG5leGVjdXRhYmxlLiIsCiAgICAgICJ0eXBlIjogImFycmF5IiwKICAgICAgIml0ZW1zIjogewogICAgICAgICIkcmVmIjogIiMvZGVmaW5pdGlvbnMvVGFyZ2V0IiwKICAgICAgICAiZGVzY3JpcHRpb24iOiAiRmlsZXMgbG9jYXRlZCB1bmRlciB0aGUgW2B0ZXN0c2AgZGlyZWN0b3J5XShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2d1aWRlL3Byb2plY3QtbGF5b3V0Lmh0bWwpIGFyZSBpbnRlZ3JhdGlvblxudGVzdHMuIFdoZW4geW91IHJ1biBbYGNhcmdvIHRlc3RgXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2NvbW1hbmRzL2NhcmdvLXRlc3QuaHRtbCksIENhcmdvIHdpbGwgY29tcGlsZSBlYWNoIG9mIHRoZXNlIGZpbGVzIGFzXG5hIHNlcGFyYXRlIGNyYXRlLCBhbmQgZXhlY3V0ZSB0aGVtLlxuXG5JbnRlZ3JhdGlvbiB0ZXN0cyBjYW4gdXNlIHRoZSBwdWJsaWMgQVBJIG9mIHRoZSBwYWNrYWdlJ3MgbGlicmFyeS4gVGhleSBhcmVcbmFsc28gbGlua2VkIHdpdGggdGhlIFtgW2RlcGVuZGVuY2llc11gXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9zcGVjaWZ5aW5nLWRlcGVuZGVuY2llcy5odG1sKSBhbmRcbltgW2Rldi1kZXBlbmRlbmNpZXNdYF0oaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2Uvc3BlY2lmeWluZy1kZXBlbmRlbmNpZXMuaHRtbCNkZXZlbG9wbWVudC1kZXBlbmRlbmNpZXMpIGRlZmluZWQgaW4gYENhcmdvLnRvbWxgLlxuXG5JZiB5b3Ugd2FudCB0byBzaGFyZSBjb2RlIGFtb25nIG11bHRpcGxlIGludGVncmF0aW9uIHRlc3RzLCB5b3UgY2FuIHBsYWNlIGl0XG5pbiBhIHNlcGFyYXRlIG1vZHVsZSBzdWNoIGFzIGB0ZXN0cy9jb21tb24vbW9kLnJzYCBhbmQgdGhlbiBwdXQgYG1vZCBjb21tb247YFxuaW4gZWFjaCB0ZXN0IHRvIGltcG9ydCBpdC5cblxuRWFjaCBpbnRlZ3JhdGlvbiB0ZXN0IHJlc3VsdHMgaW4gYSBzZXBhcmF0ZSBleGVjdXRhYmxlIGJpbmFyeSwgYW5kIFtgY2FyZ29cbnRlc3RgXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL2NvbW1hbmRzL2NhcmdvLXRlc3QuaHRtbCkgd2lsbCBydW4gdGhlbSBzZXJpYWxseS4gSW4gc29tZSBjYXNlcyB0aGlzIGNhbiBiZSBpbmVmZmljaWVudCwgYXMgaXRcbmNhbiB0YWtlIGxvbmdlciB0byBjb21waWxlLCBhbmQgbWF5IG5vdCBtYWtlIGZ1bGwgdXNlIG9mIG11bHRpcGxlIENQVXMgd2hlblxucnVubmluZyB0aGUgdGVzdHMuIElmIHlvdSBoYXZlIGEgbG90IG9mIGludGVncmF0aW9uIHRlc3RzLCB5b3UgbWF5IHdhbnQgdG9cbmNvbnNpZGVyIGNyZWF0aW5nIGEgc2luZ2xlIGludGVncmF0aW9uIHRlc3QsIGFuZCBzcGxpdCB0aGUgdGVzdHMgaW50byBtdWx0aXBsZVxubW9kdWxlcy4gVGhlIGxpYnRlc3QgaGFybmVzcyB3aWxsIGF1dG9tYXRpY2FsbHkgZmluZCBhbGwgb2YgdGhlIGAjW3Rlc3RdYFxuYW5ub3RhdGVkIGZ1bmN0aW9ucyBhbmQgcnVuIHRoZW0gaW4gcGFyYWxsZWwuIFlvdSBjYW4gcGFzcyBtb2R1bGUgbmFtZXMgdG9cbltgY2FyZ28gdGVzdGBdKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvY2FyZ28vY29tbWFuZHMvY2FyZ28tdGVzdC5odG1sKSB0byBvbmx5IHJ1biB0aGUgdGVzdHMgd2l0aGluIHRoYXQgbW9kdWxlLlxuXG5CaW5hcnkgdGFyZ2V0cyBhcmUgYXV0b21hdGljYWxseSBidWlsdCBpZiB0aGVyZSBpcyBhbiBpbnRlZ3JhdGlvbiB0ZXN0LiBUaGlzXG5hbGxvd3MgYW4gaW50ZWdyYXRpb24gdGVzdCB0byBleGVjdXRlIHRoZSBiaW5hcnkgdG8gZXhlcmNpc2UgYW5kIHRlc3QgaXRzXG5iZWhhdmlvci4gVGhlIGBDQVJHT19CSU5fRVhFXzxuYW1lPmAgW2Vudmlyb25tZW50IHZhcmlhYmxlXShodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9lbnZpcm9ubWVudC12YXJpYWJsZXMuaHRtbCNlbnZpcm9ubWVudC12YXJpYWJsZXMtY2FyZ28tc2V0cy1mb3ItY3JhdGVzKSBpcyBzZXQgd2hlbiB0aGVcbmludGVncmF0aW9uIHRlc3QgaXMgYnVpbHQgc28gdGhhdCBpdCBjYW4gdXNlIHRoZSBbYGVudmAgbWFjcm9dKGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvc3RkL21hY3JvLmVudi5odG1sKSB0byBsb2NhdGUgdGhlXG5leGVjdXRhYmxlLiIsCiAgICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgICAibGlua3MiOiB7CiAgICAgICAgICAgICJrZXkiOiAiaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9jYXJnby9yZWZlcmVuY2UvY2FyZ28tdGFyZ2V0cy5odG1sI2ludGVncmF0aW9uLXRlc3RzIgogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwKICAgICAgIngtdGFwbG8iOiB7CiAgICAgICAgImxpbmtzIjogewogICAgICAgICAgImtleSI6ICJodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL2NhcmdvL3JlZmVyZW5jZS9jYXJnby10YXJnZXRzLmh0bWwjaW50ZWdyYXRpb24tdGVzdHMiCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgIndvcmtzcGFjZSI6IHsKICAgICAgIiRyZWYiOiAiIy9kZWZpbml0aW9ucy9Xb3Jrc3BhY2UiCiAgICB9CiAgfSwKICAidGl0bGUiOiAiQ2FyZ28udG9tbCIsCiAgInR5cGUiOiAib2JqZWN0IiwKICAieC10YXBsby1pbmZvIjogewogICAgImF1dGhvcnMiOiBbInRhbWFzZmUgKGh0dHBzOi8vZ2l0aHViLmNvbS90YW1hc2ZlKSJdLAogICAgInBhdHRlcm5zIjogWyJeKC4qKC98XFxcXClDYXJnb1xcLnRvbWx8Q2FyZ29cXC50b21sKSQiXQogIH0KfQ=="
  },
  "functions": {
    "cargo:index:read": {
      "description": "Read the given JSON into the object model",
      "inputs": {
        "required": [
          "json"
        ],
        "properties": {
          "json": {
            "type": "string"
          }
        }
      },
      "outputs": {
        "required": [
          "value"
        ],
        "properties": {
          "value": {
            "$ref": "#/types/cargo:index:root"
          }
        }
      }
    },
    "cargo:index:write": {
      "description": "Read the given JSON into the object model",
      "inputs": {
        "required": [
          "value"
        ],
        "properties": {
          "value": {
            "$ref": "#/types/cargo:index:root"
          }
        }
      },
      "outputs": {
        "required": [
          "json"
        ],
        "properties": {
          "json": {
            "type": "string"
          }
        }
      }
    }
  },
  "types": {
    "cargo:index:assetsConfiguration": {
      "type": "object",
      "description": "Options for assets paths resolution and how to build assets collection",
      "properties": {
        "dependencies": {
          "type": "boolean",
          "description": "Allow build assets for dependencies."
        },
        "followSymlinks": {
          "type": "boolean"
        },
        "method": {
          "$ref": "#/types/cargo:index:method"
        },
        "overwrite": {
          "type": "boolean",
          "description": "Allow overwriting existing files."
        }
      }
    },
    "cargo:index:configuration": {
      "type": "object",
      "description": "Package build options.",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "assets": {
          "$ref": "#/types/cargo:index:assetsConfiguration"
        }
      }
    },
    "cargo:index:definitionsEdition": {
      "description": "The \u0060edition\u0060 key affects which edition your package is compiled with. Cargo\nwill always generate packages via [\u0060cargo new\u0060](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the \u0060edition\u0060 key set to the\nlatest edition. Setting the \u0060edition\u0060 key in \u0060[package]\u0060 will affect all\ntargets/crates in the package, including test suites, benchmarks, binaries,\nexamples, etc.",
      "type": "string",
      "enum": [
        {
          "value": "2015"
        },
        {
          "value": "2018"
        },
        {
          "value": "2021"
        },
        {
          "value": "2024"
        }
      ]
    },
    "cargo:index:definitionsPanic": {
      "description": "The \u0060panic\u0060 setting controls the [\u0060-C panic\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic) which controls which panic\nstrategy to use.\n\nWhen set to \u0060\u0022unwind\u0022\u0060, the actual value depends on the default of the target\nplatform. For example, the NVPTX platform does not support unwinding, so it\nalways uses \u0060\u0022abort\u0022\u0060.\n\nTests, benchmarks, build scripts, and proc macros ignore the \u0060panic\u0060 setting.\nThe \u0060rustc\u0060 test harness currently requires \u0060unwind\u0060 behavior. See the\n[\u0060panic-abort-tests\u0060](https://doc.rust-lang.org/cargo/reference/unstable.html#panic-abort-tests) unstable flag which enables \u0060abort\u0060 behavior.\n\nAdditionally, when using the \u0060abort\u0060 strategy and building a test, all of the\ndependencies will also be forced to built with the \u0060unwind\u0060 strategy.",
      "type": "string",
      "enum": [
        {
          "value": "unwind"
        },
        {
          "value": "abort"
        }
      ]
    },
    "cargo:index:definitionsProfile": {
      "type": "object",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "buildOverride": {
          "$ref": "#/types/cargo:index:definitionsProfile"
        },
        "codegenUnits": {
          "type": "integer",
          "description": "The \u0060codegen-units\u0060 setting controls the [\u0060-C codegen-units\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#codegen-units) which\ncontrols how many \u0022code generation units\u0022 a crate will be split into. More\ncode generation units allows more of a crate to be processed in parallel\npossibly reducing compile time, but may produce slower code.\n\nThis option takes an integer greater than 0.\n\nThe default is 256 for [incremental](https://doc.rust-lang.org/cargo/reference/profiles.html#incremental) builds, and 16 for\nnon-incremental builds."
        },
        "debug": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "debugAssertions": {
          "type": "boolean",
          "description": "The \u0060debug-assertions\u0060 setting controls the [\u0060-C debug-assertions\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#debug-assertions) which\nturns \u0060cfg(debug_assertions)\u0060 [conditional compilation](https://doc.rust-lang.org/reference/conditional-compilation.html#debug_assertions) on or off. Debug\nassertions are intended to include runtime validation which is only available\nin debug/development builds. These may be things that are too expensive or\notherwise undesirable in a release build. Debug assertions enables the\n[\u0060debug_assert!\u0060 macro](https://doc.rust-lang.org/std/macro.debug_assert.html) in the standard library."
        },
        "dirName": {
          "type": "string"
        },
        "incremental": {
          "type": "boolean",
          "description": "The \u0060incremental\u0060 setting controls the [\u0060-C incremental\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#incremental) which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses \u0060rustc\u0060 to to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times. The additional\ninformation is stored in the \u0060target\u0060 directory.\n\nThe valid options are:\n\n* \u0060true\u0060: enabled\n* \u0060false\u0060: disabled\n\nIncremental compilation is only used for workspace members and \u0022path\u0022\ndependencies.\n\nThe incremental value can be overridden globally with the \u0060CARGO_INCREMENTAL\u0060\n[environment variable](https://doc.rust-lang.org/cargo/reference/environment-variables.html) or the [\u0060build.incremental\u0060](https://doc.rust-lang.org/cargo/reference/config.html#buildincremental) config variable."
        },
        "inherits": {
          "type": "string"
        },
        "lto": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "optLevel": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "overflowChecks": {
          "type": "boolean",
          "description": "The \u0060overflow-checks\u0060 setting controls the [\u0060-C overflow-checks\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#overflow-checks) which\ncontrols the behavior of [runtime integer overflow](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow). When overflow-checks are\nenabled, a panic will occur on overflow."
        },
        "package": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/types/cargo:index:definitionsProfile"
          },
          "description": "Package-specific overrides.\n\nThe package name is a [Package ID Spec](https://doc.rust-lang.org/cargo/reference/pkgid-spec.html), so you can\ntarget individual versions of a package with syntax such as \u0060[profile.dev.package.\u0022foo:2.1.0\u0022]\u0060."
        },
        "panic": {
          "$ref": "#/types/cargo:index:definitionsPanic"
        },
        "rpath": {
          "type": "boolean",
          "description": "The \u0060rpath\u0060 setting controls the [\u0060-C rpath\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#rpath) which controls\nwhether or not [\u0060rpath\u0060](https://en.wikipedia.org/wiki/Rpath) is enabled."
        }
      }
    },
    "cargo:index:definitionsResolver": {
      "description": "A different feature resolver algorithm can be used by specifying the resolver version in Cargo.toml like this:\n\n[package]\nname = \u0022my-package\u0022\nversion = \u00221.0.0\u0022\nresolver = \u00222\u0022\n\nThe version \u00221\u0022 resolver is the original resolver that shipped with Cargo up to version 1.50. The default is \u00222\u0022 if the root package specifies edition = \u00222021\u0022 or a newer edition. Otherwise the default is \u00221\u0022.\n\nThe version \u00222\u0022 resolver introduces changes in feature unification. See the features chapter for more details.\n\nThe resolver is a global option that affects the entire workspace. The resolver version in dependencies is ignored, only the value in the top-level package will be used. If using a virtual workspace, the version should be specified in the [workspace] table, for example:\n\n[workspace]\nmembers = [\u0022member1\u0022, \u0022member2\u0022]\nresolver = \u00222\u0022",
      "type": "string",
      "enum": [
        {
          "value": "1"
        },
        {
          "value": "2"
        },
        {
          "value": "3"
        }
      ]
    },
    "cargo:index:definitionsTarget": {
      "type": "object",
      "description": "Binary targets are executable programs that can be run after being compiled.\nThe default binary filename is \u0060src/main.rs\u0060, which defaults to the name of\nthe package. Additional binaries are stored in the [\u0060src/bin/\u0060\ndirectory](https://doc.rust-lang.org/cargo/guide/project-layout.html). The settings for each binary can be [customized](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#configuring-a-target) in the \u0060[[bin]]\u0060 tables in \u0060Cargo.toml\u0060.\n\nBinaries can use the public API of the package\u0027s library. They are also linked\nwith the [\u0060[dependencies]\u0060](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) defined in \u0060Cargo.toml\u0060.\n\nYou can run individual binaries with the [\u0060cargo run\u0060](https://doc.rust-lang.org/cargo/commands/cargo-run.html) command with the \u0060--bin\n\u003Cbin-name\u003E\u0060 option. [\u0060cargo install\u0060](https://doc.rust-lang.org/cargo/commands/cargo-install.html) can be used to copy the executable to a\ncommon location.\n\n\u0060\u0060\u0060toml\n# Example of customizing binaries in Cargo.toml.\n[[bin]]\nname = \u0022cool-tool\u0022\ntest = false\nbench = false\n\n[[bin]]\nname = \u0022frobnicator\u0022\nrequired-features = [\u0022frobnicate\u0022]\n\u0060\u0060\u0060",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "bench": {
          "type": "boolean",
          "description": "The \u0060bench\u0060 field indicates whether or not the target is benchmarked by\ndefault by [\u0060cargo bench\u0060](https://doc.rust-lang.org/cargo/commands/cargo-bench.html). The default is \u0060true\u0060 for lib, bins, and\nbenchmarks."
        },
        "crateType": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The \u0060crate-type\u0060 field defines the [crate types](https://doc.rust-lang.org/reference/linkage.html) that will be generated by the\ntarget. It is an array of strings, allowing you to specify multiple crate\ntypes for a single target. This can only be specified for libraries and\nexamples. Binaries, tests, and benchmarks are always the \u0022bin\u0022 crate type.\n\nThe available options are \u0060bin\u0060, \u0060lib\u0060, \u0060rlib\u0060, \u0060dylib\u0060, \u0060cdylib\u0060,\n\u0060staticlib\u0060, and \u0060proc-macro\u0060. You can read more about the different crate\ntypes in the [Rust Reference Manual](https://doc.rust-lang.org/reference/linkage.html)."
        },
        "crateType0": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "doc": {
          "type": "boolean",
          "description": "The \u0060doc\u0060 field indicates whether or not the target is included in the\ndocumentation generated by [\u0060cargo doc\u0060](https://doc.rust-lang.org/cargo/commands/cargo-doc.html) by default. The default is \u0060true\u0060 for\nlibraries and binaries.\n\n\u003E **Note**: The binary will be skipped if its name is the same as the lib\n\u003E target."
        },
        "doctest": {
          "type": "boolean",
          "description": "The \u0060doctest\u0060 field indicates whether or not [documentation examples](https://doc.rust-lang.org/rustdoc/documentation-tests.html) are\ntested by default by [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html). This is only relevant for libraries, it\nhas no effect on other sections. The default is \u0060true\u0060 for the library.\n"
        },
        "edition": {
          "$ref": "#/types/cargo:index:definitionsEdition"
        },
        "harness": {
          "type": "boolean",
          "description": "The \u0060harness\u0060 field indicates that the [\u0060--test\u0060 flag](https://doc.rust-lang.org/rustc/command-line-arguments.html#option-test) will be passed to\n\u0060rustc\u0060 which will automatically include the libtest library which is the\ndriver for collecting and running tests marked with the [\u0060#[test]\u0060 attribute](https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute) or benchmarks with the \u0060#[bench]\u0060 attribute. The\ndefault is \u0060true\u0060 for all targets.\n\nIf set to \u0060false\u0060, then you are responsible for defining a \u0060main()\u0060 function\nto run tests and benchmarks.\n\nTests have the [\u0060cfg(test)\u0060 conditional expression](https://doc.rust-lang.org/reference/conditional-compilation.html#test) enabled whether\nor not the harness is enabled."
        },
        "name": {
          "type": "string",
          "description": "The \u0060name\u0060 field specifies the name of the target, which corresponds to the\nfilename of the artifact that will be generated. For a library, this is the\ncrate name that dependencies will use to reference it.\n\nFor the \u0060[lib]\u0060 and the default binary (\u0060src/main.rs\u0060), this defaults to the\nname of the package, with any dashes replaced with underscores. For other\n[auto discovered](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery) targets, it defaults to the\ndirectory or file name.\n\nThis is required for all targets except \u0060[lib]\u0060."
        },
        "path": {
          "type": "string",
          "description": "The \u0060path\u0060 field specifies where the source for the crate is located, relative\nto the \u0060Cargo.toml\u0060 file.\n\nIf not specified, the [inferred path](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery) is used based on\nthe target name."
        },
        "plugin": {
          "type": "boolean"
        },
        "procMacro": {
          "type": "boolean",
          "description": "The \u0060proc-macro\u0060 field indicates that the library is a [procedural macro](https://doc.rust-lang.org/book/ch19-06-macros.html)\n([reference](https://doc.rust-lang.org/reference/procedural-macros.html)). This is only valid for the \u0060[lib]\u0060\ntarget."
        },
        "procMacro0": {
          "type": "boolean"
        },
        "requiredFeatures": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The \u0060required-features\u0060 field specifies which [features](https://doc.rust-lang.org/cargo/reference/features.html) the target needs in\norder to be built. If any of the required features are not enabled, the\ntarget will be skipped. This is only relevant for the \u0060[[bin]]\u0060, \u0060[[bench]]\u0060,\n\u0060[[test]]\u0060, and \u0060[[example]]\u0060 sections, it has no effect on \u0060[lib]\u0060.\n\n\u0060\u0060\u0060toml\n[features]\n# ...\npostgres = []\nsqlite = []\ntools = []\n\n[[bin]]\nname = \u0022my-pg-tool\u0022\nrequired-features = [\u0022postgres\u0022, \u0022tools\u0022]\n\u0060\u0060\u0060\n"
        },
        "test": {
          "type": "boolean",
          "description": "The \u0060test\u0060 field indicates whether or not the target is tested by default by\n[\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html). The default is \u0060true\u0060 for lib, bins, and tests.\n\n\u003E **Note**: Examples are built by [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html) by default to ensure they\n\u003E continue to compile, but they are not *tested* by default. Setting \u0060test =\n\u003E true\u0060 for an example will also build it as a test and run any\n\u003E [\u0060#[test]\u0060](https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute) functions defined in the example."
        }
      }
    },
    "cargo:index:dev": {
      "type": "object",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "buildOverride": {
          "$ref": "#/types/cargo:index:dev"
        },
        "codegenUnits": {
          "type": "integer",
          "description": "The \u0060codegen-units\u0060 setting controls the [\u0060-C codegen-units\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#codegen-units) which\ncontrols how many \u0022code generation units\u0022 a crate will be split into. More\ncode generation units allows more of a crate to be processed in parallel\npossibly reducing compile time, but may produce slower code.\n\nThis option takes an integer greater than 0.\n\nThe default is 256 for [incremental](https://doc.rust-lang.org/cargo/reference/profiles.html#incremental) builds, and 16 for\nnon-incremental builds."
        },
        "debug": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "debugAssertions": {
          "type": "boolean",
          "description": "The \u0060debug-assertions\u0060 setting controls the [\u0060-C debug-assertions\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#debug-assertions) which\nturns \u0060cfg(debug_assertions)\u0060 [conditional compilation](https://doc.rust-lang.org/reference/conditional-compilation.html#debug_assertions) on or off. Debug\nassertions are intended to include runtime validation which is only available\nin debug/development builds. These may be things that are too expensive or\notherwise undesirable in a release build. Debug assertions enables the\n[\u0060debug_assert!\u0060 macro](https://doc.rust-lang.org/std/macro.debug_assert.html) in the standard library."
        },
        "dirName": {
          "type": "string"
        },
        "incremental": {
          "type": "boolean",
          "description": "The \u0060incremental\u0060 setting controls the [\u0060-C incremental\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#incremental) which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses \u0060rustc\u0060 to to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times. The additional\ninformation is stored in the \u0060target\u0060 directory.\n\nThe valid options are:\n\n* \u0060true\u0060: enabled\n* \u0060false\u0060: disabled\n\nIncremental compilation is only used for workspace members and \u0022path\u0022\ndependencies.\n\nThe incremental value can be overridden globally with the \u0060CARGO_INCREMENTAL\u0060\n[environment variable](https://doc.rust-lang.org/cargo/reference/environment-variables.html) or the [\u0060build.incremental\u0060](https://doc.rust-lang.org/cargo/reference/config.html#buildincremental) config variable."
        },
        "inherits": {
          "type": "string"
        },
        "lto": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "optLevel": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "overflowChecks": {
          "type": "boolean",
          "description": "The \u0060overflow-checks\u0060 setting controls the [\u0060-C overflow-checks\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#overflow-checks) which\ncontrols the behavior of [runtime integer overflow](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow). When overflow-checks are\nenabled, a panic will occur on overflow."
        },
        "package": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/types/cargo:index:dev"
          },
          "description": "Package-specific overrides.\n\nThe package name is a [Package ID Spec](https://doc.rust-lang.org/cargo/reference/pkgid-spec.html), so you can\ntarget individual versions of a package with syntax such as \u0060[profile.dev.package.\u0022foo:2.1.0\u0022]\u0060."
        },
        "panic": {
          "$ref": "#/types/cargo:index:devPanic"
        },
        "rpath": {
          "type": "boolean",
          "description": "The \u0060rpath\u0060 setting controls the [\u0060-C rpath\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#rpath) which controls\nwhether or not [\u0060rpath\u0060](https://en.wikipedia.org/wiki/Rpath) is enabled."
        }
      }
    },
    "cargo:index:devPanic": {
      "description": "The \u0060panic\u0060 setting controls the [\u0060-C panic\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic) which controls which panic\nstrategy to use.\n\nWhen set to \u0060\u0022unwind\u0022\u0060, the actual value depends on the default of the target\nplatform. For example, the NVPTX platform does not support unwinding, so it\nalways uses \u0060\u0022abort\u0022\u0060.\n\nTests, benchmarks, build scripts, and proc macros ignore the \u0060panic\u0060 setting.\nThe \u0060rustc\u0060 test harness currently requires \u0060unwind\u0060 behavior. See the\n[\u0060panic-abort-tests\u0060](https://doc.rust-lang.org/cargo/reference/unstable.html#panic-abort-tests) unstable flag which enables \u0060abort\u0060 behavior.\n\nAdditionally, when using the \u0060abort\u0060 strategy and building a test, all of the\ndependencies will also be forced to built with the \u0060unwind\u0060 strategy.",
      "type": "string",
      "enum": [
        {
          "value": "unwind"
        },
        {
          "value": "abort"
        }
      ]
    },
    "cargo:index:edition": {
      "description": "The \u0060edition\u0060 key affects which edition your package is compiled with. Cargo\nwill always generate packages via [\u0060cargo new\u0060](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the \u0060edition\u0060 key set to the\nlatest edition. Setting the \u0060edition\u0060 key in \u0060[package]\u0060 will affect all\ntargets/crates in the package, including test suites, benchmarks, binaries,\nexamples, etc.",
      "type": "string",
      "enum": [
        {
          "value": "2015"
        },
        {
          "value": "2018"
        },
        {
          "value": "2021"
        },
        {
          "value": "2024"
        }
      ]
    },
    "cargo:index:items": {
      "type": "object",
      "description": "Files located under the [examples directory](https://doc.rust-lang.org/cargo/guide/project-layout.html) are example uses of the functionality provided by the library. When compiled, they are placed in the[ target/debug/examples directory](https://doc.rust-lang.org/cargo/guide/build-cache.html).\n\nExamples can use the public API of the package\u0027s library. They are also linked with the [dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) and [dev-dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies) defined in Cargo.toml.\n\nBy default, examples are executable binaries (with a \u0060main()\u0060 function). You\ncan specify the [\u0060crate-type\u0060 field](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-crate-type-field) to make an example\nbe compiled as a library:\n\n\u0060\u0060\u0060toml\n[[example]]\nname = \u0022foo\u0022\ncrate-type = [\u0022staticlib\u0022]\n\u0060\u0060\u0060\n\nYou can run individual executable examples with the [\u0060cargo run\u0060](https://doc.rust-lang.org/cargo/commands/cargo-run.html) command with\nthe \u0060--example \u003Cexample-name\u003E\u0060 option. Library examples can be built with\n[\u0060cargo build\u0060](https://doc.rust-lang.org/cargo/commands/cargo-build.html) with the \u0060--example \u003Cexample-name\u003E\u0060 option. [\u0060cargo install\u0060](https://doc.rust-lang.org/cargo/commands/cargo-install.html)\nwith the \u0060--example \u003Cexample-name\u003E\u0060 option can be used to copy executable\nbinaries to a common location. Examples are compiled by [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html) by\ndefault to protect them from bit-rotting. Set [the \u0060test\u0060\nfield](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-test-field) to \u0060true\u0060 if you have \u0060#[test]\u0060 functions in the\nexample that you want to run with [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html).\n",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "bench": {
          "type": "boolean",
          "description": "The \u0060bench\u0060 field indicates whether or not the target is benchmarked by\ndefault by [\u0060cargo bench\u0060](https://doc.rust-lang.org/cargo/commands/cargo-bench.html). The default is \u0060true\u0060 for lib, bins, and\nbenchmarks."
        },
        "crateType": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The \u0060crate-type\u0060 field defines the [crate types](https://doc.rust-lang.org/reference/linkage.html) that will be generated by the\ntarget. It is an array of strings, allowing you to specify multiple crate\ntypes for a single target. This can only be specified for libraries and\nexamples. Binaries, tests, and benchmarks are always the \u0022bin\u0022 crate type.\n\nThe available options are \u0060bin\u0060, \u0060lib\u0060, \u0060rlib\u0060, \u0060dylib\u0060, \u0060cdylib\u0060,\n\u0060staticlib\u0060, and \u0060proc-macro\u0060. You can read more about the different crate\ntypes in the [Rust Reference Manual](https://doc.rust-lang.org/reference/linkage.html)."
        },
        "crateType0": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "doc": {
          "type": "boolean",
          "description": "The \u0060doc\u0060 field indicates whether or not the target is included in the\ndocumentation generated by [\u0060cargo doc\u0060](https://doc.rust-lang.org/cargo/commands/cargo-doc.html) by default. The default is \u0060true\u0060 for\nlibraries and binaries.\n\n\u003E **Note**: The binary will be skipped if its name is the same as the lib\n\u003E target."
        },
        "doctest": {
          "type": "boolean",
          "description": "The \u0060doctest\u0060 field indicates whether or not [documentation examples](https://doc.rust-lang.org/rustdoc/documentation-tests.html) are\ntested by default by [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html). This is only relevant for libraries, it\nhas no effect on other sections. The default is \u0060true\u0060 for the library.\n"
        },
        "edition": {
          "$ref": "#/types/cargo:index:itemsEdition"
        },
        "harness": {
          "type": "boolean",
          "description": "The \u0060harness\u0060 field indicates that the [\u0060--test\u0060 flag](https://doc.rust-lang.org/rustc/command-line-arguments.html#option-test) will be passed to\n\u0060rustc\u0060 which will automatically include the libtest library which is the\ndriver for collecting and running tests marked with the [\u0060#[test]\u0060 attribute](https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute) or benchmarks with the \u0060#[bench]\u0060 attribute. The\ndefault is \u0060true\u0060 for all targets.\n\nIf set to \u0060false\u0060, then you are responsible for defining a \u0060main()\u0060 function\nto run tests and benchmarks.\n\nTests have the [\u0060cfg(test)\u0060 conditional expression](https://doc.rust-lang.org/reference/conditional-compilation.html#test) enabled whether\nor not the harness is enabled."
        },
        "name": {
          "type": "string",
          "description": "The \u0060name\u0060 field specifies the name of the target, which corresponds to the\nfilename of the artifact that will be generated. For a library, this is the\ncrate name that dependencies will use to reference it.\n\nFor the \u0060[lib]\u0060 and the default binary (\u0060src/main.rs\u0060), this defaults to the\nname of the package, with any dashes replaced with underscores. For other\n[auto discovered](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery) targets, it defaults to the\ndirectory or file name.\n\nThis is required for all targets except \u0060[lib]\u0060."
        },
        "path": {
          "type": "string",
          "description": "The \u0060path\u0060 field specifies where the source for the crate is located, relative\nto the \u0060Cargo.toml\u0060 file.\n\nIf not specified, the [inferred path](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery) is used based on\nthe target name."
        },
        "plugin": {
          "type": "boolean"
        },
        "procMacro": {
          "type": "boolean",
          "description": "The \u0060proc-macro\u0060 field indicates that the library is a [procedural macro](https://doc.rust-lang.org/book/ch19-06-macros.html)\n([reference](https://doc.rust-lang.org/reference/procedural-macros.html)). This is only valid for the \u0060[lib]\u0060\ntarget."
        },
        "procMacro0": {
          "type": "boolean"
        },
        "requiredFeatures": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The \u0060required-features\u0060 field specifies which [features](https://doc.rust-lang.org/cargo/reference/features.html) the target needs in\norder to be built. If any of the required features are not enabled, the\ntarget will be skipped. This is only relevant for the \u0060[[bin]]\u0060, \u0060[[bench]]\u0060,\n\u0060[[test]]\u0060, and \u0060[[example]]\u0060 sections, it has no effect on \u0060[lib]\u0060.\n\n\u0060\u0060\u0060toml\n[features]\n# ...\npostgres = []\nsqlite = []\ntools = []\n\n[[bin]]\nname = \u0022my-pg-tool\u0022\nrequired-features = [\u0022postgres\u0022, \u0022tools\u0022]\n\u0060\u0060\u0060\n"
        },
        "test": {
          "type": "boolean",
          "description": "The \u0060test\u0060 field indicates whether or not the target is tested by default by\n[\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html). The default is \u0060true\u0060 for lib, bins, and tests.\n\n\u003E **Note**: Examples are built by [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html) by default to ensure they\n\u003E continue to compile, but they are not *tested* by default. Setting \u0060test =\n\u003E true\u0060 for an example will also build it as a test and run any\n\u003E [\u0060#[test]\u0060](https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute) functions defined in the example."
        }
      }
    },
    "cargo:index:itemsEdition": {
      "description": "The \u0060edition\u0060 key affects which edition your package is compiled with. Cargo\nwill always generate packages via [\u0060cargo new\u0060](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the \u0060edition\u0060 key set to the\nlatest edition. Setting the \u0060edition\u0060 key in \u0060[package]\u0060 will affect all\ntargets/crates in the package, including test suites, benchmarks, binaries,\nexamples, etc.",
      "type": "string",
      "enum": [
        {
          "value": "2015"
        },
        {
          "value": "2018"
        },
        {
          "value": "2021"
        },
        {
          "value": "2024"
        }
      ]
    },
    "cargo:index:lib": {
      "type": "object",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "bench": {
          "type": "boolean",
          "description": "The \u0060bench\u0060 field indicates whether or not the target is benchmarked by\ndefault by [\u0060cargo bench\u0060](https://doc.rust-lang.org/cargo/commands/cargo-bench.html). The default is \u0060true\u0060 for lib, bins, and\nbenchmarks."
        },
        "crateType": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The \u0060crate-type\u0060 field defines the [crate types](https://doc.rust-lang.org/reference/linkage.html) that will be generated by the\ntarget. It is an array of strings, allowing you to specify multiple crate\ntypes for a single target. This can only be specified for libraries and\nexamples. Binaries, tests, and benchmarks are always the \u0022bin\u0022 crate type.\n\nThe available options are \u0060bin\u0060, \u0060lib\u0060, \u0060rlib\u0060, \u0060dylib\u0060, \u0060cdylib\u0060,\n\u0060staticlib\u0060, and \u0060proc-macro\u0060. You can read more about the different crate\ntypes in the [Rust Reference Manual](https://doc.rust-lang.org/reference/linkage.html)."
        },
        "crateType0": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "doc": {
          "type": "boolean",
          "description": "The \u0060doc\u0060 field indicates whether or not the target is included in the\ndocumentation generated by [\u0060cargo doc\u0060](https://doc.rust-lang.org/cargo/commands/cargo-doc.html) by default. The default is \u0060true\u0060 for\nlibraries and binaries.\n\n\u003E **Note**: The binary will be skipped if its name is the same as the lib\n\u003E target."
        },
        "doctest": {
          "type": "boolean",
          "description": "The \u0060doctest\u0060 field indicates whether or not [documentation examples](https://doc.rust-lang.org/rustdoc/documentation-tests.html) are\ntested by default by [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html). This is only relevant for libraries, it\nhas no effect on other sections. The default is \u0060true\u0060 for the library.\n"
        },
        "edition": {
          "$ref": "#/types/cargo:index:libEdition"
        },
        "harness": {
          "type": "boolean",
          "description": "The \u0060harness\u0060 field indicates that the [\u0060--test\u0060 flag](https://doc.rust-lang.org/rustc/command-line-arguments.html#option-test) will be passed to\n\u0060rustc\u0060 which will automatically include the libtest library which is the\ndriver for collecting and running tests marked with the [\u0060#[test]\u0060 attribute](https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute) or benchmarks with the \u0060#[bench]\u0060 attribute. The\ndefault is \u0060true\u0060 for all targets.\n\nIf set to \u0060false\u0060, then you are responsible for defining a \u0060main()\u0060 function\nto run tests and benchmarks.\n\nTests have the [\u0060cfg(test)\u0060 conditional expression](https://doc.rust-lang.org/reference/conditional-compilation.html#test) enabled whether\nor not the harness is enabled."
        },
        "name": {
          "type": "string",
          "description": "The \u0060name\u0060 field specifies the name of the target, which corresponds to the\nfilename of the artifact that will be generated. For a library, this is the\ncrate name that dependencies will use to reference it.\n\nFor the \u0060[lib]\u0060 and the default binary (\u0060src/main.rs\u0060), this defaults to the\nname of the package, with any dashes replaced with underscores. For other\n[auto discovered](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery) targets, it defaults to the\ndirectory or file name.\n\nThis is required for all targets except \u0060[lib]\u0060."
        },
        "path": {
          "type": "string",
          "description": "The \u0060path\u0060 field specifies where the source for the crate is located, relative\nto the \u0060Cargo.toml\u0060 file.\n\nIf not specified, the [inferred path](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery) is used based on\nthe target name."
        },
        "plugin": {
          "type": "boolean"
        },
        "procMacro": {
          "type": "boolean",
          "description": "The \u0060proc-macro\u0060 field indicates that the library is a [procedural macro](https://doc.rust-lang.org/book/ch19-06-macros.html)\n([reference](https://doc.rust-lang.org/reference/procedural-macros.html)). This is only valid for the \u0060[lib]\u0060\ntarget."
        },
        "procMacro0": {
          "type": "boolean"
        },
        "requiredFeatures": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The \u0060required-features\u0060 field specifies which [features](https://doc.rust-lang.org/cargo/reference/features.html) the target needs in\norder to be built. If any of the required features are not enabled, the\ntarget will be skipped. This is only relevant for the \u0060[[bin]]\u0060, \u0060[[bench]]\u0060,\n\u0060[[test]]\u0060, and \u0060[[example]]\u0060 sections, it has no effect on \u0060[lib]\u0060.\n\n\u0060\u0060\u0060toml\n[features]\n# ...\npostgres = []\nsqlite = []\ntools = []\n\n[[bin]]\nname = \u0022my-pg-tool\u0022\nrequired-features = [\u0022postgres\u0022, \u0022tools\u0022]\n\u0060\u0060\u0060\n"
        },
        "test": {
          "type": "boolean",
          "description": "The \u0060test\u0060 field indicates whether or not the target is tested by default by\n[\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html). The default is \u0060true\u0060 for lib, bins, and tests.\n\n\u003E **Note**: Examples are built by [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html) by default to ensure they\n\u003E continue to compile, but they are not *tested* by default. Setting \u0060test =\n\u003E true\u0060 for an example will also build it as a test and run any\n\u003E [\u0060#[test]\u0060](https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute) functions defined in the example."
        }
      }
    },
    "cargo:index:libEdition": {
      "description": "The \u0060edition\u0060 key affects which edition your package is compiled with. Cargo\nwill always generate packages via [\u0060cargo new\u0060](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the \u0060edition\u0060 key set to the\nlatest edition. Setting the \u0060edition\u0060 key in \u0060[package]\u0060 will affect all\ntargets/crates in the package, including test suites, benchmarks, binaries,\nexamples, etc.",
      "type": "string",
      "enum": [
        {
          "value": "2015"
        },
        {
          "value": "2018"
        },
        {
          "value": "2021"
        },
        {
          "value": "2024"
        }
      ]
    },
    "cargo:index:metadata": {
      "type": "object",
      "description": "Cargo by default will warn about unused keys in \u0060Cargo.toml\u0060 to assist in\ndetecting typos and such. The \u0060package.metadata\u0060 table, however, is completely\nignored by Cargo and will not be warned about. This section can be used for\ntools which would like to store package configuration in \u0060Cargo.toml\u0060. For\nexample:\n\n\u0060\u0060\u0060toml\n[package]\nname = \u0022...\u0022\n# ...\n\n# Metadata used when generating an Android APK, for example.\n[package.metadata.android]\npackage-name = \u0022my-awesome-android-app\u0022\nassets = \u0022path/to/static\u0022\n\u0060\u0060\u0060\n",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "playdate": {
          "$ref": "#/types/cargo:index:playdatePackageMetadata"
        }
      }
    },
    "cargo:index:method": {
      "type": "string",
      "enum": [
        {
          "value": "copy"
        },
        {
          "value": "link"
        }
      ]
    },
    "cargo:index:package": {
      "type": "object",
      "description": "The only field required by Cargo is [\u0060name\u0060](https://doc.rust-lang.org/cargo/reference/manifest.html#the-name-field).\n If publishing to a registry, the registry may\nrequire additional fields. See the notes below and [the publishing chapter](https://doc.rust-lang.org/cargo/reference/publishing.html) for requirements for publishing to [crates.io](https://crates.io/).",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "authors": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "autobenches": {
          "type": "boolean",
          "description": "Disable automatic discovery of \u0060bench\u0060 targets.\n\nDisabling automatic discovery should only be needed for specialized\nsituations. For example, if you have a library where you want a *module* named\n\u0060bin\u0060, this would present a problem because Cargo would usually attempt to\ncompile anything in the \u0060bin\u0060 directory as an executable. Here is a sample\nlayout of this scenario:\n\n\u0060\u0060\u0060\n\u251C\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u251C\u2500\u2500 lib.rs\n    \u2514\u2500\u2500 bin\n        \u2514\u2500\u2500 mod.rs\n\u0060\u0060\u0060\n"
        },
        "autobins": {
          "type": "boolean",
          "description": "Disable automatic discovery of \u0060bin\u0060 targets.\n\nDisabling automatic discovery should only be needed for specialized\nsituations. For example, if you have a library where you want a *module* named\n\u0060bin\u0060, this would present a problem because Cargo would usually attempt to\ncompile anything in the \u0060bin\u0060 directory as an executable. Here is a sample\nlayout of this scenario:\n\n\u0060\u0060\u0060\n\u251C\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u251C\u2500\u2500 lib.rs\n    \u2514\u2500\u2500 bin\n        \u2514\u2500\u2500 mod.rs\n\u0060\u0060\u0060\n\nTo prevent Cargo from inferring \u0060src/bin/mod.rs\u0060 as an executable, set\nthis to \u0060false\u0060 to disable auto-discovery."
        },
        "autoexamples": {
          "type": "boolean",
          "description": "Disable automatic discovery of \u0060example\u0060 targets.\n\nDisabling automatic discovery should only be needed for specialized\nsituations. For example, if you have a library where you want a *module* named\n\u0060bin\u0060, this would present a problem because Cargo would usually attempt to\ncompile anything in the \u0060bin\u0060 directory as an executable. Here is a sample\nlayout of this scenario:\n\n\u0060\u0060\u0060\n\u251C\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u251C\u2500\u2500 lib.rs\n    \u2514\u2500\u2500 bin\n        \u2514\u2500\u2500 mod.rs\n\u0060\u0060\u0060\n"
        },
        "autotests": {
          "type": "boolean",
          "description": "Disable automatic discovery of \u0060test\u0060 targets.\n\nDisabling automatic discovery should only be needed for specialized\nsituations. For example, if you have a library where you want a *module* named\n\u0060bin\u0060, this would present a problem because Cargo would usually attempt to\ncompile anything in the \u0060bin\u0060 directory as an executable. Here is a sample\nlayout of this scenario:\n\n\u0060\u0060\u0060\n\u251C\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u251C\u2500\u2500 lib.rs\n    \u2514\u2500\u2500 bin\n        \u2514\u2500\u2500 mod.rs\n\u0060\u0060\u0060\n"
        },
        "build": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.AnyOfKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "categories": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "defaultRun": {
          "type": "string",
          "description": "The \u0060default-run\u0060 field in the \u0060[package]\u0060 section of the manifest can be used\nto specify a default binary picked by [\u0060cargo run\u0060](https://doc.rust-lang.org/cargo/commands/cargo-run.html). For example, when there is\nboth \u0060src/bin/a.rs\u0060 and \u0060src/bin/b.rs\u0060:\n\n\u0060\u0060\u0060toml\n[package]\ndefault-run = \u0022a\u0022\n\u0060\u0060\u0060"
        },
        "description": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "documentation": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "edition": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "exclude": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "homepage": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "imATeapot": {
          "type": "boolean",
          "description": "Sets whether the current package is a teapot or something else that is not capable of brewing tea."
        },
        "include": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "keywords": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "license": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "licenseFile": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "links": {
          "type": "string",
          "description": "The \u0060links\u0060 field specifies the name of a native library that is being linked\nto. More information can be found in the [\u0060links\u0060](https://doc.rust-lang.org/cargo/reference/build-scripts.html#the-links-manifest-key) section of the build\nscript guide.\n\n\u0060\u0060\u0060toml\n[package]\n# ...\nlinks = \u0022foo\u0022\n\u0060\u0060\u0060"
        },
        "metabuild": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "metadata": {
          "$ref": "#/types/cargo:index:metadata"
        },
        "name": {
          "type": "string",
          "description": "The package name is an identifier used to refer to the package. It is used\nwhen listed as a dependency in another package, and as the default name of\ninferred lib and bin targets.\n\nThe name must use only [alphanumeric](https://doc.rust-lang.org/std/primitive.char.html#method.is_alphanumeric) characters or \u0060-\u0060 or \u0060_\u0060, and cannot be empty.\nNote that [\u0060cargo new\u0060](https://doc.rust-lang.org/cargo/commands/cargo-new.html) and [\u0060cargo init\u0060](https://doc.rust-lang.org/cargo/commands/cargo-init.html) impose some additional restrictions on\nthe package name, such as enforcing that it is a valid Rust identifier and not\na keyword. [crates.io](https://crates.io) imposes even more restrictions, such as\nenforcing only ASCII characters, not a reserved name, not a special Windows\nname such as \u0022nul\u0022, is not too long, etc."
        },
        "namespacedFeatures": {
          "type": "boolean"
        },
        "publish": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "publishLockfile": {
          "type": "boolean"
        },
        "readme": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "repository": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "resolver": {
          "$ref": "#/types/cargo:index:resolver"
        },
        "rustVersion": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "version": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "workspace": {
          "type": "string",
          "description": "The \u0060workspace\u0060 field can be used to configure the workspace that this package\nwill be a member of. If not specified this will be inferred as the first\nCargo.toml with \u0060[workspace]\u0060 upwards in the filesystem. Setting this is\nuseful if the member is not inside a subdirectory of the workspace root.\n\n\u0060\u0060\u0060toml\n[package]\n# ...\nworkspace = \u0022path/to/workspace/root\u0022\n\u0060\u0060\u0060\n\nThis field cannot be specified if the manifest already has a \u0060[workspace]\u0060\ntable defined. That is, a crate cannot both be a root crate in a workspace\n(contain \u0060[workspace]\u0060) and also be a member crate of another workspace\n(contain \u0060package.workspace\u0060).\n\nFor more information, see the [workspaces chapter](https://doc.rust-lang.org/cargo/reference/workspaces.html)."
        }
      },
      "required": [
        "name"
      ]
    },
    "cargo:index:packageEdition": {
      "description": "The \u0060edition\u0060 key affects which edition your package is compiled with. Cargo\nwill always generate packages via [\u0060cargo new\u0060](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the \u0060edition\u0060 key set to the\nlatest edition. Setting the \u0060edition\u0060 key in \u0060[package]\u0060 will affect all\ntargets/crates in the package, including test suites, benchmarks, binaries,\nexamples, etc.",
      "type": "string",
      "enum": [
        {
          "value": "2015"
        },
        {
          "value": "2018"
        },
        {
          "value": "2021"
        },
        {
          "value": "2024"
        }
      ]
    },
    "cargo:index:panic": {
      "description": "The \u0060panic\u0060 setting controls the [\u0060-C panic\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic) which controls which panic\nstrategy to use.\n\nWhen set to \u0060\u0022unwind\u0022\u0060, the actual value depends on the default of the target\nplatform. For example, the NVPTX platform does not support unwinding, so it\nalways uses \u0060\u0022abort\u0022\u0060.\n\nTests, benchmarks, build scripts, and proc macros ignore the \u0060panic\u0060 setting.\nThe \u0060rustc\u0060 test harness currently requires \u0060unwind\u0060 behavior. See the\n[\u0060panic-abort-tests\u0060](https://doc.rust-lang.org/cargo/reference/unstable.html#panic-abort-tests) unstable flag which enables \u0060abort\u0060 behavior.\n\nAdditionally, when using the \u0060abort\u0060 strategy and building a test, all of the\ndependencies will also be forced to built with the \u0060unwind\u0060 strategy.",
      "type": "string",
      "enum": [
        {
          "value": "unwind"
        },
        {
          "value": "abort"
        }
      ]
    },
    "cargo:index:platform": {
      "type": "object",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "buildDependencies": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "You can depend on other Cargo-based crates for use in your build scripts.\nDependencies are declared through the \u0060build-dependencies\u0060 section of the\nmanifest:\n\n\u0060\u0060\u0060toml\n[build-dependencies]\ncc = \u00221.0.3\u0022\n\u0060\u0060\u0060\n\nThe build script **does not** have access to the dependencies listed\nin the \u0060dependencies\u0060 or \u0060dev-dependencies\u0060 section. Build\ndependencies will likewise not be available to the package itself\nunless listed under the \u0060dependencies\u0060 section as well. A package\nitself and its build script are built separately, so their\ndependencies need not coincide. Cargo is kept simpler and cleaner by\nusing independent dependencies for independent purposes."
        },
        "buildDependencies0": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "dependencies": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Cargo is configured to look for dependencies on [crates.io](https://crates.io) by default. Only\nthe name and a version string are required in this case. In [the cargo\nguide](https://doc.rust-lang.org/cargo/guide/index.html), we specified a dependency on the \u0060time\u0060 crate:\n\n\u0060\u0060\u0060toml\n[dependencies]\ntime = \u00220.1.12\u0022\n\u0060\u0060\u0060\n\nThe string \u0060\u00220.1.12\u0022\u0060 is a [semver](https://github.com/steveklabnik/semver#requirements) version requirement. Since this\nstring does not have any operators in it, it is interpreted the same way as\nif we had specified \u0060\u0022^0.1.12\u0022\u0060, which is called a caret requirement.\n\nA dependency can also be defined by a table with additional options:\n\n\u0060\u0060\u0060toml\n[dependencies]\ntime = { path = \u0022../time\u0022, version = \u00220.1.12\u0022 }\n\u0060\u0060\u0060"
        },
        "devDependencies": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "The format of \u0060[dev-dependencies]\u0060 is equivalent to \u0060[dependencies]\u0060:\n\n\u0060\u0060\u0060toml\n[dev-dependencies]\ntempdir = \u00220.3\u0022\n\u0060\u0060\u0060\n\nDev-dependencies are not used when compiling\na package for building, but are used for compiling tests, examples, and\nbenchmarks.\n\nThese dependencies are *not* propagated to other packages which depend on this\npackage.\n\nYou can also have target-specific development dependencies by using\n\u0060dev-dependencies\u0060 in the target section header instead of \u0060dependencies\u0060. For\nexample:\n\n\u0060\u0060\u0060toml\n[target.\u0027cfg(unix)\u0027.dev-dependencies]\nmio = \u00220.0.1\u0022\n\u0060\u0060\u0060\n\n\u003E **Note**: When a package is published, only dev-dependencies that specify a\n\u003E \u0060version\u0060 will be included in the published crate. For most use cases,\n\u003E dev-dependencies are not needed when published, though some users (like OS\n\u003E packagers) may want to run tests within a crate, so providing a \u0060version\u0060 if\n\u003E possible can still be beneficial.\n"
        },
        "devDependencies0": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        }
      }
    },
    "cargo:index:playdatePackageMetadata": {
      "type": "object",
      "description": "Metadata and build configuration.",
      "properties": {
        "assets": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "author": {
          "type": "string"
        },
        "buildNumber": {
          "type": "integer",
          "description": "A monotonically-increasing integer value used to indicate a unique version of your game. This can be set using an automated build process like Continuous Integration to avoid having to set the value by hand.\n\nFor sideloaded games, buildNumber is required and is used to determine when a newer version is available to download."
        },
        "bundleId": {
          "type": "string",
          "description": "A unique identifier for your game, in reverse DNS notation."
        },
        "contentWarning": {
          "type": "string",
          "description": "Optional. A content warning that displays when the user launches your game for the first time. The user will have the option of backing out and not launching your game if they choose."
        },
        "contentWarning2": {
          "type": "string",
          "description": "Optional. A second content warning that displays on a second screen when the user launches your game for the first time. The user will have the option of backing out and not launching your game if they choose.\n\nNote: \u0060content-warning2\u0060 will only display if a \u0060content-warning\u0060 attribute is also specified.\n\nThe string displayed on the content warning screen can only be so long before it will be truncated with an \u0022\u2026\u0022 character. Be sure to keep this in mind when designing your \u0060content-warning\u0060 and \u0060content-warning2\u0060 text."
        },
        "description": {
          "type": "string"
        },
        "devAssets": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.AnyOfKeyword"
        },
        "imagePath": {
          "type": "string",
          "description": "A directory of images that will be used by the launcher.\n\nMore in [official documentation](https://sdk.play.date/#pdxinfo)."
        },
        "launchSoundPath": {
          "type": "string",
          "description": "Should point to the path of a short audio file to be played as the game launch animation is taking place.\n\nMore in [official documentation](https://sdk.play.date/#pdxinfo)."
        },
        "name": {
          "type": "string",
          "description": "A game version number, formatted any way you wish, that is displayed to players. It is not used to compute when updates should occur."
        },
        "options": {
          "$ref": "#/types/cargo:index:configuration"
        },
        "support": {
          "$ref": "#/types/cargo:index:support"
        },
        "version": {
          "type": "string"
        }
      },
      "required": [
        "bundleId"
      ]
    },
    "cargo:index:profile": {
      "type": "object",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "buildOverride": {
          "$ref": "#/types/cargo:index:profile"
        },
        "codegenUnits": {
          "type": "integer",
          "description": "The \u0060codegen-units\u0060 setting controls the [\u0060-C codegen-units\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#codegen-units) which\ncontrols how many \u0022code generation units\u0022 a crate will be split into. More\ncode generation units allows more of a crate to be processed in parallel\npossibly reducing compile time, but may produce slower code.\n\nThis option takes an integer greater than 0.\n\nThe default is 256 for [incremental](https://doc.rust-lang.org/cargo/reference/profiles.html#incremental) builds, and 16 for\nnon-incremental builds."
        },
        "debug": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "debugAssertions": {
          "type": "boolean",
          "description": "The \u0060debug-assertions\u0060 setting controls the [\u0060-C debug-assertions\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#debug-assertions) which\nturns \u0060cfg(debug_assertions)\u0060 [conditional compilation](https://doc.rust-lang.org/reference/conditional-compilation.html#debug_assertions) on or off. Debug\nassertions are intended to include runtime validation which is only available\nin debug/development builds. These may be things that are too expensive or\notherwise undesirable in a release build. Debug assertions enables the\n[\u0060debug_assert!\u0060 macro](https://doc.rust-lang.org/std/macro.debug_assert.html) in the standard library."
        },
        "dirName": {
          "type": "string"
        },
        "incremental": {
          "type": "boolean",
          "description": "The \u0060incremental\u0060 setting controls the [\u0060-C incremental\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#incremental) which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses \u0060rustc\u0060 to to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times. The additional\ninformation is stored in the \u0060target\u0060 directory.\n\nThe valid options are:\n\n* \u0060true\u0060: enabled\n* \u0060false\u0060: disabled\n\nIncremental compilation is only used for workspace members and \u0022path\u0022\ndependencies.\n\nThe incremental value can be overridden globally with the \u0060CARGO_INCREMENTAL\u0060\n[environment variable](https://doc.rust-lang.org/cargo/reference/environment-variables.html) or the [\u0060build.incremental\u0060](https://doc.rust-lang.org/cargo/reference/config.html#buildincremental) config variable."
        },
        "inherits": {
          "type": "string"
        },
        "lto": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "optLevel": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "overflowChecks": {
          "type": "boolean",
          "description": "The \u0060overflow-checks\u0060 setting controls the [\u0060-C overflow-checks\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#overflow-checks) which\ncontrols the behavior of [runtime integer overflow](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow). When overflow-checks are\nenabled, a panic will occur on overflow."
        },
        "package": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/types/cargo:index:profile"
          },
          "description": "Package-specific overrides.\n\nThe package name is a [Package ID Spec](https://doc.rust-lang.org/cargo/reference/pkgid-spec.html), so you can\ntarget individual versions of a package with syntax such as \u0060[profile.dev.package.\u0022foo:2.1.0\u0022]\u0060."
        },
        "panic": {
          "$ref": "#/types/cargo:index:panic"
        },
        "rpath": {
          "type": "boolean",
          "description": "The \u0060rpath\u0060 setting controls the [\u0060-C rpath\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#rpath) which controls\nwhether or not [\u0060rpath\u0060](https://en.wikipedia.org/wiki/Rpath) is enabled."
        }
      }
    },
    "cargo:index:profiles": {
      "type": "object",
      "description": "Profiles provide a way to alter the compiler settings, influencing things like optimizations and debugging symbols.\n\nCargo has 4 built-in profiles: dev, release, test, and bench. It automatically chooses the profile based on which command is being run, the package and target that is being built, and command-line flags like --release.",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/types/cargo:index:profile"
          }
        },
        "bench": {
          "$ref": "#/types/cargo:index:definitionsProfile"
        },
        "dev": {
          "$ref": "#/types/cargo:index:dev"
        },
        "release": {
          "$ref": "#/types/cargo:index:release"
        },
        "test": {
          "$ref": "#/types/cargo:index:test"
        }
      }
    },
    "cargo:index:propertiesPackage": {
      "type": "object",
      "description": "The \u0060workspace.package\u0060 table is where you define keys that can be\ninherited by members of a workspace. These keys can be inherited by\ndefining them in the member package with \u0060{key}.workspace = true\u0060.\n\nKeys that are supported:\n\n|                |                 |\n|----------------|-----------------|\n| \u0060authors\u0060      | \u0060categories\u0060    |\n| \u0060description\u0060  | \u0060documentation\u0060 |\n| \u0060edition\u0060      | \u0060exclude\u0060       |\n| \u0060homepage\u0060     | \u0060include\u0060       |\n| \u0060keywords\u0060     | \u0060license\u0060       |\n| \u0060license-file\u0060 | \u0060publish\u0060       |\n| \u0060readme\u0060       | \u0060repository\u0060    |\n| \u0060rust-version\u0060 | \u0060version\u0060       |\n\n- \u0060license-file\u0060 and \u0060readme\u0060 are relative to the workspace root\n- \u0060include\u0060 and \u0060exclude\u0060 are relative to your package root\n\nExample:\n\u0060\u0060\u0060toml\n# [PROJECT_DIR]/Cargo.toml\n[workspace]\nmembers = [\u0022bar\u0022]\n\n[workspace.package]\nversion = \u00221.2.3\u0022\nauthors = [\u0022Nice Folks\u0022]\ndescription = \u0022A short description of my package\u0022\ndocumentation = \u0022https://example.com/bar\u0022\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060toml\n# [PROJECT_DIR]/bar/Cargo.toml\n[package]\nname = \u0022bar\u0022\nversion.workspace = true\nauthors.workspace = true\ndescription.workspace = true\ndocumentation.workspace = true\n\u0060\u0060\u0060",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "authors": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The \u0060authors\u0060 field lists people or organizations that are considered the\n\u0022authors\u0022 of the package. The exact meaning is open to interpretation \u2014 it may\nlist the original or primary authors, current maintainers, or owners of the\npackage. These names will be listed on the crate\u0027s page on\n[crates.io](https://crates.io). An optional email address may be included within angled\nbrackets at the end of each author.\n\n\u003E **Note**: [crates.io](https://crates.io) requires at least one author to be listed."
        },
        "categories": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The \u0060categories\u0060 field is an array of strings of the categories this package\nbelongs to.\n\n\u0060\u0060\u0060toml\ncategories = [\u0022command-line-utilities\u0022, \u0022development-tools::cargo-plugins\u0022]\n\u0060\u0060\u0060\n\n\u003E **Note**: [crates.io](https://crates.io) has a maximum of 5 categories. Each category should\n\u003E match one of the strings available at https://crates.io/category_slugs, and\n\u003E must match exactly."
        },
        "description": {
          "type": "string",
          "description": "The description is a short blurb about the package. [crates.io](https://crates.io) will display\nthis with your package. This should be plain text (not Markdown).\n\n\u0060\u0060\u0060toml\n[package]\n# ...\ndescription = \u0022A short description of my package\u0022\n\u0060\u0060\u0060\n\n\u003E **Note**: [crates.io](https://crates.io) requires the \u0060description\u0060 to be set."
        },
        "documentation": {
          "type": "string",
          "description": "\nThe \u0060documentation\u0060 field specifies a URL to a website hosting the crate\u0027s\ndocumentation. If no URL is specified in the manifest file, [crates.io](https://crates.io) will\nautomatically link your crate to the corresponding [docs.rs](https://docs.rs) page.\n\n\u0060\u0060\u0060toml\n[package]\n# ...\ndocumentation = \u0022https://docs.rs/bitflags\u0022\n\u0060\u0060\u0060\n"
        },
        "edition": {
          "$ref": "#/types/cargo:index:packageEdition"
        },
        "exclude": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "You can explicitly specify that a set of file patterns should be ignored or\nincluded for the purposes of packaging. The patterns specified in the\n\u0060exclude\u0060 field identify a set of files that are not included, and the\npatterns in \u0060include\u0060 specify files that are explicitly included.\n\nThe patterns should be [gitignore](https://git-scm.com/docs/gitignore)-style patterns. Briefly:\n\n- \u0060foo\u0060 matches any file or directory with the name \u0060foo\u0060 anywhere in the\n  package. This is equivalent to the pattern \u0060**/foo\u0060.\n- \u0060/foo\u0060 matches any file or directory with the name \u0060foo\u0060 only in the root of\n  the package.\n- \u0060foo/\u0060 matches any *directory* with the name \u0060foo\u0060 anywhere in the package.\n- Common glob patterns like \u0060*\u0060, \u0060?\u0060, and \u0060[]\u0060 are supported:\n  - \u0060*\u0060 matches zero or more characters except \u0060/\u0060.  For example, \u0060*.html\u0060\n    matches any file or directory with the \u0060.html\u0060 extension anywhere in the\n    package.\n  - \u0060?\u0060 matches any character except \u0060/\u0060. For example, \u0060foo?\u0060 matches \u0060food\u0060,\n    but not \u0060foo\u0060.\n  - \u0060[]\u0060 allows for matching a range of characters. For example, \u0060[ab]\u0060\n    matches either \u0060a\u0060 or \u0060b\u0060. \u0060[a-z]\u0060 matches letters a through z.\n- \u0060**/\u0060 prefix matches in any directory. For example, \u0060**/foo/bar\u0060 matches the\n  file or directory \u0060bar\u0060 anywhere that is directly under directory \u0060foo\u0060.\n- \u0060/**\u0060 suffix matches everything inside. For example, \u0060foo/**\u0060 matches all\n  files inside directory \u0060foo\u0060, including all files in subdirectories below\n  \u0060foo\u0060.\n- \u0060/**/\u0060 matches zero or more directories. For example, \u0060a/**/b\u0060 matches\n  \u0060a/b\u0060, \u0060a/x/b\u0060, \u0060a/x/y/b\u0060, and so on.\n- \u0060!\u0060 prefix negates a pattern. For example, a pattern of \u0060src/**.rs\u0060 and\n  \u0060!foo.rs\u0060 would match all files with the \u0060.rs\u0060 extension inside the \u0060src\u0060\n  directory, except for any file named \u0060foo.rs\u0060.\n\nIf git is being used for a package, the \u0060exclude\u0060 field will be seeded with\nthe \u0060gitignore\u0060 settings from the repository.\n\n\u0060\u0060\u0060toml\n[package]\n# ...\nexclude = [\u0022build/**/*.o\u0022, \u0022doc/**/*.html\u0022]\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060toml\n[package]\n# ...\ninclude = [\u0022src/**/*\u0022, \u0022Cargo.toml\u0022]\n\u0060\u0060\u0060\n\nThe options are mutually exclusive: setting \u0060include\u0060 will override an\n\u0060exclude\u0060. Note that \u0060include\u0060 must be an exhaustive list of files as otherwise\nnecessary source files may not be included. The package\u0027s \u0060Cargo.toml\u0060 is\nautomatically included.\n\nThe include/exclude list is also used for change tracking in some situations.\nFor targets built with \u0060rustdoc\u0060, it is used to determine the list of files to\ntrack to determine if the target should be rebuilt. If the package has a\n[build script](https://doc.rust-lang.org/cargo/reference/build-scripts.html) that does not emit any \u0060rerun-if-*\u0060 directives, then the\ninclude/exclude list is used for tracking if the build script should be re-run\nif any of those files change."
        },
        "homepage": {
          "type": "string",
          "description": "The \u0060homepage\u0060 field should be a URL to a site that is the home page for your\npackage.\n\n\u0060\u0060\u0060toml\n[package]\n# ...\nhomepage = \u0022https://serde.rs/\u0022\n\u0060\u0060\u0060"
        },
        "include": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "You can explicitly specify that a set of file patterns should be ignored or\nincluded for the purposes of packaging. The patterns specified in the\n\u0060exclude\u0060 field identify a set of files that are not included, and the\npatterns in \u0060include\u0060 specify files that are explicitly included.\n\nThe patterns should be [gitignore](https://git-scm.com/docs/gitignore)-style patterns. Briefly:\n\n- \u0060foo\u0060 matches any file or directory with the name \u0060foo\u0060 anywhere in the\n  package. This is equivalent to the pattern \u0060**/foo\u0060.\n- \u0060/foo\u0060 matches any file or directory with the name \u0060foo\u0060 only in the root of\n  the package.\n- \u0060foo/\u0060 matches any *directory* with the name \u0060foo\u0060 anywhere in the package.\n- Common glob patterns like \u0060*\u0060, \u0060?\u0060, and \u0060[]\u0060 are supported:\n  - \u0060*\u0060 matches zero or more characters except \u0060/\u0060.  For example, \u0060*.html\u0060\n    matches any file or directory with the \u0060.html\u0060 extension anywhere in the\n    package.\n  - \u0060?\u0060 matches any character except \u0060/\u0060. For example, \u0060foo?\u0060 matches \u0060food\u0060,\n    but not \u0060foo\u0060.\n  - \u0060[]\u0060 allows for matching a range of characters. For example, \u0060[ab]\u0060\n    matches either \u0060a\u0060 or \u0060b\u0060. \u0060[a-z]\u0060 matches letters a through z.\n- \u0060**/\u0060 prefix matches in any directory. For example, \u0060**/foo/bar\u0060 matches the\n  file or directory \u0060bar\u0060 anywhere that is directly under directory \u0060foo\u0060.\n- \u0060/**\u0060 suffix matches everything inside. For example, \u0060foo/**\u0060 matches all\n  files inside directory \u0060foo\u0060, including all files in subdirectories below\n  \u0060foo\u0060.\n- \u0060/**/\u0060 matches zero or more directories. For example, \u0060a/**/b\u0060 matches\n  \u0060a/b\u0060, \u0060a/x/b\u0060, \u0060a/x/y/b\u0060, and so on.\n- \u0060!\u0060 prefix negates a pattern. For example, a pattern of \u0060src/**.rs\u0060 and\n  \u0060!foo.rs\u0060 would match all files with the \u0060.rs\u0060 extension inside the \u0060src\u0060\n  directory, except for any file named \u0060foo.rs\u0060.\n\nIf git is being used for a package, the \u0060exclude\u0060 field will be seeded with\nthe \u0060gitignore\u0060 settings from the repository.\n\n\u0060\u0060\u0060toml\n[package]\n# ...\nexclude = [\u0022build/**/*.o\u0022, \u0022doc/**/*.html\u0022]\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060toml\n[package]\n# ...\ninclude = [\u0022src/**/*\u0022, \u0022Cargo.toml\u0022]\n\u0060\u0060\u0060\n\nThe options are mutually exclusive: setting \u0060include\u0060 will override an\n\u0060exclude\u0060. Note that \u0060include\u0060 must be an exhaustive list of files as otherwise\nnecessary source files may not be included. The package\u0027s \u0060Cargo.toml\u0060 is\nautomatically included.\n\nThe include/exclude list is also used for change tracking in some situations.\nFor targets built with \u0060rustdoc\u0060, it is used to determine the list of files to\ntrack to determine if the target should be rebuilt. If the package has a\n[build script](https://doc.rust-lang.org/cargo/reference/build-scripts.html) that does not emit any \u0060rerun-if-*\u0060 directives, then the\ninclude/exclude list is used for tracking if the build script should be re-run\nif any of those files change."
        },
        "keywords": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The \u0060keywords\u0060 field is an array of strings that describe this package. This\ncan help when searching for the package on a registry, and you may choose any\nwords that would help someone find this crate.\n\n\u0060\u0060\u0060toml\n[package]\n# ...\nkeywords = [\u0022gamedev\u0022, \u0022graphics\u0022]\n\u0060\u0060\u0060\n\n\u003E **Note**: [crates.io](https://crates.io) has a maximum of 5 keywords. Each keyword must be\n\u003E ASCII text, start with a letter, and only contain letters, numbers, \u0060_\u0060 or\n\u003E \u0060-\u0060, and have at most 20 characters."
        },
        "license": {
          "type": "string",
          "description": "The \u0060license\u0060 field contains the name of the software license that the package\nis released under.\n\n[crates.io](https://crates.io/) interprets the \u0060license\u0060 field as an [SPDX 2.1 license\nexpression](https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60). The name must be a known license\nfrom the [SPDX license list 3.6](https://github.com/spdx/license-list-data/tree/v3.6). Parentheses are not\ncurrently supported. See the [SPDX site](https://spdx.org/license-list) for more information.\n\nSPDX license expressions support AND and OR operators to combine multiple\nlicenses.\n\n\u0060\u0060\u0060toml\n[package]\n# ...\nlicense = \u0022MIT OR Apache-2.0\u0022\n\u0060\u0060\u0060\n\nUsing \u0060OR\u0060 indicates the user may choose either license. Using \u0060AND\u0060 indicates\nthe user must comply with both licenses simultaneously. The \u0060WITH\u0060 operator\nindicates a license with a special exception. Some examples:\n\n* \u0060MIT OR Apache-2.0\u0060\n* \u0060LGPL-2.1 AND MIT AND BSD-2-Clause\u0060\n* \u0060GPL-2.0\u002B WITH Bison-exception-2.2\u0060\n\nIf a package is using a nonstandard license, then the \u0060license-file\u0060 field may\nbe specified in lieu of the \u0060license\u0060 field."
        },
        "licenseFile": {
          "type": "string",
          "description": "The \u0060license-file\u0060 field contains the path to a file\ncontaining the text of the license (relative to this \u0060Cargo.toml\u0060).\n\n\u0060\u0060\u0060toml\n[package]\n# ...\nlicense-file = \u0022LICENSE.txt\u0022\n\u0060\u0060\u0060\n\n\u003E **Note**: [crates.io](https://crates.io) requires either \u0060license\u0060 or \u0060license-file\u0060 to be set."
        },
        "publish": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.AnyOfKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "readme": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.AnyOfKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "repository": {
          "type": "string",
          "description": "The \u0060repository\u0060 field should be a URL to the source repository for your\npackage.\n\n\u0060\u0060\u0060toml\n[package]\n# ...\nrepository = \u0022https://github.com/rust-lang/cargo/\u0022\n\u0060\u0060\u0060"
        },
        "rustVersion": {
          "type": "string",
          "description": "The \u0060rust-version\u0060 field is an optional key that tells cargo what version of the\nRust language and compiler your package can be compiled with. If the currently\nselected version of the Rust compiler is older than the stated version, cargo\nwill exit with an error, telling the user what version is required.\n\nThe first version of Cargo that supports this field was released with Rust 1.56.0.\nIn older releases, the field will be ignored, and Cargo will display a warning.\n\n\u0060\u0060\u0060toml\n[package]\n# ...\nrust-version = \u00221.56\u0022\n\u0060\u0060\u0060\n\nThe Rust version must be a bare version number with two or three components; it\ncannot include semver operators or pre-release identifiers. Compiler pre-release\nidentifiers such as -nightly will be ignored while checking the Rust version.\nThe \u0060rust-version\u0060 must be equal to or newer than the version that first\nintroduced the configured \u0060edition\u0060.\n\nThe \u0060rust-version\u0060 may be ignored using the \u0060--ignore-rust-version\u0060 option.\n\nSetting the \u0060rust-version\u0060 key in \u0060[package]\u0060 will affect all targets/crates in\nthe package, including test suites, benchmarks, binaries, examples, etc."
        },
        "version": {
          "type": "string",
          "description": "Cargo bakes in the concept of [Semantic Versioning](https://semver.org/), so make sure you follow some basic rules:\n\n* Before you reach 1.0.0, anything goes, but if you make breaking changes,\n    increment the minor version. In Rust, breaking changes include adding fields to\n    structs or variants to enums.\n* After 1.0.0, only make breaking changes when you increment the major version.\n    Don\u0027t break the build.\n* After 1.0.0, don\u0027t add any new public API (no new \u0060pub\u0060 anything) in patch-level\n    versions. Always increment the minor version if you add any new \u0060pub\u0060 structs,\n    traits, fields, types, functions, methods or anything else.\n* Use version numbers with three numeric parts such as 1.0.0 rather than 1.0."
        }
      }
    },
    "cargo:index:release": {
      "type": "object",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "buildOverride": {
          "$ref": "#/types/cargo:index:release"
        },
        "codegenUnits": {
          "type": "integer",
          "description": "The \u0060codegen-units\u0060 setting controls the [\u0060-C codegen-units\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#codegen-units) which\ncontrols how many \u0022code generation units\u0022 a crate will be split into. More\ncode generation units allows more of a crate to be processed in parallel\npossibly reducing compile time, but may produce slower code.\n\nThis option takes an integer greater than 0.\n\nThe default is 256 for [incremental](https://doc.rust-lang.org/cargo/reference/profiles.html#incremental) builds, and 16 for\nnon-incremental builds."
        },
        "debug": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "debugAssertions": {
          "type": "boolean",
          "description": "The \u0060debug-assertions\u0060 setting controls the [\u0060-C debug-assertions\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#debug-assertions) which\nturns \u0060cfg(debug_assertions)\u0060 [conditional compilation](https://doc.rust-lang.org/reference/conditional-compilation.html#debug_assertions) on or off. Debug\nassertions are intended to include runtime validation which is only available\nin debug/development builds. These may be things that are too expensive or\notherwise undesirable in a release build. Debug assertions enables the\n[\u0060debug_assert!\u0060 macro](https://doc.rust-lang.org/std/macro.debug_assert.html) in the standard library."
        },
        "dirName": {
          "type": "string"
        },
        "incremental": {
          "type": "boolean",
          "description": "The \u0060incremental\u0060 setting controls the [\u0060-C incremental\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#incremental) which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses \u0060rustc\u0060 to to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times. The additional\ninformation is stored in the \u0060target\u0060 directory.\n\nThe valid options are:\n\n* \u0060true\u0060: enabled\n* \u0060false\u0060: disabled\n\nIncremental compilation is only used for workspace members and \u0022path\u0022\ndependencies.\n\nThe incremental value can be overridden globally with the \u0060CARGO_INCREMENTAL\u0060\n[environment variable](https://doc.rust-lang.org/cargo/reference/environment-variables.html) or the [\u0060build.incremental\u0060](https://doc.rust-lang.org/cargo/reference/config.html#buildincremental) config variable."
        },
        "inherits": {
          "type": "string"
        },
        "lto": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "optLevel": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "overflowChecks": {
          "type": "boolean",
          "description": "The \u0060overflow-checks\u0060 setting controls the [\u0060-C overflow-checks\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#overflow-checks) which\ncontrols the behavior of [runtime integer overflow](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow). When overflow-checks are\nenabled, a panic will occur on overflow."
        },
        "package": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/types/cargo:index:release"
          },
          "description": "Package-specific overrides.\n\nThe package name is a [Package ID Spec](https://doc.rust-lang.org/cargo/reference/pkgid-spec.html), so you can\ntarget individual versions of a package with syntax such as \u0060[profile.dev.package.\u0022foo:2.1.0\u0022]\u0060."
        },
        "panic": {
          "$ref": "#/types/cargo:index:releasePanic"
        },
        "rpath": {
          "type": "boolean",
          "description": "The \u0060rpath\u0060 setting controls the [\u0060-C rpath\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#rpath) which controls\nwhether or not [\u0060rpath\u0060](https://en.wikipedia.org/wiki/Rpath) is enabled."
        }
      }
    },
    "cargo:index:releasePanic": {
      "description": "The \u0060panic\u0060 setting controls the [\u0060-C panic\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic) which controls which panic\nstrategy to use.\n\nWhen set to \u0060\u0022unwind\u0022\u0060, the actual value depends on the default of the target\nplatform. For example, the NVPTX platform does not support unwinding, so it\nalways uses \u0060\u0022abort\u0022\u0060.\n\nTests, benchmarks, build scripts, and proc macros ignore the \u0060panic\u0060 setting.\nThe \u0060rustc\u0060 test harness currently requires \u0060unwind\u0060 behavior. See the\n[\u0060panic-abort-tests\u0060](https://doc.rust-lang.org/cargo/reference/unstable.html#panic-abort-tests) unstable flag which enables \u0060abort\u0060 behavior.\n\nAdditionally, when using the \u0060abort\u0060 strategy and building a test, all of the\ndependencies will also be forced to built with the \u0060unwind\u0060 strategy.",
      "type": "string",
      "enum": [
        {
          "value": "unwind"
        },
        {
          "value": "abort"
        }
      ]
    },
    "cargo:index:resolver": {
      "description": "A different feature resolver algorithm can be used by specifying the resolver version in Cargo.toml like this:\n\n[package]\nname = \u0022my-package\u0022\nversion = \u00221.0.0\u0022\nresolver = \u00222\u0022\n\nThe version \u00221\u0022 resolver is the original resolver that shipped with Cargo up to version 1.50. The default is \u00222\u0022 if the root package specifies edition = \u00222021\u0022 or a newer edition. Otherwise the default is \u00221\u0022.\n\nThe version \u00222\u0022 resolver introduces changes in feature unification. See the features chapter for more details.\n\nThe resolver is a global option that affects the entire workspace. The resolver version in dependencies is ignored, only the value in the top-level package will be used. If using a virtual workspace, the version should be specified in the [workspace] table, for example:\n\n[workspace]\nmembers = [\u0022member1\u0022, \u0022member2\u0022]\nresolver = \u00222\u0022",
      "type": "string",
      "enum": [
        {
          "value": "1"
        },
        {
          "value": "2"
        },
        {
          "value": "3"
        }
      ]
    },
    "cargo:index:root": {
      "type": "object",
      "description": "A schema for Cargo.toml.",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "badges": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "description": "[crates.io](https://crates.io) can display various badges for build status, test coverage, etc. for\neach crate. All badges are optional.\n\n- The badges pertaining to build status that are currently available are\n  Appveyor, CircleCI, Cirrus CI, GitLab, Azure DevOps, Travis CI and Bitbucket\n  Pipelines.\n- Available badges pertaining to code test coverage are Codecov and Coveralls.\n- There are also maintenance-related badges based on isitmaintained.com\n  which state the issue resolution time, percent of open issues, and future\n  maintenance intentions.\n\nMost badge specifications require a \u0060repository\u0060 key. It is expected to be in\n\u0060user/repo\u0060 format.\n\n\u0060\u0060\u0060toml\n[badges]\n\n# Appveyor: \u0060repository\u0060 is required. \u0060branch\u0060 is optional; default is \u0060master\u0060\n# \u0060service\u0060 is optional; valid values are \u0060github\u0060 (default), \u0060bitbucket\u0060, and\n# \u0060gitlab\u0060; \u0060id\u0060 is optional; you can specify the appveyor project id if you\n# want to use that instead. \u0060project_name\u0060 is optional; use when the repository\n# name differs from the appveyor project name.\nappveyor = { repository = \u0022...\u0022, branch = \u0022master\u0022, service = \u0022github\u0022 }\n\n# Circle CI: \u0060repository\u0060 is required. \u0060branch\u0060 is optional; default is \u0060master\u0060\ncircle-ci = { repository = \u0022...\u0022, branch = \u0022master\u0022 }\n\n# Cirrus CI: \u0060repository\u0060 is required. \u0060branch\u0060 is optional; default is \u0060master\u0060\ncirrus-ci = { repository = \u0022...\u0022, branch = \u0022master\u0022 }\n\n# GitLab: \u0060repository\u0060 is required. \u0060branch\u0060 is optional; default is \u0060master\u0060\ngitlab = { repository = \u0022...\u0022, branch = \u0022master\u0022 }\n\n# Azure DevOps: \u0060project\u0060 is required. \u0060pipeline\u0060 is required. \u0060build\u0060 is optional; default is \u00601\u0060\n# Note: project = \u0060organization/project\u0060, pipeline = \u0060name_of_pipeline\u0060, build = \u0060definitionId\u0060\nazure-devops = { project = \u0022...\u0022, pipeline = \u0022...\u0022, build=\u00222\u0022 }\n\n# Travis CI: \u0060repository\u0060 in format \u0022\u003Cuser\u003E/\u003Cproject\u003E\u0022 is required.\n# \u0060branch\u0060 is optional; default is \u0060master\u0060\ntravis-ci = { repository = \u0022...\u0022, branch = \u0022master\u0022 }\n\n# Bitbucket Pipelines: \u0060repository\u0060 is required. \u0060branch\u0060 is required\nbitbucket-pipelines = { repository = \u0022...\u0022, branch = \u0022master\u0022 }\n\n# Codecov: \u0060repository\u0060 is required. \u0060branch\u0060 is optional; default is \u0060master\u0060\n# \u0060service\u0060 is optional; valid values are \u0060github\u0060 (default), \u0060bitbucket\u0060, and\n# \u0060gitlab\u0060.\ncodecov = { repository = \u0022...\u0022, branch = \u0022master\u0022, service = \u0022github\u0022 }\n\n# Coveralls: \u0060repository\u0060 is required. \u0060branch\u0060 is optional; default is \u0060master\u0060\n# \u0060service\u0060 is optional; valid values are \u0060github\u0060 (default) and \u0060bitbucket\u0060.\ncoveralls = { repository = \u0022...\u0022, branch = \u0022master\u0022, service = \u0022github\u0022 }\n\n# Is it maintained resolution time: \u0060repository\u0060 is required.\nis-it-maintained-issue-resolution = { repository = \u0022...\u0022 }\n\n# Is it maintained percentage of open issues: \u0060repository\u0060 is required.\nis-it-maintained-open-issues = { repository = \u0022...\u0022 }\n\n# Maintenance: \u0060status\u0060 is required. Available options are:\n# - \u0060actively-developed\u0060: New features are being added and bugs are being fixed.\n# - \u0060passively-maintained\u0060: There are no plans for new features, but the maintainer intends to\n#   respond to issues that get filed.\n# - \u0060as-is\u0060: The crate is feature complete, the maintainer does not intend to continue working on\n#   it or providing support, but it works for the purposes it was designed for.\n# - \u0060experimental\u0060: The author wants to share it with the community but is not intending to meet\n#   anyone\u0027s particular use case.\n# - \u0060looking-for-maintainer\u0060: The current maintainer would like to transfer the crate to someone\n#   else.\n# - \u0060deprecated\u0060: The maintainer does not recommend using this crate (the description of the crate\n#   can describe why, there could be a better solution available or there could be problems with\n#   the crate that the author does not want to fix).\n# - \u0060none\u0060: Displays no badge on crates.io, since the maintainer has not chosen to specify\n#   their intentions, potential crate users will need to investigate on their own.\nmaintenance = { status = \u0022...\u0022 }\n\u0060\u0060\u0060"
        },
        "bench": {
          "type": "array",
          "items": {
            "$ref": "#/types/cargo:index:target"
          },
          "description": "Benchmarks provide a way to test the performance of your code using the\n[\u0060cargo bench\u0060](https://doc.rust-lang.org/cargo/commands/cargo-bench.html) command. They follow the same structure as [tests](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#tests),\nwith each benchmark function annotated with the \u0060#[bench]\u0060 attribute.\nSimilarly to tests:\n\n* Benchmarks are placed in the [\u0060benches\u0060 directory](https://doc.rust-lang.org/cargo/guide/project-layout.html).\n* Benchmark functions defined in libraries and binaries have access to the\n  *private* API within the target they are defined in. Benchmarks in the\n  \u0060benches\u0060 directory may use the *public* API.\n* [The \u0060bench\u0060 field](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-bench-field) can be used to define which targets\n  are benchmarked by default.\n* [The \u0060harness\u0060 field](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-harness-field) can be used to disable the\n  built-in harness.\n\n\u003E **Note**: The [\u0060#[bench]\u0060\n\u003E attribute](https://doc.rust-lang.org/unstable-book/library-features/test.html) is currently\n\u003E unstable and only available on the [nightly channel](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html). There are some\n\u003E packages available on [crates.io](https://crates.io/keywords/benchmark) that\n\u003E may help with running benchmarks on the stable channel, such as\n\u003E [Criterion](https://crates.io/crates/criterion)."
        },
        "bin": {
          "type": "array",
          "items": {
            "$ref": "#/types/cargo:index:definitionsTarget"
          },
          "description": "Binary targets are executable programs that can be run after being compiled.\nThe default binary filename is \u0060src/main.rs\u0060, which defaults to the name of\nthe package. Additional binaries are stored in the [\u0060src/bin/\u0060\ndirectory](https://doc.rust-lang.org/cargo/guide/project-layout.html). The settings for each binary can be [customized](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#configuring-a-target) in the \u0060[[bin]]\u0060 tables in \u0060Cargo.toml\u0060.\n\nBinaries can use the public API of the package\u0027s library. They are also linked\nwith the [\u0060[dependencies]\u0060](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) defined in \u0060Cargo.toml\u0060.\n\nYou can run individual binaries with the [\u0060cargo run\u0060](https://doc.rust-lang.org/cargo/commands/cargo-run.html) command with the \u0060--bin\n\u003Cbin-name\u003E\u0060 option. [\u0060cargo install\u0060](https://doc.rust-lang.org/cargo/commands/cargo-install.html) can be used to copy the executable to a\ncommon location.\n\n\u0060\u0060\u0060toml\n# Example of customizing binaries in Cargo.toml.\n[[bin]]\nname = \u0022cool-tool\u0022\ntest = false\nbench = false\n\n[[bin]]\nname = \u0022frobnicator\u0022\nrequired-features = [\u0022frobnicate\u0022]\n\u0060\u0060\u0060"
        },
        "buildDependencies": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "You can depend on other Cargo-based crates for use in your build scripts.\nDependencies are declared through the \u0060build-dependencies\u0060 section of the\nmanifest:\n\n\u0060\u0060\u0060toml\n[build-dependencies]\ncc = \u00221.0.3\u0022\n\u0060\u0060\u0060\n\nThe build script **does not** have access to the dependencies listed\nin the \u0060dependencies\u0060 or \u0060dev-dependencies\u0060 section. Build\ndependencies will likewise not be available to the package itself\nunless listed under the \u0060dependencies\u0060 section as well. A package\nitself and its build script are built separately, so their\ndependencies need not coincide. Cargo is kept simpler and cleaner by\nusing independent dependencies for independent purposes."
        },
        "buildDependencies0": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "cargoFeatures": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "dependencies": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Cargo is configured to look for dependencies on [crates.io](https://crates.io) by default. Only\nthe name and a version string are required in this case. In [the cargo\nguide](https://doc.rust-lang.org/cargo/guide/index.html), we specified a dependency on the \u0060time\u0060 crate:\n\n\u0060\u0060\u0060toml\n[dependencies]\ntime = \u00220.1.12\u0022\n\u0060\u0060\u0060\n\nThe string \u0060\u00220.1.12\u0022\u0060 is a [semver](https://github.com/steveklabnik/semver#requirements) version requirement. Since this\nstring does not have any operators in it, it is interpreted the same way as\nif we had specified \u0060\u0022^0.1.12\u0022\u0060, which is called a caret requirement.\n\nA dependency can also be defined by a table with additional options:\n\n\u0060\u0060\u0060toml\n[dependencies]\ntime = { path = \u0022../time\u0022, version = \u00220.1.12\u0022 }\n\u0060\u0060\u0060"
        },
        "devDependencies": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "The format of \u0060[dev-dependencies]\u0060 is equivalent to \u0060[dependencies]\u0060:\n\n\u0060\u0060\u0060toml\n[dev-dependencies]\ntempdir = \u00220.3\u0022\n\u0060\u0060\u0060\n\nDev-dependencies are not used when compiling\na package for building, but are used for compiling tests, examples, and\nbenchmarks.\n\nThese dependencies are *not* propagated to other packages which depend on this\npackage.\n\nYou can also have target-specific development dependencies by using\n\u0060dev-dependencies\u0060 in the target section header instead of \u0060dependencies\u0060. For\nexample:\n\n\u0060\u0060\u0060toml\n[target.\u0027cfg(unix)\u0027.dev-dependencies]\nmio = \u00220.0.1\u0022\n\u0060\u0060\u0060\n\n\u003E **Note**: When a package is published, only dev-dependencies that specify a\n\u003E \u0060version\u0060 will be included in the published crate. For most use cases,\n\u003E dev-dependencies are not needed when published, though some users (like OS\n\u003E packagers) may want to run tests within a crate, so providing a \u0060version\u0060 if\n\u003E possible can still be beneficial.\n"
        },
        "devDependencies0": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "example": {
          "type": "array",
          "items": {
            "$ref": "#/types/cargo:index:items"
          },
          "description": "Files located under the [examples directory](https://doc.rust-lang.org/cargo/guide/project-layout.html) are example uses of the functionality provided by the library. When compiled, they are placed in the[ target/debug/examples directory](https://doc.rust-lang.org/cargo/guide/build-cache.html).\n\nExamples can use the public API of the package\u0027s library. They are also linked with the [dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) and [dev-dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies) defined in Cargo.toml.\n\nBy default, examples are executable binaries (with a \u0060main()\u0060 function). You\ncan specify the [\u0060crate-type\u0060 field](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-crate-type-field) to make an example\nbe compiled as a library:\n\n\u0060\u0060\u0060toml\n[[example]]\nname = \u0022foo\u0022\ncrate-type = [\u0022staticlib\u0022]\n\u0060\u0060\u0060\n\nYou can run individual executable examples with the [\u0060cargo run\u0060](https://doc.rust-lang.org/cargo/commands/cargo-run.html) command with\nthe \u0060--example \u003Cexample-name\u003E\u0060 option. Library examples can be built with\n[\u0060cargo build\u0060](https://doc.rust-lang.org/cargo/commands/cargo-build.html) with the \u0060--example \u003Cexample-name\u003E\u0060 option. [\u0060cargo install\u0060](https://doc.rust-lang.org/cargo/commands/cargo-install.html)\nwith the \u0060--example \u003Cexample-name\u003E\u0060 option can be used to copy executable\nbinaries to a common location. Examples are compiled by [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html) by\ndefault to protect them from bit-rotting. Set [the \u0060test\u0060\nfield](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-test-field) to \u0060true\u0060 if you have \u0060#[test]\u0060 functions in the\nexample that you want to run with [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html).\n"
        },
        "features": {
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "description": "Cargo supports features to allow expression of:\n\n* conditional compilation options (usable through \u0060cfg\u0060 attributes);\n* optional dependencies, which enhance a package, but are not required; and\n* clusters of optional dependencies, such as \u0060postgres-all\u0060, that would include the\n  \u0060postgres\u0060 package, the \u0060postgres-macros\u0060 package, and possibly other packages\n  (such as development-time mocking libraries, debugging tools, etc.).\n\nA feature of a package is either an optional dependency, or a set of other\nfeatures.\n"
        },
        "lib": {
          "$ref": "#/types/cargo:index:lib"
        },
        "package": {
          "$ref": "#/types/cargo:index:package"
        },
        "patch": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            }
          },
          "description": "The \u0060[patch]\u0060 section of \u0060Cargo.toml\u0060 can be used to override dependencies\nwith other copies. The syntax is similar to the\n[\u0060[dependencies]\u0060](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) section.\n\n"
        },
        "profile": {
          "$ref": "#/types/cargo:index:profiles"
        },
        "project": {
          "$ref": "pulumi.json#/Any",
          "description": "Ref needs more translation map [(Json.Schema.UnrecognizedKeyword, [Json.Schema.UnrecognizedKeyword; Json.Schema.UnrecognizedKeyword])]"
        },
        "replace": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "target": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/types/cargo:index:platform"
          }
        },
        "test": {
          "type": "array",
          "items": {
            "$ref": "#/types/cargo:index:testItems"
          },
          "description": "Files located under the [\u0060tests\u0060 directory](https://doc.rust-lang.org/cargo/guide/project-layout.html) are integration\ntests. When you run [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html), Cargo will compile each of these files as\na separate crate, and execute them.\n\nIntegration tests can use the public API of the package\u0027s library. They are\nalso linked with the [\u0060[dependencies]\u0060](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) and\n[\u0060[dev-dependencies]\u0060](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies) defined in \u0060Cargo.toml\u0060.\n\nIf you want to share code among multiple integration tests, you can place it\nin a separate module such as \u0060tests/common/mod.rs\u0060 and then put \u0060mod common;\u0060\nin each test to import it.\n\nEach integration test results in a separate executable binary, and [\u0060cargo\ntest\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html) will run them serially. In some cases this can be inefficient, as it\ncan take longer to compile, and may not make full use of multiple CPUs when\nrunning the tests. If you have a lot of integration tests, you may want to\nconsider creating a single integration test, and split the tests into multiple\nmodules. The libtest harness will automatically find all of the \u0060#[test]\u0060\nannotated functions and run them in parallel. You can pass module names to\n[\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html) to only run the tests within that module.\n\nBinary targets are automatically built if there is an integration test. This\nallows an integration test to execute the binary to exercise and test its\nbehavior. The \u0060CARGO_BIN_EXE_\u003Cname\u003E\u0060 [environment variable](https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates) is set when the\nintegration test is built so that it can use the [\u0060env\u0060 macro](https://doc.rust-lang.org/std/macro.env.html) to locate the\nexecutable."
        },
        "workspace": {
          "$ref": "#/types/cargo:index:workspace"
        }
      }
    },
    "cargo:index:support": {
      "type": "object",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        }
      }
    },
    "cargo:index:target": {
      "type": "object",
      "description": "Benchmarks provide a way to test the performance of your code using the\n[\u0060cargo bench\u0060](https://doc.rust-lang.org/cargo/commands/cargo-bench.html) command. They follow the same structure as [tests](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#tests),\nwith each benchmark function annotated with the \u0060#[bench]\u0060 attribute.\nSimilarly to tests:\n\n* Benchmarks are placed in the [\u0060benches\u0060 directory](https://doc.rust-lang.org/cargo/guide/project-layout.html).\n* Benchmark functions defined in libraries and binaries have access to the\n  *private* API within the target they are defined in. Benchmarks in the\n  \u0060benches\u0060 directory may use the *public* API.\n* [The \u0060bench\u0060 field](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-bench-field) can be used to define which targets\n  are benchmarked by default.\n* [The \u0060harness\u0060 field](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-harness-field) can be used to disable the\n  built-in harness.\n\n\u003E **Note**: The [\u0060#[bench]\u0060\n\u003E attribute](https://doc.rust-lang.org/unstable-book/library-features/test.html) is currently\n\u003E unstable and only available on the [nightly channel](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html). There are some\n\u003E packages available on [crates.io](https://crates.io/keywords/benchmark) that\n\u003E may help with running benchmarks on the stable channel, such as\n\u003E [Criterion](https://crates.io/crates/criterion).",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "bench": {
          "type": "boolean",
          "description": "The \u0060bench\u0060 field indicates whether or not the target is benchmarked by\ndefault by [\u0060cargo bench\u0060](https://doc.rust-lang.org/cargo/commands/cargo-bench.html). The default is \u0060true\u0060 for lib, bins, and\nbenchmarks."
        },
        "crateType": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The \u0060crate-type\u0060 field defines the [crate types](https://doc.rust-lang.org/reference/linkage.html) that will be generated by the\ntarget. It is an array of strings, allowing you to specify multiple crate\ntypes for a single target. This can only be specified for libraries and\nexamples. Binaries, tests, and benchmarks are always the \u0022bin\u0022 crate type.\n\nThe available options are \u0060bin\u0060, \u0060lib\u0060, \u0060rlib\u0060, \u0060dylib\u0060, \u0060cdylib\u0060,\n\u0060staticlib\u0060, and \u0060proc-macro\u0060. You can read more about the different crate\ntypes in the [Rust Reference Manual](https://doc.rust-lang.org/reference/linkage.html)."
        },
        "crateType0": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "doc": {
          "type": "boolean",
          "description": "The \u0060doc\u0060 field indicates whether or not the target is included in the\ndocumentation generated by [\u0060cargo doc\u0060](https://doc.rust-lang.org/cargo/commands/cargo-doc.html) by default. The default is \u0060true\u0060 for\nlibraries and binaries.\n\n\u003E **Note**: The binary will be skipped if its name is the same as the lib\n\u003E target."
        },
        "doctest": {
          "type": "boolean",
          "description": "The \u0060doctest\u0060 field indicates whether or not [documentation examples](https://doc.rust-lang.org/rustdoc/documentation-tests.html) are\ntested by default by [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html). This is only relevant for libraries, it\nhas no effect on other sections. The default is \u0060true\u0060 for the library.\n"
        },
        "edition": {
          "$ref": "#/types/cargo:index:edition"
        },
        "harness": {
          "type": "boolean",
          "description": "The \u0060harness\u0060 field indicates that the [\u0060--test\u0060 flag](https://doc.rust-lang.org/rustc/command-line-arguments.html#option-test) will be passed to\n\u0060rustc\u0060 which will automatically include the libtest library which is the\ndriver for collecting and running tests marked with the [\u0060#[test]\u0060 attribute](https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute) or benchmarks with the \u0060#[bench]\u0060 attribute. The\ndefault is \u0060true\u0060 for all targets.\n\nIf set to \u0060false\u0060, then you are responsible for defining a \u0060main()\u0060 function\nto run tests and benchmarks.\n\nTests have the [\u0060cfg(test)\u0060 conditional expression](https://doc.rust-lang.org/reference/conditional-compilation.html#test) enabled whether\nor not the harness is enabled."
        },
        "name": {
          "type": "string",
          "description": "The \u0060name\u0060 field specifies the name of the target, which corresponds to the\nfilename of the artifact that will be generated. For a library, this is the\ncrate name that dependencies will use to reference it.\n\nFor the \u0060[lib]\u0060 and the default binary (\u0060src/main.rs\u0060), this defaults to the\nname of the package, with any dashes replaced with underscores. For other\n[auto discovered](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery) targets, it defaults to the\ndirectory or file name.\n\nThis is required for all targets except \u0060[lib]\u0060."
        },
        "path": {
          "type": "string",
          "description": "The \u0060path\u0060 field specifies where the source for the crate is located, relative\nto the \u0060Cargo.toml\u0060 file.\n\nIf not specified, the [inferred path](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery) is used based on\nthe target name."
        },
        "plugin": {
          "type": "boolean"
        },
        "procMacro": {
          "type": "boolean",
          "description": "The \u0060proc-macro\u0060 field indicates that the library is a [procedural macro](https://doc.rust-lang.org/book/ch19-06-macros.html)\n([reference](https://doc.rust-lang.org/reference/procedural-macros.html)). This is only valid for the \u0060[lib]\u0060\ntarget."
        },
        "procMacro0": {
          "type": "boolean"
        },
        "requiredFeatures": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The \u0060required-features\u0060 field specifies which [features](https://doc.rust-lang.org/cargo/reference/features.html) the target needs in\norder to be built. If any of the required features are not enabled, the\ntarget will be skipped. This is only relevant for the \u0060[[bin]]\u0060, \u0060[[bench]]\u0060,\n\u0060[[test]]\u0060, and \u0060[[example]]\u0060 sections, it has no effect on \u0060[lib]\u0060.\n\n\u0060\u0060\u0060toml\n[features]\n# ...\npostgres = []\nsqlite = []\ntools = []\n\n[[bin]]\nname = \u0022my-pg-tool\u0022\nrequired-features = [\u0022postgres\u0022, \u0022tools\u0022]\n\u0060\u0060\u0060\n"
        },
        "test": {
          "type": "boolean",
          "description": "The \u0060test\u0060 field indicates whether or not the target is tested by default by\n[\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html). The default is \u0060true\u0060 for lib, bins, and tests.\n\n\u003E **Note**: Examples are built by [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html) by default to ensure they\n\u003E continue to compile, but they are not *tested* by default. Setting \u0060test =\n\u003E true\u0060 for an example will also build it as a test and run any\n\u003E [\u0060#[test]\u0060](https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute) functions defined in the example."
        }
      }
    },
    "cargo:index:test": {
      "type": "object",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "buildOverride": {
          "$ref": "#/types/cargo:index:test"
        },
        "codegenUnits": {
          "type": "integer",
          "description": "The \u0060codegen-units\u0060 setting controls the [\u0060-C codegen-units\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#codegen-units) which\ncontrols how many \u0022code generation units\u0022 a crate will be split into. More\ncode generation units allows more of a crate to be processed in parallel\npossibly reducing compile time, but may produce slower code.\n\nThis option takes an integer greater than 0.\n\nThe default is 256 for [incremental](https://doc.rust-lang.org/cargo/reference/profiles.html#incremental) builds, and 16 for\nnon-incremental builds."
        },
        "debug": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "debugAssertions": {
          "type": "boolean",
          "description": "The \u0060debug-assertions\u0060 setting controls the [\u0060-C debug-assertions\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#debug-assertions) which\nturns \u0060cfg(debug_assertions)\u0060 [conditional compilation](https://doc.rust-lang.org/reference/conditional-compilation.html#debug_assertions) on or off. Debug\nassertions are intended to include runtime validation which is only available\nin debug/development builds. These may be things that are too expensive or\notherwise undesirable in a release build. Debug assertions enables the\n[\u0060debug_assert!\u0060 macro](https://doc.rust-lang.org/std/macro.debug_assert.html) in the standard library."
        },
        "dirName": {
          "type": "string"
        },
        "incremental": {
          "type": "boolean",
          "description": "The \u0060incremental\u0060 setting controls the [\u0060-C incremental\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#incremental) which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses \u0060rustc\u0060 to to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times. The additional\ninformation is stored in the \u0060target\u0060 directory.\n\nThe valid options are:\n\n* \u0060true\u0060: enabled\n* \u0060false\u0060: disabled\n\nIncremental compilation is only used for workspace members and \u0022path\u0022\ndependencies.\n\nThe incremental value can be overridden globally with the \u0060CARGO_INCREMENTAL\u0060\n[environment variable](https://doc.rust-lang.org/cargo/reference/environment-variables.html) or the [\u0060build.incremental\u0060](https://doc.rust-lang.org/cargo/reference/config.html#buildincremental) config variable."
        },
        "inherits": {
          "type": "string"
        },
        "lto": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "optLevel": {
          "$ref": "pulumi.json#/Any",
          "description": "unhandled schema: Json.Schema.TitleKeyword, Json.Schema.DescriptionKeyword, Json.Schema.EnumKeyword, Json.Schema.UnrecognizedKeyword"
        },
        "overflowChecks": {
          "type": "boolean",
          "description": "The \u0060overflow-checks\u0060 setting controls the [\u0060-C overflow-checks\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#overflow-checks) which\ncontrols the behavior of [runtime integer overflow](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow). When overflow-checks are\nenabled, a panic will occur on overflow."
        },
        "package": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/types/cargo:index:test"
          },
          "description": "Package-specific overrides.\n\nThe package name is a [Package ID Spec](https://doc.rust-lang.org/cargo/reference/pkgid-spec.html), so you can\ntarget individual versions of a package with syntax such as \u0060[profile.dev.package.\u0022foo:2.1.0\u0022]\u0060."
        },
        "panic": {
          "$ref": "#/types/cargo:index:testPanic"
        },
        "rpath": {
          "type": "boolean",
          "description": "The \u0060rpath\u0060 setting controls the [\u0060-C rpath\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#rpath) which controls\nwhether or not [\u0060rpath\u0060](https://en.wikipedia.org/wiki/Rpath) is enabled."
        }
      }
    },
    "cargo:index:testItems": {
      "type": "object",
      "description": "Files located under the [\u0060tests\u0060 directory](https://doc.rust-lang.org/cargo/guide/project-layout.html) are integration\ntests. When you run [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html), Cargo will compile each of these files as\na separate crate, and execute them.\n\nIntegration tests can use the public API of the package\u0027s library. They are\nalso linked with the [\u0060[dependencies]\u0060](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) and\n[\u0060[dev-dependencies]\u0060](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies) defined in \u0060Cargo.toml\u0060.\n\nIf you want to share code among multiple integration tests, you can place it\nin a separate module such as \u0060tests/common/mod.rs\u0060 and then put \u0060mod common;\u0060\nin each test to import it.\n\nEach integration test results in a separate executable binary, and [\u0060cargo\ntest\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html) will run them serially. In some cases this can be inefficient, as it\ncan take longer to compile, and may not make full use of multiple CPUs when\nrunning the tests. If you have a lot of integration tests, you may want to\nconsider creating a single integration test, and split the tests into multiple\nmodules. The libtest harness will automatically find all of the \u0060#[test]\u0060\nannotated functions and run them in parallel. You can pass module names to\n[\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html) to only run the tests within that module.\n\nBinary targets are automatically built if there is an integration test. This\nallows an integration test to execute the binary to exercise and test its\nbehavior. The \u0060CARGO_BIN_EXE_\u003Cname\u003E\u0060 [environment variable](https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates) is set when the\nintegration test is built so that it can use the [\u0060env\u0060 macro](https://doc.rust-lang.org/std/macro.env.html) to locate the\nexecutable.",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "bench": {
          "type": "boolean",
          "description": "The \u0060bench\u0060 field indicates whether or not the target is benchmarked by\ndefault by [\u0060cargo bench\u0060](https://doc.rust-lang.org/cargo/commands/cargo-bench.html). The default is \u0060true\u0060 for lib, bins, and\nbenchmarks."
        },
        "crateType": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The \u0060crate-type\u0060 field defines the [crate types](https://doc.rust-lang.org/reference/linkage.html) that will be generated by the\ntarget. It is an array of strings, allowing you to specify multiple crate\ntypes for a single target. This can only be specified for libraries and\nexamples. Binaries, tests, and benchmarks are always the \u0022bin\u0022 crate type.\n\nThe available options are \u0060bin\u0060, \u0060lib\u0060, \u0060rlib\u0060, \u0060dylib\u0060, \u0060cdylib\u0060,\n\u0060staticlib\u0060, and \u0060proc-macro\u0060. You can read more about the different crate\ntypes in the [Rust Reference Manual](https://doc.rust-lang.org/reference/linkage.html)."
        },
        "crateType0": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "doc": {
          "type": "boolean",
          "description": "The \u0060doc\u0060 field indicates whether or not the target is included in the\ndocumentation generated by [\u0060cargo doc\u0060](https://doc.rust-lang.org/cargo/commands/cargo-doc.html) by default. The default is \u0060true\u0060 for\nlibraries and binaries.\n\n\u003E **Note**: The binary will be skipped if its name is the same as the lib\n\u003E target."
        },
        "doctest": {
          "type": "boolean",
          "description": "The \u0060doctest\u0060 field indicates whether or not [documentation examples](https://doc.rust-lang.org/rustdoc/documentation-tests.html) are\ntested by default by [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html). This is only relevant for libraries, it\nhas no effect on other sections. The default is \u0060true\u0060 for the library.\n"
        },
        "edition": {
          "$ref": "#/types/cargo:index:testItemsEdition"
        },
        "harness": {
          "type": "boolean",
          "description": "The \u0060harness\u0060 field indicates that the [\u0060--test\u0060 flag](https://doc.rust-lang.org/rustc/command-line-arguments.html#option-test) will be passed to\n\u0060rustc\u0060 which will automatically include the libtest library which is the\ndriver for collecting and running tests marked with the [\u0060#[test]\u0060 attribute](https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute) or benchmarks with the \u0060#[bench]\u0060 attribute. The\ndefault is \u0060true\u0060 for all targets.\n\nIf set to \u0060false\u0060, then you are responsible for defining a \u0060main()\u0060 function\nto run tests and benchmarks.\n\nTests have the [\u0060cfg(test)\u0060 conditional expression](https://doc.rust-lang.org/reference/conditional-compilation.html#test) enabled whether\nor not the harness is enabled."
        },
        "name": {
          "type": "string",
          "description": "The \u0060name\u0060 field specifies the name of the target, which corresponds to the\nfilename of the artifact that will be generated. For a library, this is the\ncrate name that dependencies will use to reference it.\n\nFor the \u0060[lib]\u0060 and the default binary (\u0060src/main.rs\u0060), this defaults to the\nname of the package, with any dashes replaced with underscores. For other\n[auto discovered](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery) targets, it defaults to the\ndirectory or file name.\n\nThis is required for all targets except \u0060[lib]\u0060."
        },
        "path": {
          "type": "string",
          "description": "The \u0060path\u0060 field specifies where the source for the crate is located, relative\nto the \u0060Cargo.toml\u0060 file.\n\nIf not specified, the [inferred path](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery) is used based on\nthe target name."
        },
        "plugin": {
          "type": "boolean"
        },
        "procMacro": {
          "type": "boolean",
          "description": "The \u0060proc-macro\u0060 field indicates that the library is a [procedural macro](https://doc.rust-lang.org/book/ch19-06-macros.html)\n([reference](https://doc.rust-lang.org/reference/procedural-macros.html)). This is only valid for the \u0060[lib]\u0060\ntarget."
        },
        "procMacro0": {
          "type": "boolean"
        },
        "requiredFeatures": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The \u0060required-features\u0060 field specifies which [features](https://doc.rust-lang.org/cargo/reference/features.html) the target needs in\norder to be built. If any of the required features are not enabled, the\ntarget will be skipped. This is only relevant for the \u0060[[bin]]\u0060, \u0060[[bench]]\u0060,\n\u0060[[test]]\u0060, and \u0060[[example]]\u0060 sections, it has no effect on \u0060[lib]\u0060.\n\n\u0060\u0060\u0060toml\n[features]\n# ...\npostgres = []\nsqlite = []\ntools = []\n\n[[bin]]\nname = \u0022my-pg-tool\u0022\nrequired-features = [\u0022postgres\u0022, \u0022tools\u0022]\n\u0060\u0060\u0060\n"
        },
        "test": {
          "type": "boolean",
          "description": "The \u0060test\u0060 field indicates whether or not the target is tested by default by\n[\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html). The default is \u0060true\u0060 for lib, bins, and tests.\n\n\u003E **Note**: Examples are built by [\u0060cargo test\u0060](https://doc.rust-lang.org/cargo/commands/cargo-test.html) by default to ensure they\n\u003E continue to compile, but they are not *tested* by default. Setting \u0060test =\n\u003E true\u0060 for an example will also build it as a test and run any\n\u003E [\u0060#[test]\u0060](https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute) functions defined in the example."
        }
      }
    },
    "cargo:index:testItemsEdition": {
      "description": "The \u0060edition\u0060 key affects which edition your package is compiled with. Cargo\nwill always generate packages via [\u0060cargo new\u0060](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the \u0060edition\u0060 key set to the\nlatest edition. Setting the \u0060edition\u0060 key in \u0060[package]\u0060 will affect all\ntargets/crates in the package, including test suites, benchmarks, binaries,\nexamples, etc.",
      "type": "string",
      "enum": [
        {
          "value": "2015"
        },
        {
          "value": "2018"
        },
        {
          "value": "2021"
        },
        {
          "value": "2024"
        }
      ]
    },
    "cargo:index:testPanic": {
      "description": "The \u0060panic\u0060 setting controls the [\u0060-C panic\u0060 flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic) which controls which panic\nstrategy to use.\n\nWhen set to \u0060\u0022unwind\u0022\u0060, the actual value depends on the default of the target\nplatform. For example, the NVPTX platform does not support unwinding, so it\nalways uses \u0060\u0022abort\u0022\u0060.\n\nTests, benchmarks, build scripts, and proc macros ignore the \u0060panic\u0060 setting.\nThe \u0060rustc\u0060 test harness currently requires \u0060unwind\u0060 behavior. See the\n[\u0060panic-abort-tests\u0060](https://doc.rust-lang.org/cargo/reference/unstable.html#panic-abort-tests) unstable flag which enables \u0060abort\u0060 behavior.\n\nAdditionally, when using the \u0060abort\u0060 strategy and building a test, all of the\ndependencies will also be forced to built with the \u0060unwind\u0060 strategy.",
      "type": "string",
      "enum": [
        {
          "value": "unwind"
        },
        {
          "value": "abort"
        }
      ]
    },
    "cargo:index:workspace": {
      "type": "object",
      "description": "The \u0060[workspace]\u0060 table in \u0060Cargo.toml\u0060 defines which packages are members of\nthe workspace:\n\n\u0060\u0060\u0060toml\n[workspace]\nmembers = [\u0022member1\u0022, \u0022path/to/member2\u0022, \u0022crates/*\u0022]\nexclude = [\u0022crates/foo\u0022, \u0022path/to/other\u0022]\n\u0060\u0060\u0060\n\nAn empty \u0060[workspace]\u0060 table can be used with a \u0060[package]\u0060 to conveniently\ncreate a workspace with the package and all of its path dependencies.\n\nAll [\u0060path\u0060 dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies) residing in the workspace directory automatically\nbecome members. Additional members can be listed with the \u0060members\u0060 key, which\nshould be an array of strings containing directories with \u0060Cargo.toml\u0060 files.\n\nThe \u0060members\u0060 list also supports [globs](https://docs.rs/glob/0.3.0/glob/struct.Pattern.html) to match multiple paths, using\ntypical filename glob patterns like \u0060*\u0060 and \u0060?\u0060.\n\nThe \u0060exclude\u0060 key can be used to prevent paths from being included in a\nworkspace. This can be useful if some path dependencies aren\u0027t desired to be\nin the workspace at all, or using a glob pattern and you want to remove a\ndirectory.\n\nAn empty \u0060[workspace]\u0060 table can be used with a \u0060[package]\u0060 to conveniently\ncreate a workspace with the package and all of its path dependencies.",
      "properties": {
        "additionalProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          }
        },
        "defaultMembers": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The optional \u0060default-members\u0060 key can be specified to set the members to\noperate on when in the workspace root and the package selection flags are not\nused:\n\n\u0060\u0060\u0060toml\n[workspace]\nmembers = [\u0022path/to/member1\u0022, \u0022path/to/member2\u0022, \u0022path/to/member3/*\u0022]\ndefault-members = [\u0022path/to/member2\u0022, \u0022path/to/member3/foo\u0022]\n\u0060\u0060\u0060\n\nWhen specified, \u0060default-members\u0060 must expand to a subset of \u0060members\u0060."
        },
        "dependencies": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "The \u0060workspace.dependencies\u0060 table is where you define dependencies to be\ninherited by members of a workspace.\n\nSpecifying a workspace dependency is similar to [package dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) except:\n- Dependencies from this table cannot be declared as \u0060optional\u0060\n- [\u0060features\u0060][features] declared in this table are additive with the \u0060features\u0060 from \u0060[dependencies]\u0060\n\nYou can then [inherit the workspace dependency as a package dependency](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace)\n\nExample:\n\u0060\u0060\u0060toml\n# [PROJECT_DIR]/Cargo.toml\n[workspace]\nmembers = [\u0022bar\u0022]\n\n[workspace.dependencies]\ncc = \u00221.0.73\u0022\nrand = \u00220.8.5\u0022\nregex = { version = \u00221.6.0\u0022, default-features = false, features = [\u0022std\u0022] }\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060toml\n# [PROJECT_DIR]/bar/Cargo.toml\n[package]\nname = \u0022bar\u0022\nversion = \u00220.2.0\u0022\n\n[dependencies]\nregex = { workspace = true, features = [\u0022unicode\u0022] }\n\n[build-dependencies]\ncc.workspace = true\n\n[dev-dependencies]\nrand.workspace = true\n\u0060\u0060\u0060"
        },
        "exclude": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The \u0060exclude\u0060 key can be used to prevent paths from being included in a\nworkspace. This can be useful if some path dependencies aren\u0027t desired to be\nin the workspace at all, or using a glob pattern and you want to remove a\ndirectory."
        },
        "members": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "All [\u0060path\u0060 dependencies] residing in the workspace directory automatically\nbecome members. Additional members can be listed with the \u0060members\u0060 key, which\nshould be an array of strings containing directories with \u0060Cargo.toml\u0060 files.\n\nThe \u0060members\u0060 list also supports [globs] to match multiple paths, using\ntypical filename glob patterns like \u0060*\u0060 and \u0060?\u0060."
        },
        "metadata": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "The \u0060workspace.metadata\u0060 table is ignored by Cargo and will not be warned\nabout. This section can be used for tools that would like to store workspace\nconfiguration in \u0060Cargo.toml\u0060. For example:\n\n\u0060\u0060\u0060toml\n[workspace]\nmembers = [\u0022member1\u0022, \u0022member2\u0022]\n\n[workspace.metadata.webcontents]\nroot = \u0022path/to/webproject\u0022\ntool = [\u0022npm\u0022, \u0022run\u0022, \u0022build\u0022]\n# ...\n\u0060\u0060\u0060\n\nThere is a similar set of tables at the package level at\n\u0060package.metadata\u0060. While cargo does not specify a\nformat for the content of either of these tables, it is suggested that\nexternal tools may wish to use them in a consistent fashion, such as referring\nto the data in \u0060workspace.metadata\u0060 if data is missing from \u0060package.metadata\u0060,\nif that makes sense for the tool in question.\n"
        },
        "package": {
          "$ref": "#/types/cargo:index:propertiesPackage"
        },
        "resolver": {
          "$ref": "#/types/cargo:index:definitionsResolver"
        }
      }
    }
  }
}